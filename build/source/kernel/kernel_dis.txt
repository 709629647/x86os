
D:/mylinux/diy-x86os-master-20230506/start/start/build/source/kernel/kernel.elf:     file format elf32-i386
D:/mylinux/diy-x86os-master-20230506/start/start/build/source/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x0000a23d memsz 0x0000a23d flags r-x
    LOAD off    0x0000c000 vaddr 0x0001b000 paddr 0x0001b000 align 2**12
         filesz 0x00000178 memsz 0x00045204 flags rw-
    LOAD off    0x0000d000 vaddr 0x80000000 paddr 0x00060204 align 2**12
         filesz 0x000003e3 memsz 0x000003e3 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00009019  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       0000121d  00019020  00019020  0000a020  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000178  0001b000  0001b000  0000c000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00044204  0001c000  0001c000  0000c178  2**12
                  ALLOC
  4 .first_task   000003e3  80000000  00060204  0000d000  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  5 .debug_line   000063ee  00000000  00000000  0000d3e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001616a  00000000  00000000  000137d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000376a  00000000  00000000  0002993b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000340  00000000  00000000  0002d0a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 000000a8  00000000  00000000  0002d3e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002d3c  00000000  00000000  0002d490  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      00000011  00000000  00000000  000301cc  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00002e28  00000000  00000000  000301e0  2**2
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
00019020 l    d  .rodata	00000000 .rodata
0001b000 l    d  .data	00000000 .data
0001c000 l    d  .bss	00000000 .bss
80000000 l    d  .first_task	00000000 .first_task
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 CMakeFiles/kernel.dir/init/start.S.obj
00010010 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 memory.c
000102f4 l     F .text	0000000c write_cr3
00010300 l     F .text	00000017 up2
00010317 l     F .text	0000000d down2
00010324 l     F .text	00000011 mmu_set_page_dir
00010335 l     F .text	0000000b pde_index
00010340 l     F .text	00000010 pte_index
00010350 l     F .text	00000027 pde_paddr
00010377 l     F .text	00000027 pte_paddr
0001039e l     F .text	0000000f get_pte_perm
0001c000 l     O .bss	00000028 paddr_alloc
0001d000 l     O .bss	00001000 kernel_page_dir
000103ad l     F .text	00000058 addr_alloc_init
00010405 l     F .text	00000067 addr_alloc_page
0001046c l     F .text	0000005e addr_free_page
000104ca l     F .text	00000066 show_mem_info
00010530 l     F .text	0000003c total_mem_size
00019164 l     O .rodata	00000012 __func__.2518
0001b000 l     O .data	00000050 kernel_map.2528
00019178 l     O .rodata	0000000c __func__.2547
00019184 l     O .rodata	00000011 __func__.2583
00019198 l     O .rodata	00000009 __func__.2647
00000000 l    df *ABS*	00000000 syscall.c
00010e72 l     F .text	0000001d inb
00010e8f l     F .text	0000001f inw
00010eae l     F .text	0000001f outb
00010ecd l     F .text	0000012f read_disk
000191c0 l     O .rodata	00000194 syscall_table
00000000 l    df *ABS*	00000000 task.c
0001107c l     F .text	0000001d inb
00011099 l     F .text	0000001f inw
000110b8 l     F .text	0000001f outb
000110d7 l     F .text	0000000c write_cr3
000110e3 l     F .text	0000001a far_jump
000110fd l     F .text	00000007 hlt
00011104 l     F .text	00000017 ltr
0001111b l     F .text	0000001b list_node_init
00011136 l     F .text	0000000b list_count
00011141 l     F .text	0000000a list_first
0001114b l     F .text	00000011 mmu_set_page_dir
0001115c l     F .text	0000012f read_disk
0001e000 l     O .bss	00001000 idle_stack
0001f000 l     O .bss	00000014 task_table_mutex
0001f020 l     O .bss	00016400 task_table
00011333 l     F .text	000001b6 tss_init
000194c8 l     O .rodata	00000010 __func__.3190
0001210c l     F .text	0000006c alloc_task
00012178 l     F .text	00000033 free_task
000121ab l     F .text	000001e3 load_elf_file
000194d8 l     O .rodata	0000000d __func__.3289
00000000 l    df *ABS*	00000000 cpu.c
000126e9 l     F .text	00000028 lgdt
00035420 l     O .bss	00000800 gdt_table
00035c20 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 irq.c
0001292e l     F .text	0000001d inb
0001294b l     F .text	0000001f inw
0001296a l     F .text	0000001f outb
00012989 l     F .text	00000007 cli
00012990 l     F .text	00000007 sti
00012997 l     F .text	00000028 lidt
000129bf l     F .text	00000011 read_cr2
000129d0 l     F .text	00000007 hlt
000129d7 l     F .text	00000010 read_eflags
000129e7 l     F .text	0000000b write_eflags
000129f2 l     F .text	0000012f read_disk
00035c40 l     O .bss	00000400 idt_table
00012b21 l     F .text	000000ff dump_core_regs
00012c20 l     F .text	00000071 do_default_handler
00013092 l     F .text	00000093 init_pic
00000000 l    df *ABS*	00000000 console.c
0001344f l     F .text	0000001d inb
0001346c l     F .text	0000001f outb
00036040 l     O .bss	00000340 console_buf
00036380 l     O .bss	00000004 curr_console_idx
0001348b l     F .text	00000074 read_cursor_pos
000134ff l     F .text	000000bf update_cursor_pos
00013f13 l     F .text	00000088 scroll_up
00013ac5 l     F .text	00000099 set_font_style
00019a80 l     O .rodata	00000020 color_table.2502
00013b5e l     F .text	00000049 move_right
00013ba7 l     F .text	00000037 move_left
00013bde l     F .text	0000001e move_cursor
00013bfc l     F .text	00000054 erase_in_display
00013eac l     F .text	00000067 erase_rows
00013c50 l     F .text	000000fa write_esc_square
00000000 l    df *ABS*	00000000 dev.c
0001b050 l     O .data	00000008 dev_desc_tbl
000363a0 l     O .bss	00000a00 dev_tbl
00013f9b l     F .text	0000003e is_devid_bad
00000000 l    df *ABS*	00000000 disk.c
0001428b l     F .text	0000001d inb
000142a8 l     F .text	0000001f inw
000142c7 l     F .text	0000001f outb
000142e6 l     F .text	00000021 outw
00036da0 l     O .bss	00000250 disk_buf
00036ff0 l     O .bss	00000014 mutex
00037004 l     O .bss	00000010 op_sem
00037014 l     O .bss	00000004 task_on_op
00014307 l     F .text	00000130 disk_send_cmd
00014437 l     F .text	00000050 disk_read_data
00014487 l     F .text	00000050 disk_write_data
000144d7 l     F .text	0000004b disk_wait_data
00014710 l     F .text	0000011d detect_part_info
00000000 l    df *ABS*	00000000 kbd.c
00014c3c l     F .text	0000001d inb
00019bc0 l     O .rodata	00000200 map_table
00014c88 l     F .text	0000003c do_fx_key
00014cc4 l     F .text	000001c2 do_normal_key
00037018 l     O .bss	00000004 recv_state.2396
0003701c l     O .bss	00000004 init.2414
00000000 l    df *ABS*	00000000 time.c
00015021 l     F .text	0000001f outb
00037020 l     O .bss	00000004 sys_tick
00015040 l     F .text	00000060 init_pit
00000000 l    df *ABS*	00000000 tty.c
00037040 l     O .bss	000022a0 tty_devs
000392e0 l     O .bss	00000004 curr_tty
00015314 l     F .text	0000004f get_tty
00000000 l    df *ABS*	00000000 devfs.c
00015671 l     F .text	0000001d inb
0001568e l     F .text	0000001f inw
000156ad l     F .text	0000001f outb
000156cc l     F .text	0000012f read_disk
0001b0e0 l     O .data	0000000c dev_type_table
00000000 l    df *ABS*	00000000 fatfs.c
000159c2 l     F .text	0000001d inb
000159df l     F .text	0000001f inw
000159fe l     F .text	0000001f outb
00015a1d l     F .text	0000012f read_disk
00015b4c l     F .text	00000017 up2
00000000 l    df *ABS*	00000000 file.c
00039300 l     O .bss	00024000 file_table
0005d300 l     O .bss	00000014 file_alloc_mutex
00000000 l    df *ABS*	00000000 fs.c
000171f3 l     F .text	0000001d inb
00017210 l     F .text	0000001f inw
0001722f l     F .text	0000001f outb
0001724e l     F .text	0000000b list_node_next
00017259 l     F .text	0000000a list_first
00017263 l     F .text	0000012f read_disk
0005d320 l     O .bss	0000000c mounted_list
0005d340 l     O .bss	000008c0 fs_table
0005dc00 l     O .bss	0000000c free_list
0005dc0c l     O .bss	00000004 root_fs
00017495 l     F .text	00000021 is_valid_path
00017cda l     F .text	0000001d is_file_bad
0001a0c8 l     O .rodata	0000000a __func__.3381
00017a41 l     F .text	00000074 mount_list_init
00000000 l    df *ABS*	00000000 init.c
00017f88 l     F .text	0000001d inb
00017fa5 l     F .text	0000001f inw
00017fc4 l     F .text	0000001f outb
00017fe3 l     F .text	0000012f read_disk
0001a1c0 l     O .rodata	0000000c __func__.3271
0005dc10 l     O .bss	00000010 sem
0001a1cc l     O .rodata	00000013 __func__.3277
00000000 l    df *ABS*	00000000 mutex.c
0001824b l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
000183da l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 klib.c
0001876f l     F .text	00000007 hlt
0001b174 l     O .data	00000004 num2ch.1950
00000000 l    df *ABS*	00000000 list.c
00018d25 l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
0005dc20 l     O .bss	00000014 mutex
0005dc34 l     O .bss	00000004 log_dev_id
00000000 l    df *ABS*	00000000 first_task.c
00000000 l    df *ABS*	00000000 lib_syscall.c
800000f0 l     F .first_task	0000004c sys_call
00018953 g     F .text	0000004f kernel_memcpy
00017835 g     F .text	000000ff sys_close
00017445 g     F .text	00000050 path_begin_with
800001c5 g     F .first_task	0000001c yield
00012ce7 g     F .text	0000001c do_handler_divider0
00013a50 g     F .text	00000075 write_esc
00013130 g     F .text	0000000b irq_enable_global
8000030a g     F .first_task	00000033 ioctl
000137dc g     F .text	0000003d erase_backword
00018dbc g     F .text	00000064 list_insert_last
0001128b g     F .text	00000030 task_file
0001027b g       .text	00000000 exception_handler_kbd
00010d66 g     F .text	0000010c sys_sbrk
00012dff g     F .text	0000001c do_handler_segment_not_present
00015bd0 g     F .text	0000012b cluster_alloc_free
00011c03 g     F .text	00000078 copy_open_files
0001869c g     F .text	0000001b bitmap_is_set
000189a2 g     F .text	00000041 kernel_memset
0001416f g     F .text	0000004c dev_write
000177ac g     F .text	00000089 sys_lseek
00014c59 g     F .text	0000001a is_makecode
00014fd2 g     F .text	0000004f kbd_init
00016e1c g     F .text	00000118 cluster_set_next
00010241 g       .text	00000000 exception_handler_virtual_exception
00014bfe g     F .text	00000006 disk_close
00010ffc g     F .text	00000080 do_handler_syscall
00012862 g     F .text	0000001e cpu_init
00018f1d g     F .text	0000002f log_init
00016d2b g     F .text	000000e7 fatfs_readdir
00011c7b g     F .text	00000188 sys_fork
000181d0 g     F .text	0000007b init_main
000101ec g       .text	00000000 exception_handler_alignment_check
00014bf4 g     F .text	0000000a disk_control
00015cfb g     F .text	00000175 expand_filesz
00011be9 g     F .text	0000001a sys_print_msg
0005fc40 g     O .bss	000005c0 task_manager
0001b140 g     O .data	00000034 fatfs_op
000187e7 g     F .text	00000047 kernel_strcpy
00014f48 g     F .text	0000008a do_e0_key
0001b000 g       .data	00000000 s_data
800001e1 g     F .first_task	0000002e execve
00010a39 g     F .text	00000010 curr_page_dir
80000166 g     F .first_task	0000001b getpid
0001313b g     F .text	0000008b irq_enable
00010028 g       .text	00000000 exception_handler_unknown
00013772 g     F .text	0000006a show_console
0001009c g       .text	00000000 exception_handler_breakpoint
000118dd g     F .text	00000034 set_ready
00012d57 g     F .text	0000001c do_handler_overflow
00013022 g     F .text	0000001c do_handler_alignment_check
0001061c g     F .text	0000009d memory_create_map
000176c8 g     F .text	00000088 sys_read
000173ed g     F .text	00000058 path_next_child
000167c7 g     F .text	0000021c fatfs_write
00013819 g     F .text	000000b7 console_select
00010199 g       .text	00000000 exception_handler_general_protection
00012e37 g     F .text	000000d8 do_handler_general_protection
000184f5 g     F .text	00000029 sem_count
80000010 g     F .first_task	000000bd first_task_main
00012dc7 g     F .text	0000001c do_handler_double_fault
00016e12 g     F .text	0000000a fatfs_closedir
00012f0f g     F .text	000000f7 do_handler_page_fault
000145e9 g     F .text	00000127 identify_disk
00015e70 g     F .text	00000242 fatfs_mount
8000033d g     F .first_task	00000021 isatty
00016624 g     F .text	000001a3 fatfs_read
0001012d g       .text	00000000 exception_handler_double_fault
000133fb g     F .text	0000002b pic_send_eoi
00011fdc g     F .text	00000130 cpy_to_stack
000150e0 g     F .text	00000037 fifo_init
8000013c g     F .first_task	0000002a sleep
000118d3 g     F .text	0000000a task_first_task
00010000 g       .text	00000000 s_text
00010828 g     F .text	00000088 memory_create_uvm
00018408 g     F .text	0000006b sem_wait
0001017e g       .text	00000000 exception_handler_stack_segment_fault
000116ed g     F .text	0000000a idle_task_func
000179a5 g     F .text	0000009c sys_fstat
00014123 g     F .text	0000004c dev_read
00016a6d g     F .text	000000df fatfs_seek
000169e3 g     F .text	0000008a fatfs_close
00013076 g     F .text	0000001c do_handler_virtual_exception
00015998 g     F .text	0000000a devfs_stat
000100b9 g       .text	00000000 exception_handler_overflow
000102b5 g       .text	00000000 simple_switch
00010298 g       .text	00000000 exception_handler_ide_primary
000160b2 g     F .text	0000003c fatfs_unmount
00017183 g     F .text	00000038 ref_inc
80000293 g     F .first_task	0000002e lseek
0001025e g       .text	00000000 exception_handler_time
00013948 g     F .text	000000a3 write_normal
0005dc40 g     O .bss	00002000 stack
00011b81 g     F .text	0000005b sys_sleep
0001482d g     F .text	000000f8 disk_init
00017c91 g     F .text	00000049 fs_init
000109a0 g     F .text	00000099 memory_free_page
00060204 g       *ABS*	00000000 s_first_task
0001130e g     F .text	00000025 task_remove_fd
000155e7 g     F .text	0000005b tty_control
00013619 g     F .text	000000e3 console_init
00015363 g     F .text	00000122 tty_read
00011640 g     F .text	0000008f task_uninit
000174e1 g     F .text	0000002b fs_unprotect
000108d5 g     F .text	000000b1 memory_alloc_for_page_dir
000159a2 g     F .text	00000020 devfs_ioctl
000151fd g     F .text	0000007f tty_fifo_get
000100d6 g       .text	00000000 exception_handler_bound_range
0001557a g     F .text	0000006d tty_in
000164a7 g     F .text	000000bb cluster_get_next
00018473 g     F .text	00000082 sem_notify
00010ce3 g     F .text	00000083 memory_copy_uvm_data
000141bb g     F .text	0000004c dev_control
00014e86 g     F .text	000000c2 do_handler_kbd
00013426 g     F .text	00000018 enter_protection
00012d8f g     F .text	0000001c do_handler_invalid_opcode
00010148 g       .text	00000000 exception_handler_invalid_tss
000150c8 g     F .text	00000018 timer_init
00017e95 g     F .text	00000053 sys_readdir
00013006 g     F .text	0000001c do_handler_fpu_error
0001303e g     F .text	0000001c do_handler_machine_check
80000265 g     F .first_task	0000002e write
000136fc g     F .text	00000076 move_forward
0001750c g     F .text	000001bc sys_open
000174b6 g     F .text	0000002b fs_protect
00012d03 g     F .text	0000001c do_handler_Debug
800002e3 g     F .first_task	00000027 fstat
000187a1 g     F .text	00000046 get_filename
00017934 g     F .text	00000071 sys_isatty
00018d5d g     F .text	0000005f list_insert_first
00013fd9 g     F .text	0000014a dev_open
80000181 g     F .first_task	00000028 mprint_msg
00017392 g     F .text	0000005b path_to_num
00015b63 g     F .text	0000006d get_item_type
000117de g     F .text	000000f5 first_task_init
00012d1f g     F .text	0000001c do_handler_NMI
0001b060 g     O .data	00000038 dev_disk_desc
00013e64 g     F .text	00000010 set_col0
0001238e g     F .text	000000c2 load_phdr
0001882e g     F .text	00000070 kernel_strncpy
000128f5 g     F .text	00000039 gdt_free_tss
00013125 g     F .text	0000000b irq_disable_global
000135be g     F .text	0000005b console_clear
00017750 g     F .text	0000005c sys_write
800003c2 g     F .first_task	00000021 wait
000605e7 g       *ABS*	00000000 mem_free_start
00018112 g     F .text	00000058 kernel_init
000183e5 g     F .text	00000023 sem_init
00011b24 g     F .text	0000003d set_sleep
00010000 g       .text	00000000 _start
00018ba4 g     F .text	0000014b kernel_vsprintf
00010110 g       .text	00000000 exception_handler_device_unavailable
000100f3 g       .text	00000000 exception_handler_invalid_opcode
00014207 g     F .text	00000084 dev_close
000139eb g     F .text	0000001e save_cursor
00060204 g       .bss	00000000 e_data
80000237 g     F .first_task	0000002e read
00018284 g     F .text	00000096 mutex_lock
00017ee8 g     F .text	00000050 sys_closedir
00016f8e g     F .text	000000f8 fatfs_unlink
000112bb g     F .text	00000053 task_alloc_fd
0001598e g     F .text	0000000a devfs_seek
00016c81 g     F .text	000000aa write_dir_ent
00010207 g       .text	00000000 exception_handler_machine_check
00015485 g     F .text	000000f5 tty_write
00012de3 g     F .text	0000001c do_handler_invalid_tss
0001527c g     F .text	00000098 tty_fifo_put
00016bfc g     F .text	00000085 read_dir_ent
000605e7 g       *ABS*	00000000 e_first_task
00013a09 g     F .text	0000001e load_cursor
000185c8 g     F .text	000000d4 bitmap_set_nbit
000138d0 g     F .text	00000078 cursor_backword
00017da4 g     F .text	0000009e sys_dup
00012c91 g     F .text	0000003a irq_install
000186b7 g     F .text	000000b8 bitmap_alloc_nbit
000127de g     F .text	00000084 init_gdt
000157fb g     F .text	00000017 devfs_mount
00015117 g     F .text	000000e6 tty_open
800001a9 g     F .first_task	0000001c fork
00018256 g     F .text	0000002e mutex_init
00011a20 g     F .text	0000000a current_task
000131c6 g     F .text	00000087 irq_disable
000163e7 g     F .text	00000029 clust_is_valid
8000035e g     F .first_task	00000021 sbrk
0001b100 g     O .data	00000034 devfs_op
00013e74 g     F .text	00000038 add_row1
00015818 g     F .text	00000113 devfs_open
00010224 g       .text	00000000 exception_handler_smd_exception
00017cf7 g     F .text	000000ad sys_ioctl
00014522 g     F .text	000000c7 print_disk_info
00016410 g     F .text	00000059 bread_sector
00010b9e g     F .text	000000ff memory_destroy_uvm
000108b0 g     F .text	00000025 memory_alloc_for_page
00012dab g     F .text	0000001c do_handler_device_unavailable
00017f38 g     F .text	00000050 sys_unlink
00016155 g     F .text	0000008b to_snf
00016b56 g     F .text	00000013 fatfs_opendir
000119de g     F .text	00000042 task_dispatch
00010a49 g     F .text	00000155 memory_copy_uvm
00015642 g     F .text	00000006 tty_close
000160ee g     F .text	00000067 read_from_diritem
00018574 g     F .text	00000016 bit_count
0001594f g     F .text	00000024 devfs_write
0001816a g     F .text	00000066 move_to_first_task
00017aed g     F .text	000001a4 mount
00015973 g     F .text	0000001b devfs_close
00013d4a g     F .text	00000110 console_write
0001343e g     F .text	00000011 leave_protection
8000037f g     F .first_task	00000021 dup
00011999 g     F .text	00000045 task_next_run
00018776 g     F .text	0000002b count_string
000189e3 g     F .text	0000005e kernel_memcmp
000106b9 g     F .text	000000a3 create_kernel_table
00018d38 g     F .text	00000025 list_init
0001305a g     F .text	0000001c do_handler_smd_exception
00016469 g     F .text	0000003e bwrite_sector
80000000 g       .first_task	00000000 _first_task_entry
000101b4 g       .text	00000000 exception_handler_page_fault
00012ccb g     F .text	0000001c do_handler_unknown
00010986 g     F .text	0000001a memory_alloc_page
000101cf g       .text	00000000 exception_handler_fpu_error
00011b61 g     F .text	00000020 set_wake
000116cf g     F .text	0000001e task_switch_from_to
0001324d g     F .text	000001ae irq_init
00017ab5 g     F .text	00000038 get_fs_op
0001831a g     F .text	000000c0 mutex_unlock
00017153 g     F .text	00000030 file_table_init
00017111 g     F .text	00000042 file_free
00016217 g     F .text	00000052 diritem_init
00016562 g     F .text	000000c2 move_pos
0001889e g     F .text	0000003b kernel_strlen
00012711 g     F .text	00000086 segment_desc_set
00012d73 g     F .text	0000001c do_handler_bound_range
000102c9 g       .text	00000000 exception_handler_syscall
00014925 g     F .text	000000f5 disk_open
000171bb g     F .text	00000038 ref_dec
00016269 g     F .text	0000017e fatfs_open
00060200 g     O .bss	00000004 kbd_state
00018e20 g     F .text	00000078 list_remove_first
0001a23d g       .rodata	00000000 e_text
000188d9 g     F .text	0000007a kernel_strncmp
00017e42 g     F .text	00000053 sys_opendir
0001851e g     F .text	00000056 bitmap_init
00011911 g     F .text	0000002b set_block
00010163 g       .text	00000000 exception_handler_segment_not_present
0001007f g       .text	00000000 exception_handler_NMI
00016b4c g     F .text	0000000a fatfs_stat
00017086 g     F .text	0000008b file_alloc
000116f7 g     F .text	000000e7 task_manager_init
00011613 g     F .text	0000002d task_start
00010062 g       .text	00000000 exception_handler_Debug
00011a2a g     F .text	000000fa task_time_tick
0001075c g     F .text	000000cc memory_init
00011e03 g     F .text	000001d9 sys_execve
00014b07 g     F .text	000000ed disk_write
00012450 g     F .text	00000138 sys_wait
00012588 g     F .text	00000161 sys_exit
00013a27 g     F .text	00000029 clear_esc_param
00018cef g     F .text	00000036 pannic
00015648 g     F .text	00000029 tty_select
00013e5a g     F .text	0000000a console_close
00010c9d g     F .text	00000046 memory_get_paddr
00012e1b g     F .text	0000001c do_handler_stack_segment_fault
00012d3b g     F .text	0000001c do_handler_breakpoint
00015812 g     F .text	00000006 devfs_unmount
800003a0 g     F .first_task	00000022 _exit
0001592b g     F .text	00000024 devfs_read
00018f4c g     F .text	000000cd log_printf
00016b69 g     F .text	00000093 get_item_name
000114e9 g     F .text	0000012a task_init
00010045 g       .text	00000000 exception_handler_divider0
00014a1a g     F .text	000000ed disk_read
8000020f g     F .first_task	00000028 open
00016f34 g     F .text	0000005a cluster_free_chain
00018b80 g     F .text	00000024 kernel_sprintf
00014c73 g     F .text	00000015 get_key
000161e0 g     F .text	00000037 item_name_match
00011bdc g     F .text	0000000d sys_getpid
00012880 g     F .text	00000075 gdt_alloc_desc
0001858a g     F .text	0000003e bitmap_get_index
00018a41 g     F .text	0000013f kernel_itoa
00018e98 g     F .text	00000085 list_remove
0001193c g     F .text	0000005d sys_shed_yield
00012797 g     F .text	00000047 gate_desc_set
800002c1 g     F .first_task	00000022 close
00014c04 g     F .text	00000038 do_handler_ide_primary
0001056c g     F .text	000000b0 find_pte
000150a0 g     F .text	00000028 do_handler_time
0001b0a0 g     O .data	00000038 dev_tty_desc



Disassembly of section .text:

00010000 <_start>:
    # 第二种方法
    # mov 4(%esp), %eax
    # push %eax

    # 第三种方法
    push 4(%esp)
   10000:	ff 74 24 04          	pushl  0x4(%esp)

    # kernel_init(boot_info)
    call kernel_init
   10004:	e8 09 81 00 00       	call   18112 <kernel_init>

    	// 重新加载GDT
	jmp $KERNEL_SELECTOR_CS, $gdt_reload
   10009:	ea 10 00 01 00 08 00 	ljmp   $0x8,$0x10010

00010010 <gdt_reload>:

gdt_reload:
	mov $KERNEL_SELECTOR_DS, %ax		// 16为数据段选择子
   10010:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10014:	8e d8                	mov    %eax,%ds
    mov %ax, %ss
   10016:	8e d0                	mov    %eax,%ss
    mov %ax, %es
   10018:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   1001a:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   1001c:	8e e8                	mov    %eax,%gs

	// 栈设置
	mov $(stack + KERNEL_STACK_SIZE), %esp
   1001e:	bc 40 fc 05 00       	mov    $0x5fc40,%esp

	// 栈和段等沿用之前的设置
	jmp init_main
   10023:	e9 a8 81 00 00       	jmp    181d0 <init_main>

00010028 <exception_handler_unknown>:
    add $(2*4), %esp
    iret

.endm

exception_handler unknown, -1, 0
   10028:	6a 00                	push   $0x0
   1002a:	6a ff                	push   $0xffffffff
   1002c:	60                   	pusha  
   1002d:	1e                   	push   %ds
   1002e:	06                   	push   %es
   1002f:	0f a0                	push   %fs
   10031:	0f a8                	push   %gs
   10033:	54                   	push   %esp
   10034:	e8 92 2c 00 00       	call   12ccb <do_handler_unknown>
   10039:	5c                   	pop    %esp
   1003a:	0f a9                	pop    %gs
   1003c:	0f a1                	pop    %fs
   1003e:	07                   	pop    %es
   1003f:	1f                   	pop    %ds
   10040:	61                   	popa   
   10041:	83 c4 08             	add    $0x8,%esp
   10044:	cf                   	iret   

00010045 <exception_handler_divider0>:
exception_handler divider0, 0, 0
   10045:	6a 00                	push   $0x0
   10047:	6a 00                	push   $0x0
   10049:	60                   	pusha  
   1004a:	1e                   	push   %ds
   1004b:	06                   	push   %es
   1004c:	0f a0                	push   %fs
   1004e:	0f a8                	push   %gs
   10050:	54                   	push   %esp
   10051:	e8 91 2c 00 00       	call   12ce7 <do_handler_divider0>
   10056:	5c                   	pop    %esp
   10057:	0f a9                	pop    %gs
   10059:	0f a1                	pop    %fs
   1005b:	07                   	pop    %es
   1005c:	1f                   	pop    %ds
   1005d:	61                   	popa   
   1005e:	83 c4 08             	add    $0x8,%esp
   10061:	cf                   	iret   

00010062 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10062:	6a 00                	push   $0x0
   10064:	6a 01                	push   $0x1
   10066:	60                   	pusha  
   10067:	1e                   	push   %ds
   10068:	06                   	push   %es
   10069:	0f a0                	push   %fs
   1006b:	0f a8                	push   %gs
   1006d:	54                   	push   %esp
   1006e:	e8 90 2c 00 00       	call   12d03 <do_handler_Debug>
   10073:	5c                   	pop    %esp
   10074:	0f a9                	pop    %gs
   10076:	0f a1                	pop    %fs
   10078:	07                   	pop    %es
   10079:	1f                   	pop    %ds
   1007a:	61                   	popa   
   1007b:	83 c4 08             	add    $0x8,%esp
   1007e:	cf                   	iret   

0001007f <exception_handler_NMI>:
exception_handler NMI, 2, 0
   1007f:	6a 00                	push   $0x0
   10081:	6a 02                	push   $0x2
   10083:	60                   	pusha  
   10084:	1e                   	push   %ds
   10085:	06                   	push   %es
   10086:	0f a0                	push   %fs
   10088:	0f a8                	push   %gs
   1008a:	54                   	push   %esp
   1008b:	e8 8f 2c 00 00       	call   12d1f <do_handler_NMI>
   10090:	5c                   	pop    %esp
   10091:	0f a9                	pop    %gs
   10093:	0f a1                	pop    %fs
   10095:	07                   	pop    %es
   10096:	1f                   	pop    %ds
   10097:	61                   	popa   
   10098:	83 c4 08             	add    $0x8,%esp
   1009b:	cf                   	iret   

0001009c <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   1009c:	6a 00                	push   $0x0
   1009e:	6a 03                	push   $0x3
   100a0:	60                   	pusha  
   100a1:	1e                   	push   %ds
   100a2:	06                   	push   %es
   100a3:	0f a0                	push   %fs
   100a5:	0f a8                	push   %gs
   100a7:	54                   	push   %esp
   100a8:	e8 8e 2c 00 00       	call   12d3b <do_handler_breakpoint>
   100ad:	5c                   	pop    %esp
   100ae:	0f a9                	pop    %gs
   100b0:	0f a1                	pop    %fs
   100b2:	07                   	pop    %es
   100b3:	1f                   	pop    %ds
   100b4:	61                   	popa   
   100b5:	83 c4 08             	add    $0x8,%esp
   100b8:	cf                   	iret   

000100b9 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100b9:	6a 00                	push   $0x0
   100bb:	6a 04                	push   $0x4
   100bd:	60                   	pusha  
   100be:	1e                   	push   %ds
   100bf:	06                   	push   %es
   100c0:	0f a0                	push   %fs
   100c2:	0f a8                	push   %gs
   100c4:	54                   	push   %esp
   100c5:	e8 8d 2c 00 00       	call   12d57 <do_handler_overflow>
   100ca:	5c                   	pop    %esp
   100cb:	0f a9                	pop    %gs
   100cd:	0f a1                	pop    %fs
   100cf:	07                   	pop    %es
   100d0:	1f                   	pop    %ds
   100d1:	61                   	popa   
   100d2:	83 c4 08             	add    $0x8,%esp
   100d5:	cf                   	iret   

000100d6 <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100d6:	6a 00                	push   $0x0
   100d8:	6a 05                	push   $0x5
   100da:	60                   	pusha  
   100db:	1e                   	push   %ds
   100dc:	06                   	push   %es
   100dd:	0f a0                	push   %fs
   100df:	0f a8                	push   %gs
   100e1:	54                   	push   %esp
   100e2:	e8 8c 2c 00 00       	call   12d73 <do_handler_bound_range>
   100e7:	5c                   	pop    %esp
   100e8:	0f a9                	pop    %gs
   100ea:	0f a1                	pop    %fs
   100ec:	07                   	pop    %es
   100ed:	1f                   	pop    %ds
   100ee:	61                   	popa   
   100ef:	83 c4 08             	add    $0x8,%esp
   100f2:	cf                   	iret   

000100f3 <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   100f3:	6a 00                	push   $0x0
   100f5:	6a 06                	push   $0x6
   100f7:	60                   	pusha  
   100f8:	1e                   	push   %ds
   100f9:	06                   	push   %es
   100fa:	0f a0                	push   %fs
   100fc:	0f a8                	push   %gs
   100fe:	54                   	push   %esp
   100ff:	e8 8b 2c 00 00       	call   12d8f <do_handler_invalid_opcode>
   10104:	5c                   	pop    %esp
   10105:	0f a9                	pop    %gs
   10107:	0f a1                	pop    %fs
   10109:	07                   	pop    %es
   1010a:	1f                   	pop    %ds
   1010b:	61                   	popa   
   1010c:	83 c4 08             	add    $0x8,%esp
   1010f:	cf                   	iret   

00010110 <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   10110:	6a 00                	push   $0x0
   10112:	6a 07                	push   $0x7
   10114:	60                   	pusha  
   10115:	1e                   	push   %ds
   10116:	06                   	push   %es
   10117:	0f a0                	push   %fs
   10119:	0f a8                	push   %gs
   1011b:	54                   	push   %esp
   1011c:	e8 8a 2c 00 00       	call   12dab <do_handler_device_unavailable>
   10121:	5c                   	pop    %esp
   10122:	0f a9                	pop    %gs
   10124:	0f a1                	pop    %fs
   10126:	07                   	pop    %es
   10127:	1f                   	pop    %ds
   10128:	61                   	popa   
   10129:	83 c4 08             	add    $0x8,%esp
   1012c:	cf                   	iret   

0001012d <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   1012d:	6a 08                	push   $0x8
   1012f:	60                   	pusha  
   10130:	1e                   	push   %ds
   10131:	06                   	push   %es
   10132:	0f a0                	push   %fs
   10134:	0f a8                	push   %gs
   10136:	54                   	push   %esp
   10137:	e8 8b 2c 00 00       	call   12dc7 <do_handler_double_fault>
   1013c:	5c                   	pop    %esp
   1013d:	0f a9                	pop    %gs
   1013f:	0f a1                	pop    %fs
   10141:	07                   	pop    %es
   10142:	1f                   	pop    %ds
   10143:	61                   	popa   
   10144:	83 c4 08             	add    $0x8,%esp
   10147:	cf                   	iret   

00010148 <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   10148:	6a 0a                	push   $0xa
   1014a:	60                   	pusha  
   1014b:	1e                   	push   %ds
   1014c:	06                   	push   %es
   1014d:	0f a0                	push   %fs
   1014f:	0f a8                	push   %gs
   10151:	54                   	push   %esp
   10152:	e8 8c 2c 00 00       	call   12de3 <do_handler_invalid_tss>
   10157:	5c                   	pop    %esp
   10158:	0f a9                	pop    %gs
   1015a:	0f a1                	pop    %fs
   1015c:	07                   	pop    %es
   1015d:	1f                   	pop    %ds
   1015e:	61                   	popa   
   1015f:	83 c4 08             	add    $0x8,%esp
   10162:	cf                   	iret   

00010163 <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   10163:	6a 0b                	push   $0xb
   10165:	60                   	pusha  
   10166:	1e                   	push   %ds
   10167:	06                   	push   %es
   10168:	0f a0                	push   %fs
   1016a:	0f a8                	push   %gs
   1016c:	54                   	push   %esp
   1016d:	e8 8d 2c 00 00       	call   12dff <do_handler_segment_not_present>
   10172:	5c                   	pop    %esp
   10173:	0f a9                	pop    %gs
   10175:	0f a1                	pop    %fs
   10177:	07                   	pop    %es
   10178:	1f                   	pop    %ds
   10179:	61                   	popa   
   1017a:	83 c4 08             	add    $0x8,%esp
   1017d:	cf                   	iret   

0001017e <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   1017e:	6a 0c                	push   $0xc
   10180:	60                   	pusha  
   10181:	1e                   	push   %ds
   10182:	06                   	push   %es
   10183:	0f a0                	push   %fs
   10185:	0f a8                	push   %gs
   10187:	54                   	push   %esp
   10188:	e8 8e 2c 00 00       	call   12e1b <do_handler_stack_segment_fault>
   1018d:	5c                   	pop    %esp
   1018e:	0f a9                	pop    %gs
   10190:	0f a1                	pop    %fs
   10192:	07                   	pop    %es
   10193:	1f                   	pop    %ds
   10194:	61                   	popa   
   10195:	83 c4 08             	add    $0x8,%esp
   10198:	cf                   	iret   

00010199 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   10199:	6a 0d                	push   $0xd
   1019b:	60                   	pusha  
   1019c:	1e                   	push   %ds
   1019d:	06                   	push   %es
   1019e:	0f a0                	push   %fs
   101a0:	0f a8                	push   %gs
   101a2:	54                   	push   %esp
   101a3:	e8 8f 2c 00 00       	call   12e37 <do_handler_general_protection>
   101a8:	5c                   	pop    %esp
   101a9:	0f a9                	pop    %gs
   101ab:	0f a1                	pop    %fs
   101ad:	07                   	pop    %es
   101ae:	1f                   	pop    %ds
   101af:	61                   	popa   
   101b0:	83 c4 08             	add    $0x8,%esp
   101b3:	cf                   	iret   

000101b4 <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101b4:	6a 0e                	push   $0xe
   101b6:	60                   	pusha  
   101b7:	1e                   	push   %ds
   101b8:	06                   	push   %es
   101b9:	0f a0                	push   %fs
   101bb:	0f a8                	push   %gs
   101bd:	54                   	push   %esp
   101be:	e8 4c 2d 00 00       	call   12f0f <do_handler_page_fault>
   101c3:	5c                   	pop    %esp
   101c4:	0f a9                	pop    %gs
   101c6:	0f a1                	pop    %fs
   101c8:	07                   	pop    %es
   101c9:	1f                   	pop    %ds
   101ca:	61                   	popa   
   101cb:	83 c4 08             	add    $0x8,%esp
   101ce:	cf                   	iret   

000101cf <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101cf:	6a 00                	push   $0x0
   101d1:	6a 10                	push   $0x10
   101d3:	60                   	pusha  
   101d4:	1e                   	push   %ds
   101d5:	06                   	push   %es
   101d6:	0f a0                	push   %fs
   101d8:	0f a8                	push   %gs
   101da:	54                   	push   %esp
   101db:	e8 26 2e 00 00       	call   13006 <do_handler_fpu_error>
   101e0:	5c                   	pop    %esp
   101e1:	0f a9                	pop    %gs
   101e3:	0f a1                	pop    %fs
   101e5:	07                   	pop    %es
   101e6:	1f                   	pop    %ds
   101e7:	61                   	popa   
   101e8:	83 c4 08             	add    $0x8,%esp
   101eb:	cf                   	iret   

000101ec <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   101ec:	6a 11                	push   $0x11
   101ee:	60                   	pusha  
   101ef:	1e                   	push   %ds
   101f0:	06                   	push   %es
   101f1:	0f a0                	push   %fs
   101f3:	0f a8                	push   %gs
   101f5:	54                   	push   %esp
   101f6:	e8 27 2e 00 00       	call   13022 <do_handler_alignment_check>
   101fb:	5c                   	pop    %esp
   101fc:	0f a9                	pop    %gs
   101fe:	0f a1                	pop    %fs
   10200:	07                   	pop    %es
   10201:	1f                   	pop    %ds
   10202:	61                   	popa   
   10203:	83 c4 08             	add    $0x8,%esp
   10206:	cf                   	iret   

00010207 <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   10207:	6a 00                	push   $0x0
   10209:	6a 12                	push   $0x12
   1020b:	60                   	pusha  
   1020c:	1e                   	push   %ds
   1020d:	06                   	push   %es
   1020e:	0f a0                	push   %fs
   10210:	0f a8                	push   %gs
   10212:	54                   	push   %esp
   10213:	e8 26 2e 00 00       	call   1303e <do_handler_machine_check>
   10218:	5c                   	pop    %esp
   10219:	0f a9                	pop    %gs
   1021b:	0f a1                	pop    %fs
   1021d:	07                   	pop    %es
   1021e:	1f                   	pop    %ds
   1021f:	61                   	popa   
   10220:	83 c4 08             	add    $0x8,%esp
   10223:	cf                   	iret   

00010224 <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   10224:	6a 00                	push   $0x0
   10226:	6a 13                	push   $0x13
   10228:	60                   	pusha  
   10229:	1e                   	push   %ds
   1022a:	06                   	push   %es
   1022b:	0f a0                	push   %fs
   1022d:	0f a8                	push   %gs
   1022f:	54                   	push   %esp
   10230:	e8 25 2e 00 00       	call   1305a <do_handler_smd_exception>
   10235:	5c                   	pop    %esp
   10236:	0f a9                	pop    %gs
   10238:	0f a1                	pop    %fs
   1023a:	07                   	pop    %es
   1023b:	1f                   	pop    %ds
   1023c:	61                   	popa   
   1023d:	83 c4 08             	add    $0x8,%esp
   10240:	cf                   	iret   

00010241 <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   10241:	6a 00                	push   $0x0
   10243:	6a 14                	push   $0x14
   10245:	60                   	pusha  
   10246:	1e                   	push   %ds
   10247:	06                   	push   %es
   10248:	0f a0                	push   %fs
   1024a:	0f a8                	push   %gs
   1024c:	54                   	push   %esp
   1024d:	e8 24 2e 00 00       	call   13076 <do_handler_virtual_exception>
   10252:	5c                   	pop    %esp
   10253:	0f a9                	pop    %gs
   10255:	0f a1                	pop    %fs
   10257:	07                   	pop    %es
   10258:	1f                   	pop    %ds
   10259:	61                   	popa   
   1025a:	83 c4 08             	add    $0x8,%esp
   1025d:	cf                   	iret   

0001025e <exception_handler_time>:
exception_handler time, 0x20, 0
   1025e:	6a 00                	push   $0x0
   10260:	6a 20                	push   $0x20
   10262:	60                   	pusha  
   10263:	1e                   	push   %ds
   10264:	06                   	push   %es
   10265:	0f a0                	push   %fs
   10267:	0f a8                	push   %gs
   10269:	54                   	push   %esp
   1026a:	e8 31 4e 00 00       	call   150a0 <do_handler_time>
   1026f:	5c                   	pop    %esp
   10270:	0f a9                	pop    %gs
   10272:	0f a1                	pop    %fs
   10274:	07                   	pop    %es
   10275:	1f                   	pop    %ds
   10276:	61                   	popa   
   10277:	83 c4 08             	add    $0x8,%esp
   1027a:	cf                   	iret   

0001027b <exception_handler_kbd>:
exception_handler kbd, 0x21, 0
   1027b:	6a 00                	push   $0x0
   1027d:	6a 21                	push   $0x21
   1027f:	60                   	pusha  
   10280:	1e                   	push   %ds
   10281:	06                   	push   %es
   10282:	0f a0                	push   %fs
   10284:	0f a8                	push   %gs
   10286:	54                   	push   %esp
   10287:	e8 fa 4b 00 00       	call   14e86 <do_handler_kbd>
   1028c:	5c                   	pop    %esp
   1028d:	0f a9                	pop    %gs
   1028f:	0f a1                	pop    %fs
   10291:	07                   	pop    %es
   10292:	1f                   	pop    %ds
   10293:	61                   	popa   
   10294:	83 c4 08             	add    $0x8,%esp
   10297:	cf                   	iret   

00010298 <exception_handler_ide_primary>:
exception_handler ide_primary, 0x2E, 0
   10298:	6a 00                	push   $0x0
   1029a:	6a 2e                	push   $0x2e
   1029c:	60                   	pusha  
   1029d:	1e                   	push   %ds
   1029e:	06                   	push   %es
   1029f:	0f a0                	push   %fs
   102a1:	0f a8                	push   %gs
   102a3:	54                   	push   %esp
   102a4:	e8 5b 49 00 00       	call   14c04 <do_handler_ide_primary>
   102a9:	5c                   	pop    %esp
   102aa:	0f a9                	pop    %gs
   102ac:	0f a1                	pop    %fs
   102ae:	07                   	pop    %es
   102af:	1f                   	pop    %ds
   102b0:	61                   	popa   
   102b1:	83 c4 08             	add    $0x8,%esp
   102b4:	cf                   	iret   

000102b5 <simple_switch>:
;     .text
;     .global simple_switch
;     //simple_switch(&from, to)
; simple_switch:
;     mov 8(%esp), %edx
   102b5:	8b 54 24 08          	mov    0x8(%esp),%edx
;     mov 4(%esp), %eax
   102b9:	8b 44 24 04          	mov    0x4(%esp),%eax
;     push %ebp
   102bd:	55                   	push   %ebp
;     push %ebx
   102be:	53                   	push   %ebx
;     push %esi
   102bf:	56                   	push   %esi
;     push %edi
   102c0:	57                   	push   %edi
;     mov %esp, (%eax)
   102c1:	89 20                	mov    %esp,(%eax)

;     mov %edx, %esp
   102c3:	89 d4                	mov    %edx,%esp
;     pop %edi
   102c5:	5f                   	pop    %edi
;     pop %esi
   102c6:	5e                   	pop    %esi
;     pop %ebx
   102c7:	5b                   	pop    %ebx
;     pop %ebp
   102c8:	5d                   	pop    %ebp

000102c9 <exception_handler_syscall>:

    .global exception_handler_syscall
    .extern do_handler_syscall
exception_handler_syscall:
    pusha
   102c9:	60                   	pusha  
    push %ds
   102ca:	1e                   	push   %ds
    push %es
   102cb:	06                   	push   %es
    push %fs
   102cc:	0f a0                	push   %fs
    push %gs
   102ce:	0f a8                	push   %gs
    pushf
   102d0:	9c                   	pushf  
    mov $(KERNEL_SELECTOR_DS), %eax
   102d1:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
   102d6:	8e d8                	mov    %eax,%ds
	mov %eax, %es
   102d8:	8e c0                	mov    %eax,%es
	mov %eax, %fs
   102da:	8e e0                	mov    %eax,%fs
	mov %eax, %gs
   102dc:	8e e8                	mov    %eax,%gs
    mov %esp, %eax
   102de:	89 e0                	mov    %esp,%eax
    push %eax
   102e0:	50                   	push   %eax
    call do_handler_syscall
   102e1:	e8 16 0d 00 00       	call   10ffc <do_handler_syscall>
    add $4, %esp
   102e6:	83 c4 04             	add    $0x4,%esp
    popf
   102e9:	9d                   	popf   
    pop %gs
   102ea:	0f a9                	pop    %gs
    pop %fs
   102ec:	0f a1                	pop    %fs
    pop %es
   102ee:	07                   	pop    %es
    pop %ds
   102ef:	1f                   	pop    %ds
    popa
   102f0:	61                   	popa   
   102f1:	ca 14 00             	lret   $0x14

000102f4 <write_cr3>:

static inline void write_cr0(uint32_t v) {
	__asm__ __volatile__("mov %[v], %%cr0"::[v]"r"(v));
}

static inline void write_cr3(uint32_t v) {
   102f4:	55                   	push   %ebp
   102f5:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3"::[v]"r"(v));
   102f7:	8b 45 08             	mov    0x8(%ebp),%eax
   102fa:	0f 22 d8             	mov    %eax,%cr3
}
   102fd:	90                   	nop
   102fe:	5d                   	pop    %ebp
   102ff:	c3                   	ret    

00010300 <up2>:
#define KLIB_H
#include  <stdarg.h>
#include "comm/types.h"
#include "tools/log.h"
#include "comm/cpu_instr.h"
static inline uint32_t up2 (uint32_t size, uint32_t bound) {
   10300:	55                   	push   %ebp
   10301:	89 e5                	mov    %esp,%ebp
    return (size + bound - 1) & ~(bound - 1);
   10303:	8b 55 08             	mov    0x8(%ebp),%edx
   10306:	8b 45 0c             	mov    0xc(%ebp),%eax
   10309:	01 d0                	add    %edx,%eax
   1030b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1030e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10311:	f7 d8                	neg    %eax
   10313:	21 d0                	and    %edx,%eax
}
   10315:	5d                   	pop    %ebp
   10316:	c3                   	ret    

00010317 <down2>:

static inline uint32_t down2 (uint32_t size, uint32_t bound) {
   10317:	55                   	push   %ebp
   10318:	89 e5                	mov    %esp,%ebp
    return size & ~(bound - 1);
   1031a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1031d:	f7 d8                	neg    %eax
   1031f:	23 45 08             	and    0x8(%ebp),%eax
}
   10322:	5d                   	pop    %ebp
   10323:	c3                   	ret    

00010324 <mmu_set_page_dir>:
}pte_t;

#pragma pack()

static inline void mmu_set_page_dir(uint32_t page_dir)
{
   10324:	55                   	push   %ebp
   10325:	89 e5                	mov    %esp,%ebp
    write_cr3(page_dir);
   10327:	ff 75 08             	pushl  0x8(%ebp)
   1032a:	e8 c5 ff ff ff       	call   102f4 <write_cr3>
   1032f:	83 c4 04             	add    $0x4,%esp
}
   10332:	90                   	nop
   10333:	c9                   	leave  
   10334:	c3                   	ret    

00010335 <pde_index>:

static inline uint32_t pde_index(uint32_t vaddr){
   10335:	55                   	push   %ebp
   10336:	89 e5                	mov    %esp,%ebp
    return  (vaddr >> 22);
   10338:	8b 45 08             	mov    0x8(%ebp),%eax
   1033b:	c1 e8 16             	shr    $0x16,%eax
}
   1033e:	5d                   	pop    %ebp
   1033f:	c3                   	ret    

00010340 <pte_index>:

static inline uint32_t pte_index(uint32_t vaddr){
   10340:	55                   	push   %ebp
   10341:	89 e5                	mov    %esp,%ebp
    return  (vaddr >> 12) & 0x3ff;
   10343:	8b 45 08             	mov    0x8(%ebp),%eax
   10346:	c1 e8 0c             	shr    $0xc,%eax
   10349:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   1034e:	5d                   	pop    %ebp
   1034f:	c3                   	ret    

00010350 <pde_paddr>:
static inline uint32_t pde_paddr(pde_t* desc)
{
   10350:	55                   	push   %ebp
   10351:	89 e5                	mov    %esp,%ebp
    return (desc->phy_pt_addr << 12);
   10353:	8b 45 08             	mov    0x8(%ebp),%eax
   10356:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   1035a:	c0 ea 04             	shr    $0x4,%dl
   1035d:	0f b6 d2             	movzbl %dl,%edx
   10360:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   10364:	c1 e1 04             	shl    $0x4,%ecx
   10367:	09 ca                	or     %ecx,%edx
   10369:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   1036d:	c1 e0 0c             	shl    $0xc,%eax
   10370:	09 d0                	or     %edx,%eax
   10372:	c1 e0 0c             	shl    $0xc,%eax
}
   10375:	5d                   	pop    %ebp
   10376:	c3                   	ret    

00010377 <pte_paddr>:
static inline uint32_t pte_paddr(pte_t* desc)
{
   10377:	55                   	push   %ebp
   10378:	89 e5                	mov    %esp,%ebp
    return (desc -> phy_page_addr << 12);
   1037a:	8b 45 08             	mov    0x8(%ebp),%eax
   1037d:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   10381:	c0 ea 04             	shr    $0x4,%dl
   10384:	0f b6 d2             	movzbl %dl,%edx
   10387:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   1038b:	c1 e1 04             	shl    $0x4,%ecx
   1038e:	09 ca                	or     %ecx,%edx
   10390:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   10394:	c1 e0 0c             	shl    $0xc,%eax
   10397:	09 d0                	or     %edx,%eax
   10399:	c1 e0 0c             	shl    $0xc,%eax
}
   1039c:	5d                   	pop    %ebp
   1039d:	c3                   	ret    

0001039e <get_pte_perm>:

static inline uint32_t get_pte_perm(pte_t* desc)
{
   1039e:	55                   	push   %ebp
   1039f:	89 e5                	mov    %esp,%ebp
    return (desc->v & 0x3FF);
   103a1:	8b 45 08             	mov    0x8(%ebp),%eax
   103a4:	8b 00                	mov    (%eax),%eax
   103a6:	25 ff 03 00 00       	and    $0x3ff,%eax
   103ab:	5d                   	pop    %ebp
   103ac:	c3                   	ret    

000103ad <addr_alloc_init>:
#include "dev/console.h"
static addr_alloc_t paddr_alloc; 
static pde_t kernel_page_dir[PDE_CNT] __attribute__((aligned(4096)));
static void addr_alloc_init(addr_alloc_t * alloc, uint8_t* bits, uint32_t start,
uint32_t size, uint32_t page_size) 
{
   103ad:	55                   	push   %ebp
   103ae:	89 e5                	mov    %esp,%ebp
   103b0:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&alloc->mutex);
   103b3:	8b 45 08             	mov    0x8(%ebp),%eax
   103b6:	83 ec 0c             	sub    $0xc,%esp
   103b9:	50                   	push   %eax
   103ba:	e8 97 7e 00 00       	call   18256 <mutex_init>
   103bf:	83 c4 10             	add    $0x10,%esp
    alloc -> start = start;
   103c2:	8b 45 08             	mov    0x8(%ebp),%eax
   103c5:	8b 55 10             	mov    0x10(%ebp),%edx
   103c8:	89 50 14             	mov    %edx,0x14(%eax)
    alloc -> size = size;
   103cb:	8b 45 08             	mov    0x8(%ebp),%eax
   103ce:	8b 55 14             	mov    0x14(%ebp),%edx
   103d1:	89 50 18             	mov    %edx,0x18(%eax)
    alloc -> page_size = page_size;
   103d4:	8b 45 08             	mov    0x8(%ebp),%eax
   103d7:	8b 55 18             	mov    0x18(%ebp),%edx
   103da:	89 50 1c             	mov    %edx,0x1c(%eax)
    bitmap_init(&alloc->bitmap, bits, alloc->size / page_size, 0);
   103dd:	8b 45 08             	mov    0x8(%ebp),%eax
   103e0:	8b 40 18             	mov    0x18(%eax),%eax
   103e3:	ba 00 00 00 00       	mov    $0x0,%edx
   103e8:	f7 75 18             	divl   0x18(%ebp)
   103eb:	89 c2                	mov    %eax,%edx
   103ed:	8b 45 08             	mov    0x8(%ebp),%eax
   103f0:	83 c0 20             	add    $0x20,%eax
   103f3:	6a 00                	push   $0x0
   103f5:	52                   	push   %edx
   103f6:	ff 75 0c             	pushl  0xc(%ebp)
   103f9:	50                   	push   %eax
   103fa:	e8 1f 81 00 00       	call   1851e <bitmap_init>
   103ff:	83 c4 10             	add    $0x10,%esp
}
   10402:	90                   	nop
   10403:	c9                   	leave  
   10404:	c3                   	ret    

00010405 <addr_alloc_page>:
static uint32_t addr_alloc_page(addr_alloc_t* alloc, int page_count){
   10405:	55                   	push   %ebp
   10406:	89 e5                	mov    %esp,%ebp
   10408:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr = 0;
   1040b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&alloc->mutex);
   10412:	8b 45 08             	mov    0x8(%ebp),%eax
   10415:	83 ec 0c             	sub    $0xc,%esp
   10418:	50                   	push   %eax
   10419:	e8 66 7e 00 00       	call   18284 <mutex_lock>
   1041e:	83 c4 10             	add    $0x10,%esp
    int page_index = bitmap_alloc_nbit(&alloc->bitmap, page_count, 0);
   10421:	8b 45 08             	mov    0x8(%ebp),%eax
   10424:	83 c0 20             	add    $0x20,%eax
   10427:	83 ec 04             	sub    $0x4,%esp
   1042a:	6a 00                	push   $0x0
   1042c:	ff 75 0c             	pushl  0xc(%ebp)
   1042f:	50                   	push   %eax
   10430:	e8 82 82 00 00       	call   186b7 <bitmap_alloc_nbit>
   10435:	83 c4 10             	add    $0x10,%esp
   10438:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_index != -1)
   1043b:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
   1043f:	74 17                	je     10458 <addr_alloc_page+0x53>
        addr = alloc->start + page_index * alloc->page_size;
   10441:	8b 45 08             	mov    0x8(%ebp),%eax
   10444:	8b 50 14             	mov    0x14(%eax),%edx
   10447:	8b 45 08             	mov    0x8(%ebp),%eax
   1044a:	8b 48 1c             	mov    0x1c(%eax),%ecx
   1044d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10450:	0f af c1             	imul   %ecx,%eax
   10453:	01 d0                	add    %edx,%eax
   10455:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    mutex_unlock(&alloc->mutex);
   10458:	8b 45 08             	mov    0x8(%ebp),%eax
   1045b:	83 ec 0c             	sub    $0xc,%esp
   1045e:	50                   	push   %eax
   1045f:	e8 b6 7e 00 00       	call   1831a <mutex_unlock>
   10464:	83 c4 10             	add    $0x10,%esp
    return addr;
   10467:	8b 45 f4             	mov    -0xc(%ebp),%eax
    
}
   1046a:	c9                   	leave  
   1046b:	c3                   	ret    

0001046c <addr_free_page>:

static void addr_free_page(addr_alloc_t* alloc, uint32_t addr, int page_count)
{
   1046c:	55                   	push   %ebp
   1046d:	89 e5                	mov    %esp,%ebp
   1046f:	53                   	push   %ebx
   10470:	83 ec 04             	sub    $0x4,%esp
    mutex_lock(&alloc->mutex);
   10473:	8b 45 08             	mov    0x8(%ebp),%eax
   10476:	83 ec 0c             	sub    $0xc,%esp
   10479:	50                   	push   %eax
   1047a:	e8 05 7e 00 00       	call   18284 <mutex_lock>
   1047f:	83 c4 10             	add    $0x10,%esp
    bitmap_set_nbit(&alloc->bitmap, (addr - alloc->start)/alloc->page_size, page_count, 0);
   10482:	8b 45 08             	mov    0x8(%ebp),%eax
   10485:	8b 40 14             	mov    0x14(%eax),%eax
   10488:	8b 55 0c             	mov    0xc(%ebp),%edx
   1048b:	89 d1                	mov    %edx,%ecx
   1048d:	29 c1                	sub    %eax,%ecx
   1048f:	8b 45 08             	mov    0x8(%ebp),%eax
   10492:	8b 58 1c             	mov    0x1c(%eax),%ebx
   10495:	89 c8                	mov    %ecx,%eax
   10497:	ba 00 00 00 00       	mov    $0x0,%edx
   1049c:	f7 f3                	div    %ebx
   1049e:	89 c2                	mov    %eax,%edx
   104a0:	8b 45 08             	mov    0x8(%ebp),%eax
   104a3:	83 c0 20             	add    $0x20,%eax
   104a6:	6a 00                	push   $0x0
   104a8:	ff 75 10             	pushl  0x10(%ebp)
   104ab:	52                   	push   %edx
   104ac:	50                   	push   %eax
   104ad:	e8 16 81 00 00       	call   185c8 <bitmap_set_nbit>
   104b2:	83 c4 10             	add    $0x10,%esp
    mutex_unlock(&alloc->mutex);
   104b5:	8b 45 08             	mov    0x8(%ebp),%eax
   104b8:	83 ec 0c             	sub    $0xc,%esp
   104bb:	50                   	push   %eax
   104bc:	e8 59 7e 00 00       	call   1831a <mutex_unlock>
   104c1:	83 c4 10             	add    $0x10,%esp
}
   104c4:	90                   	nop
   104c5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   104c8:	c9                   	leave  
   104c9:	c3                   	ret    

000104ca <show_mem_info>:
static void show_mem_info (boot_info_t * boot_info) {
   104ca:	55                   	push   %ebp
   104cb:	89 e5                	mov    %esp,%ebp
   104cd:	83 ec 18             	sub    $0x18,%esp
    log_printf("mem region:");
   104d0:	83 ec 0c             	sub    $0xc,%esp
   104d3:	68 20 90 01 00       	push   $0x19020
   104d8:	e8 6f 8a 00 00       	call   18f4c <log_printf>
   104dd:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < boot_info->ram_region_count; i++) {
   104e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   104e7:	eb 29                	jmp    10512 <show_mem_info+0x48>
        log_printf("[%d]: 0x%x - 0x%x", i, 
   104e9:	8b 45 08             	mov    0x8(%ebp),%eax
   104ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
   104ef:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
   104f3:	8b 45 08             	mov    0x8(%ebp),%eax
   104f6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   104f9:	8b 04 c8             	mov    (%eax,%ecx,8),%eax
   104fc:	52                   	push   %edx
   104fd:	50                   	push   %eax
   104fe:	ff 75 f4             	pushl  -0xc(%ebp)
   10501:	68 2c 90 01 00       	push   $0x1902c
   10506:	e8 41 8a 00 00       	call   18f4c <log_printf>
   1050b:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < boot_info->ram_region_count; i++) {
   1050e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10512:	8b 45 08             	mov    0x8(%ebp),%eax
   10515:	8b 40 50             	mov    0x50(%eax),%eax
   10518:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   1051b:	7c cc                	jl     104e9 <show_mem_info+0x1f>
                    boot_info->ram_region_cfg[i].start,
                    boot_info->ram_region_cfg[i].size);
    }
    log_printf("\n");
   1051d:	83 ec 0c             	sub    $0xc,%esp
   10520:	68 3e 90 01 00       	push   $0x1903e
   10525:	e8 22 8a 00 00       	call   18f4c <log_printf>
   1052a:	83 c4 10             	add    $0x10,%esp
}
   1052d:	90                   	nop
   1052e:	c9                   	leave  
   1052f:	c3                   	ret    

00010530 <total_mem_size>:
static uint32_t total_mem_size(boot_info_t * boot_info) {
   10530:	55                   	push   %ebp
   10531:	89 e5                	mov    %esp,%ebp
   10533:	83 ec 10             	sub    $0x10,%esp
    int mem_size = 0;
   10536:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    // 简单起见，暂不考虑中间有空洞的情况
    for (int i = 0; i < boot_info->ram_region_count; i++) {
   1053d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   10544:	eb 16                	jmp    1055c <total_mem_size+0x2c>
        mem_size += boot_info->ram_region_cfg[i].size;
   10546:	8b 45 08             	mov    0x8(%ebp),%eax
   10549:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1054c:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
   10550:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10553:	01 d0                	add    %edx,%eax
   10555:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for (int i = 0; i < boot_info->ram_region_count; i++) {
   10558:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1055c:	8b 45 08             	mov    0x8(%ebp),%eax
   1055f:	8b 40 50             	mov    0x50(%eax),%eax
   10562:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   10565:	7c df                	jl     10546 <total_mem_size+0x16>
    }
    return mem_size;
   10567:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1056a:	c9                   	leave  
   1056b:	c3                   	ret    

0001056c <find_pte>:

pte_t* find_pte(pde_t* page_dir, uint32_t vstart, int alloc)
{
   1056c:	55                   	push   %ebp
   1056d:	89 e5                	mov    %esp,%ebp
   1056f:	83 ec 18             	sub    $0x18,%esp
    pte_t * page_table;

    pde_t *pde = page_dir + pde_index(vstart);
   10572:	ff 75 0c             	pushl  0xc(%ebp)
   10575:	e8 bb fd ff ff       	call   10335 <pde_index>
   1057a:	83 c4 04             	add    $0x4,%esp
   1057d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10584:	8b 45 08             	mov    0x8(%ebp),%eax
   10587:	01 d0                	add    %edx,%eax
   10589:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (pde->present) {
   1058c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1058f:	0f b6 00             	movzbl (%eax),%eax
   10592:	83 e0 01             	and    $0x1,%eax
   10595:	84 c0                	test   %al,%al
   10597:	74 10                	je     105a9 <find_pte+0x3d>
        page_table = (pte_t *)pde_paddr(pde);
   10599:	ff 75 f0             	pushl  -0x10(%ebp)
   1059c:	e8 af fd ff ff       	call   10350 <pde_paddr>
   105a1:	83 c4 04             	add    $0x4,%esp
   105a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
   105a7:	eb 57                	jmp    10600 <find_pte+0x94>
    } else {
        // 如果不存在，则考虑分配一个
        if (alloc == 0) {
   105a9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   105ad:	75 07                	jne    105b6 <find_pte+0x4a>
            return (pte_t *)0;
   105af:	b8 00 00 00 00       	mov    $0x0,%eax
   105b4:	eb 64                	jmp    1061a <find_pte+0xae>
        }

        // 分配一个物理页表
        uint32_t pg_paddr = addr_alloc_page(&paddr_alloc, 1);
   105b6:	83 ec 08             	sub    $0x8,%esp
   105b9:	6a 01                	push   $0x1
   105bb:	68 00 c0 01 00       	push   $0x1c000
   105c0:	e8 40 fe ff ff       	call   10405 <addr_alloc_page>
   105c5:	83 c4 10             	add    $0x10,%esp
   105c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (pg_paddr == 0) {
   105cb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   105cf:	75 07                	jne    105d8 <find_pte+0x6c>
            return (pte_t *)0;
   105d1:	b8 00 00 00 00       	mov    $0x0,%eax
   105d6:	eb 42                	jmp    1061a <find_pte+0xae>
        }

        // 设置为用户可读写，将被pte中设置所覆盖
        pde->v = pg_paddr | PDE_P | PDE_W | PDE_U;
   105d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105db:	83 c8 07             	or     $0x7,%eax
   105de:	89 c2                	mov    %eax,%edx
   105e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   105e3:	89 10                	mov    %edx,(%eax)
        // 为物理页表绑定虚拟地址的映射，这样下面就可以计算出虚拟地址了
        //kernel_pg_last[pde_index(vaddr)].v = pg_paddr | PTE_P | PTE_W;

        // 清空页表，防止出现异常
        // 这里虚拟地址和物理地址一一映射，所以直接写入
        page_table = (pte_t *)(pg_paddr);
   105e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   105e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        kernel_memset(page_table, 0, MEM_PAGE_SIZE);
   105eb:	83 ec 04             	sub    $0x4,%esp
   105ee:	68 00 10 00 00       	push   $0x1000
   105f3:	6a 00                	push   $0x0
   105f5:	ff 75 f4             	pushl  -0xc(%ebp)
   105f8:	e8 a5 83 00 00       	call   189a2 <kernel_memset>
   105fd:	83 c4 10             	add    $0x10,%esp
    }

    return page_table + pte_index(vstart);
   10600:	83 ec 0c             	sub    $0xc,%esp
   10603:	ff 75 0c             	pushl  0xc(%ebp)
   10606:	e8 35 fd ff ff       	call   10340 <pte_index>
   1060b:	83 c4 10             	add    $0x10,%esp
   1060e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10615:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10618:	01 d0                	add    %edx,%eax
}
   1061a:	c9                   	leave  
   1061b:	c3                   	ret    

0001061c <memory_create_map>:

int memory_create_map(pde_t* page_dir, uint32_t vstart, uint32_t pstart, uint32_t count, uint32_t perm)
{
   1061c:	55                   	push   %ebp
   1061d:	89 e5                	mov    %esp,%ebp
   1061f:	83 ec 18             	sub    $0x18,%esp
    
    for (int i = 0; i < count; i++) {
   10622:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10629:	eb 7b                	jmp    106a6 <memory_create_map+0x8a>
        // log_printf("create map: v-0x%x p-0x%x, perm: 0x%x", vstart, pstart, perm);

        pte_t * pte = find_pte(page_dir, vstart, 1);  //虚拟地址在的二级页表地址
   1062b:	83 ec 04             	sub    $0x4,%esp
   1062e:	6a 01                	push   $0x1
   10630:	ff 75 0c             	pushl  0xc(%ebp)
   10633:	ff 75 08             	pushl  0x8(%ebp)
   10636:	e8 31 ff ff ff       	call   1056c <find_pte>
   1063b:	83 c4 10             	add    $0x10,%esp
   1063e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (pte == (pte_t *)0) {
   10641:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10645:	75 17                	jne    1065e <memory_create_map+0x42>
            log_printf("create pte failed. pte == 0");
   10647:	83 ec 0c             	sub    $0xc,%esp
   1064a:	68 40 90 01 00       	push   $0x19040
   1064f:	e8 f8 88 00 00       	call   18f4c <log_printf>
   10654:	83 c4 10             	add    $0x10,%esp
            return -1;
   10657:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1065c:	eb 59                	jmp    106b7 <memory_create_map+0x9b>
        }

        // 创建映射的时候，这条pte应当是不存在的。
        // 如果存在，说明可能有问题
        // log_printf("\tpte addr: 0x%x", (uint32_t)pte);
        Assert(pte->present == 0);
   1065e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10661:	0f b6 00             	movzbl (%eax),%eax
   10664:	83 e0 01             	and    $0x1,%eax
   10667:	84 c0                	test   %al,%al
   10669:	74 19                	je     10684 <memory_create_map+0x68>
   1066b:	68 5c 90 01 00       	push   $0x1905c
   10670:	68 64 91 01 00       	push   $0x19164
   10675:	6a 68                	push   $0x68
   10677:	68 70 90 01 00       	push   $0x19070
   1067c:	e8 6e 86 00 00       	call   18cef <pannic>
   10681:	83 c4 10             	add    $0x10,%esp

        pte->v = pstart | perm | PTE_P;
   10684:	8b 45 10             	mov    0x10(%ebp),%eax
   10687:	0b 45 18             	or     0x18(%ebp),%eax
   1068a:	83 c8 01             	or     $0x1,%eax
   1068d:	89 c2                	mov    %eax,%edx
   1068f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10692:	89 10                	mov    %edx,(%eax)

        vstart += MEM_PAGE_SIZE;
   10694:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        pstart += MEM_PAGE_SIZE;
   1069b:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for (int i = 0; i < count; i++) {
   106a2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   106a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   106a9:	39 45 14             	cmp    %eax,0x14(%ebp)
   106ac:	0f 87 79 ff ff ff    	ja     1062b <memory_create_map+0xf>
    }

    return 0;
   106b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   106b7:	c9                   	leave  
   106b8:	c3                   	ret    

000106b9 <create_kernel_table>:
void create_kernel_table(void){
   106b9:	55                   	push   %ebp
   106ba:	89 e5                	mov    %esp,%ebp
   106bc:	83 ec 28             	sub    $0x28,%esp
        {s_text, e_text, s_text, 0},
        {s_data, (void*)(MEM_EBDA_START - 1), s_data, PTE_W},
        {(void*)CONSOLE_BASE, (void*)CONSOLE_END, (void*)CONSOLE_BASE, PTE_W},
        {(void*)MEM_EXT_START, (void*)MEM_EXT_END, (void*)MEM_EXT_START, PTE_W}
    };
    for(int i = 0; i < sizeof(kernel_map)/sizeof(memory_map_t); ++i){
   106bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   106c6:	e9 82 00 00 00       	jmp    1074d <create_kernel_table+0x94>
        memory_map_t* desc = kernel_map + i;
   106cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   106ce:	c1 e0 04             	shl    $0x4,%eax
   106d1:	05 00 b0 01 00       	add    $0x1b000,%eax
   106d6:	89 45 f0             	mov    %eax,-0x10(%ebp)

        uint32_t vstart = down2((uint32_t)desc -> vstart, MEM_PAGE_SIZE);
   106d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106dc:	8b 00                	mov    (%eax),%eax
   106de:	68 00 10 00 00       	push   $0x1000
   106e3:	50                   	push   %eax
   106e4:	e8 2e fc ff ff       	call   10317 <down2>
   106e9:	83 c4 08             	add    $0x8,%esp
   106ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t vend = up2((uint32_t)desc -> vend, MEM_PAGE_SIZE);
   106ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   106f2:	8b 40 04             	mov    0x4(%eax),%eax
   106f5:	68 00 10 00 00       	push   $0x1000
   106fa:	50                   	push   %eax
   106fb:	e8 00 fc ff ff       	call   10300 <up2>
   10700:	83 c4 08             	add    $0x8,%esp
   10703:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t pstart = down2((uint32_t)desc -> pstart, MEM_PAGE_SIZE);
   10706:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10709:	8b 40 08             	mov    0x8(%eax),%eax
   1070c:	68 00 10 00 00       	push   $0x1000
   10711:	50                   	push   %eax
   10712:	e8 00 fc ff ff       	call   10317 <down2>
   10717:	83 c4 08             	add    $0x8,%esp
   1071a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        uint32_t page_count = (vend - vstart) / MEM_PAGE_SIZE;
   1071d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10720:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10723:	c1 e8 0c             	shr    $0xc,%eax
   10726:	89 45 e0             	mov    %eax,-0x20(%ebp)
        memory_create_map(kernel_page_dir, vstart, pstart, page_count, desc->perm);
   10729:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1072c:	8b 40 0c             	mov    0xc(%eax),%eax
   1072f:	83 ec 0c             	sub    $0xc,%esp
   10732:	50                   	push   %eax
   10733:	ff 75 e0             	pushl  -0x20(%ebp)
   10736:	ff 75 e4             	pushl  -0x1c(%ebp)
   10739:	ff 75 ec             	pushl  -0x14(%ebp)
   1073c:	68 00 d0 01 00       	push   $0x1d000
   10741:	e8 d6 fe ff ff       	call   1061c <memory_create_map>
   10746:	83 c4 20             	add    $0x20,%esp
    for(int i = 0; i < sizeof(kernel_map)/sizeof(memory_map_t); ++i){
   10749:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1074d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10750:	83 f8 04             	cmp    $0x4,%eax
   10753:	0f 86 72 ff ff ff    	jbe    106cb <create_kernel_table+0x12>
    
    }
}
   10759:	90                   	nop
   1075a:	c9                   	leave  
   1075b:	c3                   	ret    

0001075c <memory_init>:
 * @brief 初始化内存管理系统
 * 该函数的主要任务：
 * 1、初始化物理内存分配器：将所有物理内存管理起来. 在1MB内存中分配物理位图
 * 2、重新创建内核页表：原loader中创建的页表已经不再合适
 */
void memory_init (boot_info_t * boot_info) {
   1075c:	55                   	push   %ebp
   1075d:	89 e5                	mov    %esp,%ebp
   1075f:	83 ec 18             	sub    $0x18,%esp
    // 1MB内存空间起始，在链接脚本中定义
    extern uint8_t * mem_free_start; 

    log_printf("mem init.");
   10762:	83 ec 0c             	sub    $0xc,%esp
   10765:	68 bd 90 01 00       	push   $0x190bd
   1076a:	e8 dd 87 00 00       	call   18f4c <log_printf>
   1076f:	83 c4 10             	add    $0x10,%esp
    show_mem_info(boot_info);
   10772:	83 ec 0c             	sub    $0xc,%esp
   10775:	ff 75 08             	pushl  0x8(%ebp)
   10778:	e8 4d fd ff ff       	call   104ca <show_mem_info>
   1077d:	83 c4 10             	add    $0x10,%esp

    // 在内核数据后面放物理页位图
    uint8_t * mem_free = (uint8_t *)&mem_free_start;   // 2022年-10-1 经同学反馈，发现这里有点bug，改了下
   10780:	c7 45 f4 e7 05 06 00 	movl   $0x605e7,-0xc(%ebp)

    // 计算1MB以上空间的空闲内存容量，并对齐的页边界
    uint32_t mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START;
   10787:	83 ec 0c             	sub    $0xc,%esp
   1078a:	ff 75 08             	pushl  0x8(%ebp)
   1078d:	e8 9e fd ff ff       	call   10530 <total_mem_size>
   10792:	83 c4 10             	add    $0x10,%esp
   10795:	2d 00 00 10 00       	sub    $0x100000,%eax
   1079a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE);   // 对齐到4KB页
   1079d:	83 ec 08             	sub    $0x8,%esp
   107a0:	68 00 10 00 00       	push   $0x1000
   107a5:	ff 75 f0             	pushl  -0x10(%ebp)
   107a8:	e8 6a fb ff ff       	call   10317 <down2>
   107ad:	83 c4 10             	add    $0x10,%esp
   107b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    // log_printf("Free memory: 0x%x, size: 0x%x", MEM_EXT_START, mem_up1MB_free);

    // 4GB大小需要总共4*1024*1024*1024/4096/8=128KB的位图, 使用低1MB的RAM空间中足够
    // 该部分的内存仅跟在mem_free_start开始放置
    addr_alloc_init(&paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE);
   107b3:	83 ec 0c             	sub    $0xc,%esp
   107b6:	68 00 10 00 00       	push   $0x1000
   107bb:	ff 75 f0             	pushl  -0x10(%ebp)
   107be:	68 00 00 10 00       	push   $0x100000
   107c3:	ff 75 f4             	pushl  -0xc(%ebp)
   107c6:	68 00 c0 01 00       	push   $0x1c000
   107cb:	e8 dd fb ff ff       	call   103ad <addr_alloc_init>
   107d0:	83 c4 20             	add    $0x20,%esp
    mem_free += bit_count(paddr_alloc.size / MEM_PAGE_SIZE);
   107d3:	a1 18 c0 01 00       	mov    0x1c018,%eax
   107d8:	c1 e8 0c             	shr    $0xc,%eax
   107db:	83 ec 0c             	sub    $0xc,%esp
   107de:	50                   	push   %eax
   107df:	e8 90 7d 00 00       	call   18574 <bit_count>
   107e4:	83 c4 10             	add    $0x10,%esp
   107e7:	01 45 f4             	add    %eax,-0xc(%ebp)

    // 到这里，mem_free应该比EBDA地址要小
    Assert(mem_free < (uint8_t *)MEM_EBDA_START);
   107ea:	81 7d f4 ff ff 07 00 	cmpl   $0x7ffff,-0xc(%ebp)
   107f1:	76 1c                	jbe    1080f <memory_init+0xb3>
   107f3:	68 c8 90 01 00       	push   $0x190c8
   107f8:	68 78 91 01 00       	push   $0x19178
   107fd:	68 a1 00 00 00       	push   $0xa1
   10802:	68 70 90 01 00       	push   $0x19070
   10807:	e8 e3 84 00 00       	call   18cef <pannic>
   1080c:	83 c4 10             	add    $0x10,%esp
    create_kernel_table();
   1080f:	e8 a5 fe ff ff       	call   106b9 <create_kernel_table>
    mmu_set_page_dir((uint32_t)kernel_page_dir);
   10814:	b8 00 d0 01 00       	mov    $0x1d000,%eax
   10819:	83 ec 0c             	sub    $0xc,%esp
   1081c:	50                   	push   %eax
   1081d:	e8 02 fb ff ff       	call   10324 <mmu_set_page_dir>
   10822:	83 c4 10             	add    $0x10,%esp
}
   10825:	90                   	nop
   10826:	c9                   	leave  
   10827:	c3                   	ret    

00010828 <memory_create_uvm>:
//这个函数用于将不同进程的前0x80000000的虚拟内存与内核的虚拟内存共享
uint32_t memory_create_uvm()
{
   10828:	55                   	push   %ebp
   10829:	89 e5                	mov    %esp,%ebp
   1082b:	83 ec 18             	sub    $0x18,%esp
    pde_t* page_dir = (pde_t*)addr_alloc_page(&paddr_alloc, 1);
   1082e:	83 ec 08             	sub    $0x8,%esp
   10831:	6a 01                	push   $0x1
   10833:	68 00 c0 01 00       	push   $0x1c000
   10838:	e8 c8 fb ff ff       	call   10405 <addr_alloc_page>
   1083d:	83 c4 10             	add    $0x10,%esp
   10840:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_dir == (pde_t*)0)
   10843:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10847:	75 07                	jne    10850 <memory_create_uvm+0x28>
        return 0;
   10849:	b8 00 00 00 00       	mov    $0x0,%eax
   1084e:	eb 5e                	jmp    108ae <memory_create_uvm+0x86>
    kernel_memset((void*)page_dir, 0, MEM_PAGE_SIZE);
   10850:	83 ec 04             	sub    $0x4,%esp
   10853:	68 00 10 00 00       	push   $0x1000
   10858:	6a 00                	push   $0x0
   1085a:	ff 75 f0             	pushl  -0x10(%ebp)
   1085d:	e8 40 81 00 00       	call   189a2 <kernel_memset>
   10862:	83 c4 10             	add    $0x10,%esp
    uint32_t user_pd_index = pde_index(MEMORY_TASK_BASE);
   10865:	83 ec 0c             	sub    $0xc,%esp
   10868:	68 00 00 00 80       	push   $0x80000000
   1086d:	e8 c3 fa ff ff       	call   10335 <pde_index>
   10872:	83 c4 10             	add    $0x10,%esp
   10875:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(uint32_t i = 0; i < user_pd_index; ++i)
   10878:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1087f:	eb 22                	jmp    108a3 <memory_create_uvm+0x7b>
    {
        (page_dir + i)->v = (kernel_page_dir + i)->v;
   10881:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10884:	c1 e0 02             	shl    $0x2,%eax
   10887:	05 00 d0 01 00       	add    $0x1d000,%eax
   1088c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1088f:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
   10896:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10899:	01 ca                	add    %ecx,%edx
   1089b:	8b 00                	mov    (%eax),%eax
   1089d:	89 02                	mov    %eax,(%edx)
    for(uint32_t i = 0; i < user_pd_index; ++i)
   1089f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   108a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   108a6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   108a9:	72 d6                	jb     10881 <memory_create_uvm+0x59>
    }
    return (uint32_t)page_dir;
   108ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   108ae:	c9                   	leave  
   108af:	c3                   	ret    

000108b0 <memory_alloc_for_page>:
//分配进程使用的虚拟地址
int memory_alloc_for_page(uint32_t addr, uint32_t size, uint32_t perm)
{
   108b0:	55                   	push   %ebp
   108b1:	89 e5                	mov    %esp,%ebp
   108b3:	83 ec 08             	sub    $0x8,%esp
    return memory_alloc_for_page_dir(task_manager.curr_task->tss.cr3, addr, size, perm);
   108b6:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   108bb:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
   108c1:	ff 75 10             	pushl  0x10(%ebp)
   108c4:	ff 75 0c             	pushl  0xc(%ebp)
   108c7:	ff 75 08             	pushl  0x8(%ebp)
   108ca:	50                   	push   %eax
   108cb:	e8 05 00 00 00       	call   108d5 <memory_alloc_for_page_dir>
   108d0:	83 c4 10             	add    $0x10,%esp
}
   108d3:	c9                   	leave  
   108d4:	c3                   	ret    

000108d5 <memory_alloc_for_page_dir>:

int memory_alloc_for_page_dir(uint32_t page_dir, uint32_t vaddr, uint32_t size, uint32_t perm)
{
   108d5:	55                   	push   %ebp
   108d6:	89 e5                	mov    %esp,%ebp
   108d8:	83 ec 28             	sub    $0x28,%esp
    uint32_t curr_vaddr = vaddr;
   108db:	8b 45 0c             	mov    0xc(%ebp),%eax
   108de:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE;
   108e1:	68 00 10 00 00       	push   $0x1000
   108e6:	ff 75 10             	pushl  0x10(%ebp)
   108e9:	e8 12 fa ff ff       	call   10300 <up2>
   108ee:	83 c4 08             	add    $0x8,%esp
   108f1:	c1 e8 0c             	shr    $0xc,%eax
   108f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i = 0; i < page_count; ++i){
   108f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   108fe:	eb 77                	jmp    10977 <memory_alloc_for_page_dir+0xa2>
        uint32_t paddr = addr_alloc_page(&paddr_alloc, 1);
   10900:	83 ec 08             	sub    $0x8,%esp
   10903:	6a 01                	push   $0x1
   10905:	68 00 c0 01 00       	push   $0x1c000
   1090a:	e8 f6 fa ff ff       	call   10405 <addr_alloc_page>
   1090f:	83 c4 10             	add    $0x10,%esp
   10912:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if(paddr == 0){
   10915:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   10919:	75 17                	jne    10932 <memory_alloc_for_page_dir+0x5d>
            log_printf("no mem");
   1091b:	83 ec 0c             	sub    $0xc,%esp
   1091e:	68 ed 90 01 00       	push   $0x190ed
   10923:	e8 24 86 00 00       	call   18f4c <log_printf>
   10928:	83 c4 10             	add    $0x10,%esp
            return 0;
   1092b:	b8 00 00 00 00       	mov    $0x0,%eax
   10930:	eb 52                	jmp    10984 <memory_alloc_for_page_dir+0xaf>
        }
        int err = memory_create_map((pde_t*)page_dir, vaddr, paddr, 1, perm);
   10932:	8b 45 08             	mov    0x8(%ebp),%eax
   10935:	83 ec 0c             	sub    $0xc,%esp
   10938:	ff 75 14             	pushl  0x14(%ebp)
   1093b:	6a 01                	push   $0x1
   1093d:	ff 75 e8             	pushl  -0x18(%ebp)
   10940:	ff 75 0c             	pushl  0xc(%ebp)
   10943:	50                   	push   %eax
   10944:	e8 d3 fc ff ff       	call   1061c <memory_create_map>
   10949:	83 c4 20             	add    $0x20,%esp
   1094c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err < 0){
   1094f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10953:	79 17                	jns    1096c <memory_alloc_for_page_dir+0x97>
            log_printf("cannot create map");
   10955:	83 ec 0c             	sub    $0xc,%esp
   10958:	68 f4 90 01 00       	push   $0x190f4
   1095d:	e8 ea 85 00 00       	call   18f4c <log_printf>
   10962:	83 c4 10             	add    $0x10,%esp
            // addr_free_page(&paddr, paddr, 1);
            return 0;
   10965:	b8 00 00 00 00       	mov    $0x0,%eax
   1096a:	eb 18                	jmp    10984 <memory_alloc_for_page_dir+0xaf>
        }
        vaddr += MEM_PAGE_SIZE;
   1096c:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
    for(int i = 0; i < page_count; ++i){
   10973:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10977:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1097a:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   1097d:	77 81                	ja     10900 <memory_alloc_for_page_dir+0x2b>
    } 
    return 0;
   1097f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10984:	c9                   	leave  
   10985:	c3                   	ret    

00010986 <memory_alloc_page>:
//用于分配0X80000000以下的地址，一一映射。
uint32_t memory_alloc_page(void)
{
   10986:	55                   	push   %ebp
   10987:	89 e5                	mov    %esp,%ebp
   10989:	83 ec 08             	sub    $0x8,%esp
    return addr_alloc_page(&paddr_alloc, 1);
   1098c:	83 ec 08             	sub    $0x8,%esp
   1098f:	6a 01                	push   $0x1
   10991:	68 00 c0 01 00       	push   $0x1c000
   10996:	e8 6a fa ff ff       	call   10405 <addr_alloc_page>
   1099b:	83 c4 10             	add    $0x10,%esp
}
   1099e:	c9                   	leave  
   1099f:	c3                   	ret    

000109a0 <memory_free_page>:

void  memory_free_page(uint32_t addr)
{
   109a0:	55                   	push   %ebp
   109a1:	89 e5                	mov    %esp,%ebp
   109a3:	83 ec 18             	sub    $0x18,%esp
    if(addr < MEMORY_TASK_BASE){
   109a6:	8b 45 08             	mov    0x8(%ebp),%eax
   109a9:	85 c0                	test   %eax,%eax
   109ab:	78 17                	js     109c4 <memory_free_page+0x24>
        addr_free_page(&paddr_alloc, addr, 1);
   109ad:	83 ec 04             	sub    $0x4,%esp
   109b0:	6a 01                	push   $0x1
   109b2:	ff 75 08             	pushl  0x8(%ebp)
   109b5:	68 00 c0 01 00       	push   $0x1c000
   109ba:	e8 ad fa ff ff       	call   1046c <addr_free_page>
   109bf:	83 c4 10             	add    $0x10,%esp
        pte_t* pg_table = find_pte((pde_t*)curr_page_dir(), addr, 0);
        Assert(pg_table != 0 && pg_table->present);
        addr_free_page(&paddr_alloc, pte_paddr(pg_table), 1);
        pg_table->v = 0;
    }
}
   109c2:	eb 72                	jmp    10a36 <memory_free_page+0x96>
        pte_t* pg_table = find_pte((pde_t*)curr_page_dir(), addr, 0);
   109c4:	e8 70 00 00 00       	call   10a39 <curr_page_dir>
   109c9:	83 ec 04             	sub    $0x4,%esp
   109cc:	6a 00                	push   $0x0
   109ce:	ff 75 08             	pushl  0x8(%ebp)
   109d1:	50                   	push   %eax
   109d2:	e8 95 fb ff ff       	call   1056c <find_pte>
   109d7:	83 c4 10             	add    $0x10,%esp
   109da:	89 45 f4             	mov    %eax,-0xc(%ebp)
        Assert(pg_table != 0 && pg_table->present);
   109dd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   109e1:	74 0d                	je     109f0 <memory_free_page+0x50>
   109e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109e6:	0f b6 00             	movzbl (%eax),%eax
   109e9:	83 e0 01             	and    $0x1,%eax
   109ec:	84 c0                	test   %al,%al
   109ee:	75 1c                	jne    10a0c <memory_free_page+0x6c>
   109f0:	68 08 91 01 00       	push   $0x19108
   109f5:	68 84 91 01 00       	push   $0x19184
   109fa:	68 da 00 00 00       	push   $0xda
   109ff:	68 70 90 01 00       	push   $0x19070
   10a04:	e8 e6 82 00 00       	call   18cef <pannic>
   10a09:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&paddr_alloc, pte_paddr(pg_table), 1);
   10a0c:	83 ec 0c             	sub    $0xc,%esp
   10a0f:	ff 75 f4             	pushl  -0xc(%ebp)
   10a12:	e8 60 f9 ff ff       	call   10377 <pte_paddr>
   10a17:	83 c4 10             	add    $0x10,%esp
   10a1a:	83 ec 04             	sub    $0x4,%esp
   10a1d:	6a 01                	push   $0x1
   10a1f:	50                   	push   %eax
   10a20:	68 00 c0 01 00       	push   $0x1c000
   10a25:	e8 42 fa ff ff       	call   1046c <addr_free_page>
   10a2a:	83 c4 10             	add    $0x10,%esp
        pg_table->v = 0;
   10a2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a30:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   10a36:	90                   	nop
   10a37:	c9                   	leave  
   10a38:	c3                   	ret    

00010a39 <curr_page_dir>:

uint32_t curr_page_dir(void){
   10a39:	55                   	push   %ebp
   10a3a:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task->tss.cr3;
   10a3c:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   10a41:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
}
   10a47:	5d                   	pop    %ebp
   10a48:	c3                   	ret    

00010a49 <memory_copy_uvm>:

uint32_t memory_copy_uvm (uint32_t page_dir) {
   10a49:	55                   	push   %ebp
   10a4a:	89 e5                	mov    %esp,%ebp
   10a4c:	83 ec 38             	sub    $0x38,%esp
    uint32_t to_page_dir = memory_create_uvm();
   10a4f:	e8 d4 fd ff ff       	call   10828 <memory_create_uvm>
   10a54:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (to_page_dir == 0) {
   10a57:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10a5b:	0f 84 1b 01 00 00    	je     10b7c <memory_copy_uvm+0x133>
        goto copy_uvm_failed;
    }

    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   10a61:	83 ec 0c             	sub    $0xc,%esp
   10a64:	68 00 00 00 80       	push   $0x80000000
   10a69:	e8 c7 f8 ff ff       	call   10335 <pde_index>
   10a6e:	83 c4 10             	add    $0x10,%esp
   10a71:	89 45 e0             	mov    %eax,-0x20(%ebp)
    pde_t * pde = (pde_t *)page_dir + user_pde_start;
   10a74:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10a77:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10a7e:	8b 45 08             	mov    0x8(%ebp),%eax
   10a81:	01 d0                	add    %edx,%eax
   10a83:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   10a86:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10a89:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10a8c:	e9 d9 00 00 00       	jmp    10b6a <memory_copy_uvm+0x121>
        if (!pde->present) {
   10a91:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a94:	0f b6 00             	movzbl (%eax),%eax
   10a97:	83 e0 01             	and    $0x1,%eax
   10a9a:	84 c0                	test   %al,%al
   10a9c:	0f 84 bf 00 00 00    	je     10b61 <memory_copy_uvm+0x118>
            continue;
        }

        pte_t * pte = (pte_t *)pde_paddr(pde);
   10aa2:	83 ec 0c             	sub    $0xc,%esp
   10aa5:	ff 75 f4             	pushl  -0xc(%ebp)
   10aa8:	e8 a3 f8 ff ff       	call   10350 <pde_paddr>
   10aad:	83 c4 10             	add    $0x10,%esp
   10ab0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   10ab3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10aba:	e9 93 00 00 00       	jmp    10b52 <memory_copy_uvm+0x109>
            if (!pte->present) {
   10abf:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ac2:	0f b6 00             	movzbl (%eax),%eax
   10ac5:	83 e0 01             	and    $0x1,%eax
   10ac8:	84 c0                	test   %al,%al
   10aca:	74 7d                	je     10b49 <memory_copy_uvm+0x100>
                continue;
            }

            uint32_t page = addr_alloc_page(&paddr_alloc, 1);
   10acc:	83 ec 08             	sub    $0x8,%esp
   10acf:	6a 01                	push   $0x1
   10ad1:	68 00 c0 01 00       	push   $0x1c000
   10ad6:	e8 2a f9 ff ff       	call   10405 <addr_alloc_page>
   10adb:	83 c4 10             	add    $0x10,%esp
   10ade:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if (page == 0) {
   10ae1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   10ae5:	0f 84 94 00 00 00    	je     10b7f <memory_copy_uvm+0x136>
                goto copy_uvm_failed;
            }

            uint32_t vaddr = (i << 22) | (j << 12);
   10aeb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10aee:	c1 e0 16             	shl    $0x16,%eax
   10af1:	89 c2                	mov    %eax,%edx
   10af3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10af6:	c1 e0 0c             	shl    $0xc,%eax
   10af9:	09 d0                	or     %edx,%eax
   10afb:	89 45 d8             	mov    %eax,-0x28(%ebp)
            int err = memory_create_map((pde_t *)to_page_dir, vaddr, page, 1, get_pte_perm(pte));
   10afe:	83 ec 0c             	sub    $0xc,%esp
   10b01:	ff 75 ec             	pushl  -0x14(%ebp)
   10b04:	e8 95 f8 ff ff       	call   1039e <get_pte_perm>
   10b09:	83 c4 10             	add    $0x10,%esp
   10b0c:	89 c2                	mov    %eax,%edx
   10b0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10b11:	83 ec 0c             	sub    $0xc,%esp
   10b14:	52                   	push   %edx
   10b15:	6a 01                	push   $0x1
   10b17:	ff 75 dc             	pushl  -0x24(%ebp)
   10b1a:	ff 75 d8             	pushl  -0x28(%ebp)
   10b1d:	50                   	push   %eax
   10b1e:	e8 f9 fa ff ff       	call   1061c <memory_create_map>
   10b23:	83 c4 20             	add    $0x20,%esp
   10b26:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if (err < 0) {
   10b29:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10b2d:	78 53                	js     10b82 <memory_copy_uvm+0x139>
                goto copy_uvm_failed;
            }

            kernel_memcpy((void *)page, (void *)vaddr, MEM_PAGE_SIZE);
   10b2f:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10b32:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10b35:	83 ec 04             	sub    $0x4,%esp
   10b38:	68 00 10 00 00       	push   $0x1000
   10b3d:	52                   	push   %edx
   10b3e:	50                   	push   %eax
   10b3f:	e8 0f 7e 00 00       	call   18953 <kernel_memcpy>
   10b44:	83 c4 10             	add    $0x10,%esp
   10b47:	eb 01                	jmp    10b4a <memory_copy_uvm+0x101>
                continue;
   10b49:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   10b4a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10b4e:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10b52:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10b59:	0f 8e 60 ff ff ff    	jle    10abf <memory_copy_uvm+0x76>
   10b5f:	eb 01                	jmp    10b62 <memory_copy_uvm+0x119>
            continue;
   10b61:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   10b62:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10b66:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10b6a:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10b71:	0f 8e 1a ff ff ff    	jle    10a91 <memory_copy_uvm+0x48>
        }
    }
    return to_page_dir;
   10b77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10b7a:	eb 20                	jmp    10b9c <memory_copy_uvm+0x153>
        goto copy_uvm_failed;
   10b7c:	90                   	nop
   10b7d:	eb 04                	jmp    10b83 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10b7f:	90                   	nop
   10b80:	eb 01                	jmp    10b83 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   10b82:	90                   	nop

copy_uvm_failed:
    if (to_page_dir) {
   10b83:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   10b87:	74 0e                	je     10b97 <memory_copy_uvm+0x14e>
        memory_destroy_uvm(to_page_dir);
   10b89:	83 ec 0c             	sub    $0xc,%esp
   10b8c:	ff 75 e4             	pushl  -0x1c(%ebp)
   10b8f:	e8 0a 00 00 00       	call   10b9e <memory_destroy_uvm>
   10b94:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   10b97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10b9c:	c9                   	leave  
   10b9d:	c3                   	ret    

00010b9e <memory_destroy_uvm>:

void memory_destroy_uvm(uint32_t page_dir)
{
   10b9e:	55                   	push   %ebp
   10b9f:	89 e5                	mov    %esp,%ebp
   10ba1:	83 ec 28             	sub    $0x28,%esp
    uint32_t to_page_dir = memory_create_uvm();
   10ba4:	e8 7f fc ff ff       	call   10828 <memory_create_uvm>
   10ba9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t* pde = (pde_t*)page_dir  + pde_index(MEMORY_TASK_BASE);
   10bac:	83 ec 0c             	sub    $0xc,%esp
   10baf:	68 00 00 00 80       	push   $0x80000000
   10bb4:	e8 7c f7 ff ff       	call   10335 <pde_index>
   10bb9:	83 c4 10             	add    $0x10,%esp
   10bbc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10bc3:	8b 45 08             	mov    0x8(%ebp),%eax
   10bc6:	01 d0                	add    %edx,%eax
   10bc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(int i = pde_index(MEMORY_TASK_BASE); i < PDE_CNT; ++i, ++pde)
   10bcb:	83 ec 0c             	sub    $0xc,%esp
   10bce:	68 00 00 00 80       	push   $0x80000000
   10bd3:	e8 5d f7 ff ff       	call   10335 <pde_index>
   10bd8:	83 c4 10             	add    $0x10,%esp
   10bdb:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10bde:	e9 95 00 00 00       	jmp    10c78 <memory_destroy_uvm+0xda>
    {
        if(!pde -> present)
   10be3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10be6:	0f b6 00             	movzbl (%eax),%eax
   10be9:	83 e0 01             	and    $0x1,%eax
   10bec:	84 c0                	test   %al,%al
   10bee:	74 7f                	je     10c6f <memory_destroy_uvm+0xd1>
            continue;
        pte_t* pte = (pte_t*)pde_paddr(pde);
   10bf0:	83 ec 0c             	sub    $0xc,%esp
   10bf3:	ff 75 f4             	pushl  -0xc(%ebp)
   10bf6:	e8 55 f7 ff ff       	call   10350 <pde_paddr>
   10bfb:	83 c4 10             	add    $0x10,%esp
   10bfe:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(int j = 0; j < PTE_CNT; ++j, ++pte)
   10c01:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   10c08:	eb 39                	jmp    10c43 <memory_destroy_uvm+0xa5>
        {
            if(!pte -> present)
   10c0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c0d:	0f b6 00             	movzbl (%eax),%eax
   10c10:	83 e0 01             	and    $0x1,%eax
   10c13:	84 c0                	test   %al,%al
   10c15:	74 23                	je     10c3a <memory_destroy_uvm+0x9c>
                continue;
            addr_free_page(&paddr_alloc, (uint32_t)pte_paddr(pte), 1);
   10c17:	83 ec 0c             	sub    $0xc,%esp
   10c1a:	ff 75 ec             	pushl  -0x14(%ebp)
   10c1d:	e8 55 f7 ff ff       	call   10377 <pte_paddr>
   10c22:	83 c4 10             	add    $0x10,%esp
   10c25:	83 ec 04             	sub    $0x4,%esp
   10c28:	6a 01                	push   $0x1
   10c2a:	50                   	push   %eax
   10c2b:	68 00 c0 01 00       	push   $0x1c000
   10c30:	e8 37 f8 ff ff       	call   1046c <addr_free_page>
   10c35:	83 c4 10             	add    $0x10,%esp
   10c38:	eb 01                	jmp    10c3b <memory_destroy_uvm+0x9d>
                continue;
   10c3a:	90                   	nop
        for(int j = 0; j < PTE_CNT; ++j, ++pte)
   10c3b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   10c3f:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   10c43:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   10c4a:	7e be                	jle    10c0a <memory_destroy_uvm+0x6c>
        }
        addr_free_page(&paddr_alloc, (uint32_t)pde_paddr(pde), 1);
   10c4c:	83 ec 0c             	sub    $0xc,%esp
   10c4f:	ff 75 f4             	pushl  -0xc(%ebp)
   10c52:	e8 f9 f6 ff ff       	call   10350 <pde_paddr>
   10c57:	83 c4 10             	add    $0x10,%esp
   10c5a:	83 ec 04             	sub    $0x4,%esp
   10c5d:	6a 01                	push   $0x1
   10c5f:	50                   	push   %eax
   10c60:	68 00 c0 01 00       	push   $0x1c000
   10c65:	e8 02 f8 ff ff       	call   1046c <addr_free_page>
   10c6a:	83 c4 10             	add    $0x10,%esp
   10c6d:	eb 01                	jmp    10c70 <memory_destroy_uvm+0xd2>
            continue;
   10c6f:	90                   	nop
    for(int i = pde_index(MEMORY_TASK_BASE); i < PDE_CNT; ++i, ++pde)
   10c70:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10c74:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   10c78:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   10c7f:	0f 8e 5e ff ff ff    	jle    10be3 <memory_destroy_uvm+0x45>
    }
    addr_free_page(&paddr_alloc, page_dir, 1);
   10c85:	83 ec 04             	sub    $0x4,%esp
   10c88:	6a 01                	push   $0x1
   10c8a:	ff 75 08             	pushl  0x8(%ebp)
   10c8d:	68 00 c0 01 00       	push   $0x1c000
   10c92:	e8 d5 f7 ff ff       	call   1046c <addr_free_page>
   10c97:	83 c4 10             	add    $0x10,%esp
}
   10c9a:	90                   	nop
   10c9b:	c9                   	leave  
   10c9c:	c3                   	ret    

00010c9d <memory_get_paddr>:

uint32_t memory_get_paddr(uint32_t page_dir, uint32_t vaddr)
{
   10c9d:	55                   	push   %ebp
   10c9e:	89 e5                	mov    %esp,%ebp
   10ca0:	83 ec 18             	sub    $0x18,%esp
    pte_t* pte = find_pte((pde_t*)page_dir, vaddr, 0);
   10ca3:	8b 45 08             	mov    0x8(%ebp),%eax
   10ca6:	83 ec 04             	sub    $0x4,%esp
   10ca9:	6a 00                	push   $0x0
   10cab:	ff 75 0c             	pushl  0xc(%ebp)
   10cae:	50                   	push   %eax
   10caf:	e8 b8 f8 ff ff       	call   1056c <find_pte>
   10cb4:	83 c4 10             	add    $0x10,%esp
   10cb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (pte == (pte_t *)0) {
   10cba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10cbe:	75 07                	jne    10cc7 <memory_get_paddr+0x2a>
        return 0;
   10cc0:	b8 00 00 00 00       	mov    $0x0,%eax
   10cc5:	eb 1a                	jmp    10ce1 <memory_get_paddr+0x44>
    }
    return (pte_paddr(pte) + (vaddr & (MEM_PAGE_SIZE - 1)));
   10cc7:	83 ec 0c             	sub    $0xc,%esp
   10cca:	ff 75 f4             	pushl  -0xc(%ebp)
   10ccd:	e8 a5 f6 ff ff       	call   10377 <pte_paddr>
   10cd2:	83 c4 10             	add    $0x10,%esp
   10cd5:	89 c2                	mov    %eax,%edx
   10cd7:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cda:	25 ff 0f 00 00       	and    $0xfff,%eax
   10cdf:	01 d0                	add    %edx,%eax
}
   10ce1:	c9                   	leave  
   10ce2:	c3                   	ret    

00010ce3 <memory_copy_uvm_data>:

int memory_copy_uvm_data(uint32_t to, uint32_t page_dir, uint32_t from, uint32_t size)
{
   10ce3:	55                   	push   %ebp
   10ce4:	89 e5                	mov    %esp,%ebp
   10ce6:	83 ec 18             	sub    $0x18,%esp
    
    while(size > 0)
   10ce9:	eb 6e                	jmp    10d59 <memory_copy_uvm_data+0x76>
    {
        uint32_t paddr = memory_get_paddr(page_dir, to);
   10ceb:	83 ec 08             	sub    $0x8,%esp
   10cee:	ff 75 08             	pushl  0x8(%ebp)
   10cf1:	ff 75 0c             	pushl  0xc(%ebp)
   10cf4:	e8 a4 ff ff ff       	call   10c9d <memory_get_paddr>
   10cf9:	83 c4 10             	add    $0x10,%esp
   10cfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(paddr == 0) 
   10cff:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10d03:	75 07                	jne    10d0c <memory_copy_uvm_data+0x29>
            return -1;
   10d05:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10d0a:	eb 58                	jmp    10d64 <memory_copy_uvm_data+0x81>
        uint32_t offset_in_page = paddr & (MEM_PAGE_SIZE - 1);
   10d0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d0f:	25 ff 0f 00 00       	and    $0xfff,%eax
   10d14:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t curr_size = MEM_PAGE_SIZE - offset_in_page;
   10d17:	b8 00 10 00 00       	mov    $0x1000,%eax
   10d1c:	2b 45 ec             	sub    -0x14(%ebp),%eax
   10d1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(curr_size > size)
   10d22:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d25:	3b 45 14             	cmp    0x14(%ebp),%eax
   10d28:	76 06                	jbe    10d30 <memory_copy_uvm_data+0x4d>
            curr_size = size;
   10d2a:	8b 45 14             	mov    0x14(%ebp),%eax
   10d2d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        kernel_memcpy((void*)paddr, (void*)from, curr_size);
   10d30:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   10d33:	8b 55 10             	mov    0x10(%ebp),%edx
   10d36:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d39:	83 ec 04             	sub    $0x4,%esp
   10d3c:	51                   	push   %ecx
   10d3d:	52                   	push   %edx
   10d3e:	50                   	push   %eax
   10d3f:	e8 0f 7c 00 00       	call   18953 <kernel_memcpy>
   10d44:	83 c4 10             	add    $0x10,%esp
        size -= curr_size;
   10d47:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d4a:	29 45 14             	sub    %eax,0x14(%ebp)
        to += curr_size;
   10d4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d50:	01 45 08             	add    %eax,0x8(%ebp)
        from += curr_size;
   10d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d56:	01 45 10             	add    %eax,0x10(%ebp)
    while(size > 0)
   10d59:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   10d5d:	75 8c                	jne    10ceb <memory_copy_uvm_data+0x8>
    }
    return 0;
   10d5f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10d64:	c9                   	leave  
   10d65:	c3                   	ret    

00010d66 <sys_sbrk>:

char * sys_sbrk(int incr) {
   10d66:	55                   	push   %ebp
   10d67:	89 e5                	mov    %esp,%ebp
   10d69:	83 ec 38             	sub    $0x38,%esp
    task_t * task = task_manager.curr_task;
   10d6c:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   10d71:	89 45 f0             	mov    %eax,-0x10(%ebp)
    char * pre_heap_end = (char * )task->heap_end;
   10d74:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d77:	8b 40 0c             	mov    0xc(%eax),%eax
   10d7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int pre_incr = incr;
   10d7d:	8b 45 08             	mov    0x8(%ebp),%eax
   10d80:	89 45 e8             	mov    %eax,-0x18(%ebp)

    Assert(incr >= 0);
   10d83:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10d87:	79 1c                	jns    10da5 <sys_sbrk+0x3f>
   10d89:	68 2b 91 01 00       	push   $0x1912b
   10d8e:	68 98 91 01 00       	push   $0x19198
   10d93:	68 45 01 00 00       	push   $0x145
   10d98:	68 70 90 01 00       	push   $0x19070
   10d9d:	e8 4d 7f 00 00       	call   18cef <pannic>
   10da2:	83 c4 10             	add    $0x10,%esp

    if (incr == 0) {
   10da5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10da9:	75 1b                	jne    10dc6 <sys_sbrk+0x60>
        log_printf("sbrk(0): end = 0x%x", pre_heap_end);
   10dab:	83 ec 08             	sub    $0x8,%esp
   10dae:	ff 75 ec             	pushl  -0x14(%ebp)
   10db1:	68 35 91 01 00       	push   $0x19135
   10db6:	e8 91 81 00 00       	call   18f4c <log_printf>
   10dbb:	83 c4 10             	add    $0x10,%esp
        return pre_heap_end;
   10dbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10dc1:	e9 aa 00 00 00       	jmp    10e70 <sys_sbrk+0x10a>
    } 
    
    uint32_t start = task->heap_end;
   10dc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10dc9:	8b 40 0c             	mov    0xc(%eax),%eax
   10dcc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t end = start + incr;
   10dcf:	8b 55 08             	mov    0x8(%ebp),%edx
   10dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10dd5:	01 d0                	add    %edx,%eax
   10dd7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    int start_offset = start % MEM_PAGE_SIZE;
   10dda:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10ddd:	25 ff 0f 00 00       	and    $0xfff,%eax
   10de2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if (start_offset) {
   10de5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10de9:	74 37                	je     10e22 <sys_sbrk+0xbc>

        if (start_offset + incr <= MEM_PAGE_SIZE) {
   10deb:	8b 55 e0             	mov    -0x20(%ebp),%edx
   10dee:	8b 45 08             	mov    0x8(%ebp),%eax
   10df1:	01 d0                	add    %edx,%eax
   10df3:	3d 00 10 00 00       	cmp    $0x1000,%eax
   10df8:	7f 0e                	jg     10e08 <sys_sbrk+0xa2>
            task->heap_end = end;
   10dfa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10dfd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10e00:	89 50 0c             	mov    %edx,0xc(%eax)
            return pre_heap_end;
   10e03:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e06:	eb 68                	jmp    10e70 <sys_sbrk+0x10a>
        } else {

            uint32_t curr_size = MEM_PAGE_SIZE - start_offset;
   10e08:	b8 00 10 00 00       	mov    $0x1000,%eax
   10e0d:	2b 45 e0             	sub    -0x20(%ebp),%eax
   10e10:	89 45 dc             	mov    %eax,-0x24(%ebp)
            start += curr_size;
   10e13:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e16:	01 45 f4             	add    %eax,-0xc(%ebp)
            incr -= curr_size;
   10e19:	8b 45 08             	mov    0x8(%ebp),%eax
   10e1c:	2b 45 dc             	sub    -0x24(%ebp),%eax
   10e1f:	89 45 08             	mov    %eax,0x8(%ebp)
        }
    }

    if (incr) {
   10e22:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   10e26:	74 3c                	je     10e64 <sys_sbrk+0xfe>
        uint32_t curr_size = end - start;
   10e28:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e2b:	2b 45 f4             	sub    -0xc(%ebp),%eax
   10e2e:	89 45 d8             	mov    %eax,-0x28(%ebp)
        int err = memory_alloc_for_page (start, curr_size, PTE_P | PTE_U | PTE_W);
   10e31:	83 ec 04             	sub    $0x4,%esp
   10e34:	6a 07                	push   $0x7
   10e36:	ff 75 d8             	pushl  -0x28(%ebp)
   10e39:	ff 75 f4             	pushl  -0xc(%ebp)
   10e3c:	e8 6f fa ff ff       	call   108b0 <memory_alloc_for_page>
   10e41:	83 c4 10             	add    $0x10,%esp
   10e44:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        if (err < 0) {
   10e47:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   10e4b:	79 17                	jns    10e64 <sys_sbrk+0xfe>
            log_printf("sbrk: alloc mem failed.");
   10e4d:	83 ec 0c             	sub    $0xc,%esp
   10e50:	68 49 91 01 00       	push   $0x19149
   10e55:	e8 f2 80 00 00       	call   18f4c <log_printf>
   10e5a:	83 c4 10             	add    $0x10,%esp
            return (char *)-1;
   10e5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10e62:	eb 0c                	jmp    10e70 <sys_sbrk+0x10a>
        }
    }

    // log_printf("sbrk(%d): end = 0x%x", pre_incr, end);
    task->heap_end = end;
   10e64:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e67:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   10e6a:	89 50 0c             	mov    %edx,0xc(%eax)
    return (char * )pre_heap_end;        
   10e6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
   10e70:	c9                   	leave  
   10e71:	c3                   	ret    

00010e72 <inb>:
static inline uint8_t inb(uint16_t  port) {
   10e72:	55                   	push   %ebp
   10e73:	89 e5                	mov    %esp,%ebp
   10e75:	83 ec 14             	sub    $0x14,%esp
   10e78:	8b 45 08             	mov    0x8(%ebp),%eax
   10e7b:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   10e7f:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   10e83:	89 c2                	mov    %eax,%edx
   10e85:	ec                   	in     (%dx),%al
   10e86:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   10e89:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   10e8d:	c9                   	leave  
   10e8e:	c3                   	ret    

00010e8f <inw>:
static inline uint16_t inw(uint16_t  port) {
   10e8f:	55                   	push   %ebp
   10e90:	89 e5                	mov    %esp,%ebp
   10e92:	83 ec 14             	sub    $0x14,%esp
   10e95:	8b 45 08             	mov    0x8(%ebp),%eax
   10e98:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   10e9c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   10ea0:	89 c2                	mov    %eax,%edx
   10ea2:	66 ed                	in     (%dx),%ax
   10ea4:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   10ea8:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   10eac:	c9                   	leave  
   10ead:	c3                   	ret    

00010eae <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   10eae:	55                   	push   %ebp
   10eaf:	89 e5                	mov    %esp,%ebp
   10eb1:	83 ec 08             	sub    $0x8,%esp
   10eb4:	8b 55 08             	mov    0x8(%ebp),%edx
   10eb7:	8b 45 0c             	mov    0xc(%ebp),%eax
   10eba:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   10ebe:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   10ec1:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   10ec5:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   10ec9:	ee                   	out    %al,(%dx)
}
   10eca:	90                   	nop
   10ecb:	c9                   	leave  
   10ecc:	c3                   	ret    

00010ecd <read_disk>:
        fat_t fat_data;
    };                 
}fs_t;


static void read_disk(int sector, int sector_count, uint8_t * buf) {
   10ecd:	55                   	push   %ebp
   10ece:	89 e5                	mov    %esp,%ebp
   10ed0:	53                   	push   %ebx
   10ed1:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   10ed4:	68 e0 00 00 00       	push   $0xe0
   10ed9:	68 f6 01 00 00       	push   $0x1f6
   10ede:	e8 cb ff ff ff       	call   10eae <outb>
   10ee3:	83 c4 08             	add    $0x8,%esp

	outb(0x1F2, (uint8_t) (sector_count >> 8));
   10ee6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ee9:	c1 f8 08             	sar    $0x8,%eax
   10eec:	0f b6 c0             	movzbl %al,%eax
   10eef:	50                   	push   %eax
   10ef0:	68 f2 01 00 00       	push   $0x1f2
   10ef5:	e8 b4 ff ff ff       	call   10eae <outb>
   10efa:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		// LBA参数的24~31位
   10efd:	8b 45 08             	mov    0x8(%ebp),%eax
   10f00:	c1 f8 18             	sar    $0x18,%eax
   10f03:	0f b6 c0             	movzbl %al,%eax
   10f06:	50                   	push   %eax
   10f07:	68 f3 01 00 00       	push   $0x1f3
   10f0c:	e8 9d ff ff ff       	call   10eae <outb>
   10f11:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					// LBA参数的32~39位
   10f14:	6a 00                	push   $0x0
   10f16:	68 f4 01 00 00       	push   $0x1f4
   10f1b:	e8 8e ff ff ff       	call   10eae <outb>
   10f20:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					// LBA参数的40~47位
   10f23:	6a 00                	push   $0x0
   10f25:	68 f5 01 00 00       	push   $0x1f5
   10f2a:	e8 7f ff ff ff       	call   10eae <outb>
   10f2f:	83 c4 08             	add    $0x8,%esp

    outb(0x1F2, (uint8_t) (sector_count));
   10f32:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f35:	0f b6 c0             	movzbl %al,%eax
   10f38:	50                   	push   %eax
   10f39:	68 f2 01 00 00       	push   $0x1f2
   10f3e:	e8 6b ff ff ff       	call   10eae <outb>
   10f43:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			// LBA参数的0~7位
   10f46:	8b 45 08             	mov    0x8(%ebp),%eax
   10f49:	0f b6 c0             	movzbl %al,%eax
   10f4c:	50                   	push   %eax
   10f4d:	68 f3 01 00 00       	push   $0x1f3
   10f52:	e8 57 ff ff ff       	call   10eae <outb>
   10f57:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		// LBA参数的8~15位
   10f5a:	8b 45 08             	mov    0x8(%ebp),%eax
   10f5d:	c1 f8 08             	sar    $0x8,%eax
   10f60:	0f b6 c0             	movzbl %al,%eax
   10f63:	50                   	push   %eax
   10f64:	68 f4 01 00 00       	push   $0x1f4
   10f69:	e8 40 ff ff ff       	call   10eae <outb>
   10f6e:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		// LBA参数的16~23位
   10f71:	8b 45 08             	mov    0x8(%ebp),%eax
   10f74:	c1 f8 10             	sar    $0x10,%eax
   10f77:	0f b6 c0             	movzbl %al,%eax
   10f7a:	50                   	push   %eax
   10f7b:	68 f5 01 00 00       	push   $0x1f5
   10f80:	e8 29 ff ff ff       	call   10eae <outb>
   10f85:	83 c4 08             	add    $0x8,%esp

	outb(0x1F7, (uint8_t) 0x24);
   10f88:	6a 24                	push   $0x24
   10f8a:	68 f7 01 00 00       	push   $0x1f7
   10f8f:	e8 1a ff ff ff       	call   10eae <outb>
   10f94:	83 c4 08             	add    $0x8,%esp

	// 读取数据
	uint16_t *data_buf = (uint16_t*) buf;
   10f97:	8b 45 10             	mov    0x10(%ebp),%eax
   10f9a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (sector_count-- > 0) {
   10f9d:	eb 4a                	jmp    10fe9 <read_disk+0x11c>
		// 每次扇区读之前都要检查，等待数据就绪
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   10f9f:	90                   	nop
   10fa0:	68 f7 01 00 00       	push   $0x1f7
   10fa5:	e8 c8 fe ff ff       	call   10e72 <inb>
   10faa:	83 c4 04             	add    $0x4,%esp
   10fad:	0f b6 c0             	movzbl %al,%eax
   10fb0:	25 88 00 00 00       	and    $0x88,%eax
   10fb5:	83 f8 08             	cmp    $0x8,%eax
   10fb8:	75 e6                	jne    10fa0 <read_disk+0xd3>

		// 读取并将数据写入到缓存中
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   10fba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10fc1:	eb 1d                	jmp    10fe0 <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   10fc3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   10fc6:	8d 43 02             	lea    0x2(%ebx),%eax
   10fc9:	89 45 f8             	mov    %eax,-0x8(%ebp)
   10fcc:	68 f0 01 00 00       	push   $0x1f0
   10fd1:	e8 b9 fe ff ff       	call   10e8f <inw>
   10fd6:	83 c4 04             	add    $0x4,%esp
   10fd9:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   10fdc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10fe0:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   10fe7:	7e da                	jle    10fc3 <read_disk+0xf6>
	while (sector_count-- > 0) {
   10fe9:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fec:	8d 50 ff             	lea    -0x1(%eax),%edx
   10fef:	89 55 0c             	mov    %edx,0xc(%ebp)
   10ff2:	85 c0                	test   %eax,%eax
   10ff4:	7f a9                	jg     10f9f <read_disk+0xd2>
		}
	}
}
   10ff6:	90                   	nop
   10ff7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10ffa:	c9                   	leave  
   10ffb:	c3                   	ret    

00010ffc <do_handler_syscall>:
    [SYS_READDIR]  =  (syscall_handler_t)sys_readdir,
    [SYS_CLOSEDIR] = (syscall_handler_t)sys_closedir,
    [SYS_PRINTMSG] = (syscall_handler_t)sys_print_msg,
};
void do_handler_syscall(syscall_frame_t* frame)
{
   10ffc:	55                   	push   %ebp
   10ffd:	89 e5                	mov    %esp,%ebp
   10fff:	53                   	push   %ebx
   11000:	83 ec 14             	sub    $0x14,%esp
    if(frame->id < sizeof(syscall_table) / sizeof(syscall_handler_t))
   11003:	8b 45 08             	mov    0x8(%ebp),%eax
   11006:	8b 40 3c             	mov    0x3c(%eax),%eax
   11009:	83 f8 64             	cmp    $0x64,%eax
   1100c:	77 48                	ja     11056 <do_handler_syscall+0x5a>
    {
        syscall_handler_t handler = syscall_table[frame->id];
   1100e:	8b 45 08             	mov    0x8(%ebp),%eax
   11011:	8b 40 3c             	mov    0x3c(%eax),%eax
   11014:	8b 04 85 c0 91 01 00 	mov    0x191c0(,%eax,4),%eax
   1101b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(handler)
   1101e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11022:	74 32                	je     11056 <do_handler_syscall+0x5a>
        {
            int ret = handler(frame->arg0, frame->arg1, frame->arg2, frame->arg3);
   11024:	8b 45 08             	mov    0x8(%ebp),%eax
   11027:	8b 58 4c             	mov    0x4c(%eax),%ebx
   1102a:	8b 45 08             	mov    0x8(%ebp),%eax
   1102d:	8b 48 48             	mov    0x48(%eax),%ecx
   11030:	8b 45 08             	mov    0x8(%ebp),%eax
   11033:	8b 50 44             	mov    0x44(%eax),%edx
   11036:	8b 45 08             	mov    0x8(%ebp),%eax
   11039:	8b 40 40             	mov    0x40(%eax),%eax
   1103c:	53                   	push   %ebx
   1103d:	51                   	push   %ecx
   1103e:	52                   	push   %edx
   1103f:	50                   	push   %eax
   11040:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11043:	ff d0                	call   *%eax
   11045:	83 c4 10             	add    $0x10,%esp
   11048:	89 45 f0             	mov    %eax,-0x10(%ebp)
            frame->eax = ret;
   1104b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1104e:	8b 45 08             	mov    0x8(%ebp),%eax
   11051:	89 50 30             	mov    %edx,0x30(%eax)
            return;
   11054:	eb 21                	jmp    11077 <do_handler_syscall+0x7b>
        }
            
    }
    task_t* task = task_manager.curr_task;
   11056:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   1105b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    log_printf("task is : %s", task->name);
   1105e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11061:	05 2c 02 00 00       	add    $0x22c,%eax
   11066:	83 ec 08             	sub    $0x8,%esp
   11069:	50                   	push   %eax
   1106a:	68 54 93 01 00       	push   $0x19354
   1106f:	e8 d8 7e 00 00       	call   18f4c <log_printf>
   11074:	83 c4 10             	add    $0x10,%esp
   11077:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1107a:	c9                   	leave  
   1107b:	c3                   	ret    

0001107c <inb>:
static inline uint8_t inb(uint16_t  port) {
   1107c:	55                   	push   %ebp
   1107d:	89 e5                	mov    %esp,%ebp
   1107f:	83 ec 14             	sub    $0x14,%esp
   11082:	8b 45 08             	mov    0x8(%ebp),%eax
   11085:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   11089:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1108d:	89 c2                	mov    %eax,%edx
   1108f:	ec                   	in     (%dx),%al
   11090:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   11093:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   11097:	c9                   	leave  
   11098:	c3                   	ret    

00011099 <inw>:
static inline uint16_t inw(uint16_t  port) {
   11099:	55                   	push   %ebp
   1109a:	89 e5                	mov    %esp,%ebp
   1109c:	83 ec 14             	sub    $0x14,%esp
   1109f:	8b 45 08             	mov    0x8(%ebp),%eax
   110a2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   110a6:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   110aa:	89 c2                	mov    %eax,%edx
   110ac:	66 ed                	in     (%dx),%ax
   110ae:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   110b2:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   110b6:	c9                   	leave  
   110b7:	c3                   	ret    

000110b8 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   110b8:	55                   	push   %ebp
   110b9:	89 e5                	mov    %esp,%ebp
   110bb:	83 ec 08             	sub    $0x8,%esp
   110be:	8b 55 08             	mov    0x8(%ebp),%edx
   110c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   110c4:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   110c8:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   110cb:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   110cf:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   110d3:	ee                   	out    %al,(%dx)
}
   110d4:	90                   	nop
   110d5:	c9                   	leave  
   110d6:	c3                   	ret    

000110d7 <write_cr3>:
static inline void write_cr3(uint32_t v) {
   110d7:	55                   	push   %ebp
   110d8:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3"::[v]"r"(v));
   110da:	8b 45 08             	mov    0x8(%ebp),%eax
   110dd:	0f 22 d8             	mov    %eax,%cr3
}
   110e0:	90                   	nop
   110e1:	5d                   	pop    %ebp
   110e2:	c3                   	ret    

000110e3 <far_jump>:

static inline void write_cr4(uint32_t v) {
    __asm__ __volatile__("mov %[v], %%cr4"::[v]"r"(v));
}

static inline void far_jump(uint32_t selector, uint32_t offset) {
   110e3:	55                   	push   %ebp
   110e4:	89 e5                	mov    %esp,%ebp
   110e6:	83 ec 10             	sub    $0x10,%esp
	uint32_t addr[] = {offset, selector };
   110e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   110ec:	89 45 f8             	mov    %eax,-0x8(%ebp)
   110ef:	8b 45 08             	mov    0x8(%ebp),%eax
   110f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm__ __volatile__("ljmpl *(%[a])"::[a]"r"(addr));
   110f5:	8d 45 f8             	lea    -0x8(%ebp),%eax
   110f8:	ff 28                	ljmp   *(%eax)
}
   110fa:	90                   	nop
   110fb:	c9                   	leave  
   110fc:	c3                   	ret    

000110fd <hlt>:

static inline void hlt() {
   110fd:	55                   	push   %ebp
   110fe:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("hlt");
   11100:	f4                   	hlt    
}
   11101:	90                   	nop
   11102:	5d                   	pop    %ebp
   11103:	c3                   	ret    

00011104 <ltr>:

static inline void ltr(uint16_t selector) {
   11104:	55                   	push   %ebp
   11105:	89 e5                	mov    %esp,%ebp
   11107:	83 ec 04             	sub    $0x4,%esp
   1110a:	8b 45 08             	mov    0x8(%ebp),%eax
   1110d:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	__asm__ __volatile__("ltr %%ax"::"a"(selector));
   11111:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   11115:	0f 00 d8             	ltr    %ax
}
   11118:	90                   	nop
   11119:	c9                   	leave  
   1111a:	c3                   	ret    

0001111b <list_node_init>:

/**
 * 头结点的初始化
 * @param node 待初始化的结果
 */
static inline void list_node_init(list_node_t *node) {
   1111b:	55                   	push   %ebp
   1111c:	89 e5                	mov    %esp,%ebp
    node->pre = node->next = (list_node_t *)0;
   1111e:	8b 45 08             	mov    0x8(%ebp),%eax
   11121:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11128:	8b 45 08             	mov    0x8(%ebp),%eax
   1112b:	8b 50 04             	mov    0x4(%eax),%edx
   1112e:	8b 45 08             	mov    0x8(%ebp),%eax
   11131:	89 10                	mov    %edx,(%eax)
}
   11133:	90                   	nop
   11134:	5d                   	pop    %ebp
   11135:	c3                   	ret    

00011136 <list_count>:
/**
 * 获取链表的结点数量
 * @param list 查询的链表
 * @return 结果的数据
 */
static inline int list_count(list_t *list) {
   11136:	55                   	push   %ebp
   11137:	89 e5                	mov    %esp,%ebp
    return list->count;
   11139:	8b 45 08             	mov    0x8(%ebp),%eax
   1113c:	8b 40 08             	mov    0x8(%eax),%eax
}
   1113f:	5d                   	pop    %ebp
   11140:	c3                   	ret    

00011141 <list_first>:
/**
 * 获取指定链表的第一个表项
 * @param list 查询的链表
 * @return 第一个表项
 */
static inline list_node_t* list_first(list_t *list) {
   11141:	55                   	push   %ebp
   11142:	89 e5                	mov    %esp,%ebp
    return list->first;
   11144:	8b 45 08             	mov    0x8(%ebp),%eax
   11147:	8b 00                	mov    (%eax),%eax
}
   11149:	5d                   	pop    %ebp
   1114a:	c3                   	ret    

0001114b <mmu_set_page_dir>:
{
   1114b:	55                   	push   %ebp
   1114c:	89 e5                	mov    %esp,%ebp
    write_cr3(page_dir);
   1114e:	ff 75 08             	pushl  0x8(%ebp)
   11151:	e8 81 ff ff ff       	call   110d7 <write_cr3>
   11156:	83 c4 04             	add    $0x4,%esp
}
   11159:	90                   	nop
   1115a:	c9                   	leave  
   1115b:	c3                   	ret    

0001115c <read_disk>:
static void read_disk(int sector, int sector_count, uint8_t * buf) {
   1115c:	55                   	push   %ebp
   1115d:	89 e5                	mov    %esp,%ebp
   1115f:	53                   	push   %ebx
   11160:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   11163:	68 e0 00 00 00       	push   $0xe0
   11168:	68 f6 01 00 00       	push   $0x1f6
   1116d:	e8 46 ff ff ff       	call   110b8 <outb>
   11172:	83 c4 08             	add    $0x8,%esp
	outb(0x1F2, (uint8_t) (sector_count >> 8));
   11175:	8b 45 0c             	mov    0xc(%ebp),%eax
   11178:	c1 f8 08             	sar    $0x8,%eax
   1117b:	0f b6 c0             	movzbl %al,%eax
   1117e:	50                   	push   %eax
   1117f:	68 f2 01 00 00       	push   $0x1f2
   11184:	e8 2f ff ff ff       	call   110b8 <outb>
   11189:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		// LBA参数的24~31位
   1118c:	8b 45 08             	mov    0x8(%ebp),%eax
   1118f:	c1 f8 18             	sar    $0x18,%eax
   11192:	0f b6 c0             	movzbl %al,%eax
   11195:	50                   	push   %eax
   11196:	68 f3 01 00 00       	push   $0x1f3
   1119b:	e8 18 ff ff ff       	call   110b8 <outb>
   111a0:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					// LBA参数的32~39位
   111a3:	6a 00                	push   $0x0
   111a5:	68 f4 01 00 00       	push   $0x1f4
   111aa:	e8 09 ff ff ff       	call   110b8 <outb>
   111af:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					// LBA参数的40~47位
   111b2:	6a 00                	push   $0x0
   111b4:	68 f5 01 00 00       	push   $0x1f5
   111b9:	e8 fa fe ff ff       	call   110b8 <outb>
   111be:	83 c4 08             	add    $0x8,%esp
    outb(0x1F2, (uint8_t) (sector_count));
   111c1:	8b 45 0c             	mov    0xc(%ebp),%eax
   111c4:	0f b6 c0             	movzbl %al,%eax
   111c7:	50                   	push   %eax
   111c8:	68 f2 01 00 00       	push   $0x1f2
   111cd:	e8 e6 fe ff ff       	call   110b8 <outb>
   111d2:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			// LBA参数的0~7位
   111d5:	8b 45 08             	mov    0x8(%ebp),%eax
   111d8:	0f b6 c0             	movzbl %al,%eax
   111db:	50                   	push   %eax
   111dc:	68 f3 01 00 00       	push   $0x1f3
   111e1:	e8 d2 fe ff ff       	call   110b8 <outb>
   111e6:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		// LBA参数的8~15位
   111e9:	8b 45 08             	mov    0x8(%ebp),%eax
   111ec:	c1 f8 08             	sar    $0x8,%eax
   111ef:	0f b6 c0             	movzbl %al,%eax
   111f2:	50                   	push   %eax
   111f3:	68 f4 01 00 00       	push   $0x1f4
   111f8:	e8 bb fe ff ff       	call   110b8 <outb>
   111fd:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		// LBA参数的16~23位
   11200:	8b 45 08             	mov    0x8(%ebp),%eax
   11203:	c1 f8 10             	sar    $0x10,%eax
   11206:	0f b6 c0             	movzbl %al,%eax
   11209:	50                   	push   %eax
   1120a:	68 f5 01 00 00       	push   $0x1f5
   1120f:	e8 a4 fe ff ff       	call   110b8 <outb>
   11214:	83 c4 08             	add    $0x8,%esp
	outb(0x1F7, (uint8_t) 0x24);
   11217:	6a 24                	push   $0x24
   11219:	68 f7 01 00 00       	push   $0x1f7
   1121e:	e8 95 fe ff ff       	call   110b8 <outb>
   11223:	83 c4 08             	add    $0x8,%esp
	uint16_t *data_buf = (uint16_t*) buf;
   11226:	8b 45 10             	mov    0x10(%ebp),%eax
   11229:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (sector_count-- > 0) {
   1122c:	eb 4a                	jmp    11278 <read_disk+0x11c>
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   1122e:	90                   	nop
   1122f:	68 f7 01 00 00       	push   $0x1f7
   11234:	e8 43 fe ff ff       	call   1107c <inb>
   11239:	83 c4 04             	add    $0x4,%esp
   1123c:	0f b6 c0             	movzbl %al,%eax
   1123f:	25 88 00 00 00       	and    $0x88,%eax
   11244:	83 f8 08             	cmp    $0x8,%eax
   11247:	75 e6                	jne    1122f <read_disk+0xd3>
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   11249:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11250:	eb 1d                	jmp    1126f <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   11252:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   11255:	8d 43 02             	lea    0x2(%ebx),%eax
   11258:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1125b:	68 f0 01 00 00       	push   $0x1f0
   11260:	e8 34 fe ff ff       	call   11099 <inw>
   11265:	83 c4 04             	add    $0x4,%esp
   11268:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   1126b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1126f:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   11276:	7e da                	jle    11252 <read_disk+0xf6>
	while (sector_count-- > 0) {
   11278:	8b 45 0c             	mov    0xc(%ebp),%eax
   1127b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1127e:	89 55 0c             	mov    %edx,0xc(%ebp)
   11281:	85 c0                	test   %eax,%eax
   11283:	7f a9                	jg     1122e <read_disk+0xd2>
}
   11285:	90                   	nop
   11286:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11289:	c9                   	leave  
   1128a:	c3                   	ret    

0001128b <task_file>:
#include "fs/fs.h"
static uint32_t* idle_stack[IDLE_STACK_SIZE];
static mutex_t task_table_mutex;
static task_t task_table[TASK_NUM];

file_t * task_file (int fd) {
   1128b:	55                   	push   %ebp
   1128c:	89 e5                	mov    %esp,%ebp
   1128e:	83 ec 10             	sub    $0x10,%esp
    if ((fd >= 0) && (fd < TASK_OFILE_NR)) {
   11291:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11295:	78 1d                	js     112b4 <task_file+0x29>
   11297:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   1129b:	7f 17                	jg     112b4 <task_file+0x29>
        file_t * file =  task_manager.curr_task->file_table[fd];
   1129d:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   112a2:	8b 55 08             	mov    0x8(%ebp),%edx
   112a5:	83 c2 08             	add    $0x8,%edx
   112a8:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   112ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
        return file;
   112af:	8b 45 fc             	mov    -0x4(%ebp),%eax
   112b2:	eb 05                	jmp    112b9 <task_file+0x2e>
    }

    return (file_t *)0;
   112b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
   112b9:	c9                   	leave  
   112ba:	c3                   	ret    

000112bb <task_alloc_fd>:


int task_alloc_fd (file_t * file) {
   112bb:	55                   	push   %ebp
   112bc:	89 e5                	mov    %esp,%ebp
   112be:	83 ec 10             	sub    $0x10,%esp
    task_t * task = task_manager.curr_task;
   112c1:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   112c6:	89 45 f8             	mov    %eax,-0x8(%ebp)

    for (int i = 0; i < TASK_OFILE_NR; i++) {
   112c9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   112d0:	eb 2f                	jmp    11301 <task_alloc_fd+0x46>
        file_t * p = task->file_table[i];
   112d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112d5:	8b 55 fc             	mov    -0x4(%ebp),%edx
   112d8:	83 c2 08             	add    $0x8,%edx
   112db:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   112df:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (p == (file_t *)0) {
   112e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   112e6:	75 15                	jne    112fd <task_alloc_fd+0x42>
            task->file_table[i] = file;
   112e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112eb:	8b 55 fc             	mov    -0x4(%ebp),%edx
   112ee:	8d 4a 08             	lea    0x8(%edx),%ecx
   112f1:	8b 55 08             	mov    0x8(%ebp),%edx
   112f4:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
            return i;
   112f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   112fb:	eb 0f                	jmp    1130c <task_alloc_fd+0x51>
    for (int i = 0; i < TASK_OFILE_NR; i++) {
   112fd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   11301:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
   11305:	7e cb                	jle    112d2 <task_alloc_fd+0x17>
        }
    }

    return -1;
   11307:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1130c:	c9                   	leave  
   1130d:	c3                   	ret    

0001130e <task_remove_fd>:


void task_remove_fd (int fd) {
   1130e:	55                   	push   %ebp
   1130f:	89 e5                	mov    %esp,%ebp
    if ((fd >= 0) && (fd < TASK_OFILE_NR)) {
   11311:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11315:	78 19                	js     11330 <task_remove_fd+0x22>
   11317:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   1131b:	7f 13                	jg     11330 <task_remove_fd+0x22>
         task_manager.curr_task->file_table[fd] = (file_t *)0;
   1131d:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   11322:	8b 55 08             	mov    0x8(%ebp),%edx
   11325:	83 c2 08             	add    $0x8,%edx
   11328:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
   1132f:	00 
    }
}
   11330:	90                   	nop
   11331:	5d                   	pop    %ebp
   11332:	c3                   	ret    

00011333 <tss_init>:
static int  tss_init(task_t* task, uint32_t entry, uint32_t esp, int flag)
{
   11333:	55                   	push   %ebp
   11334:	89 e5                	mov    %esp,%ebp
   11336:	83 ec 28             	sub    $0x28,%esp
    
    kernel_memset(&(task -> tss), 0, sizeof(tss_t));
   11339:	8b 45 08             	mov    0x8(%ebp),%eax
   1133c:	05 5c 02 00 00       	add    $0x25c,%eax
   11341:	83 ec 04             	sub    $0x4,%esp
   11344:	6a 68                	push   $0x68
   11346:	6a 00                	push   $0x0
   11348:	50                   	push   %eax
   11349:	e8 54 76 00 00       	call   189a2 <kernel_memset>
   1134e:	83 c4 10             	add    $0x10,%esp
    int selector = gdt_alloc_desc();
   11351:	e8 2a 15 00 00       	call   12880 <gdt_alloc_desc>
   11356:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (selector < 0) {
   11359:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1135d:	79 1a                	jns    11379 <tss_init+0x46>
        log_printf("alloc tss failed.\n");
   1135f:	83 ec 0c             	sub    $0xc,%esp
   11362:	68 64 93 01 00       	push   $0x19364
   11367:	e8 e0 7b 00 00       	call   18f4c <log_printf>
   1136c:	83 c4 10             	add    $0x10,%esp
        return -1;
   1136f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11374:	e9 6e 01 00 00       	jmp    114e7 <tss_init+0x1b4>
    }
    segment_desc_set(selector, (uint32_t)&task->tss, sizeof(tss_t), 
   11379:	8b 45 08             	mov    0x8(%ebp),%eax
   1137c:	05 5c 02 00 00       	add    $0x25c,%eax
   11381:	68 89 00 00 00       	push   $0x89
   11386:	6a 68                	push   $0x68
   11388:	50                   	push   %eax
   11389:	ff 75 ec             	pushl  -0x14(%ebp)
   1138c:	e8 80 13 00 00       	call   12711 <segment_desc_set>
   11391:	83 c4 10             	add    $0x10,%esp
    (SEG_P_PRESENT| SEG_DPL0 | SEG_TYPE_TSS));
    kernel_memset(&task->tss, 0, sizeof(tss_t));
   11394:	8b 45 08             	mov    0x8(%ebp),%eax
   11397:	05 5c 02 00 00       	add    $0x25c,%eax
   1139c:	83 ec 04             	sub    $0x4,%esp
   1139f:	6a 68                	push   $0x68
   113a1:	6a 00                	push   $0x0
   113a3:	50                   	push   %eax
   113a4:	e8 f9 75 00 00       	call   189a2 <kernel_memset>
   113a9:	83 c4 10             	add    $0x10,%esp
    uint32_t kernel_page = memory_alloc_page();
   113ac:	e8 d5 f5 ff ff       	call   10986 <memory_alloc_page>
   113b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(kernel_page == 0)
   113b4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   113b8:	0f 84 fe 00 00 00    	je     114bc <tss_init+0x189>
        goto tss_init_fault;
    int code_sel, data_sel;
    if(flag & TASK_SYSTEM_FLAG)
   113be:	8b 45 14             	mov    0x14(%ebp),%eax
   113c1:	83 e0 01             	and    $0x1,%eax
   113c4:	85 c0                	test   %eax,%eax
   113c6:	74 10                	je     113d8 <tss_init+0xa5>
    {
        code_sel = KERNEL_SELECTOR_CS;
   113c8:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
        data_sel = KERNEL_SELECTOR_DS;
   113cf:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
   113d6:	eb 16                	jmp    113ee <tss_init+0xbb>
    }
    else {
        code_sel = task_manager.app_code_sel | SEG_CPL3; //设置选择子的 RPL位
   113d8:	a1 f8 01 06 00       	mov    0x601f8,%eax
   113dd:	83 c8 03             	or     $0x3,%eax
   113e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
        data_sel = task_manager.app_data_sel | SEG_CPL3;
   113e3:	a1 fc 01 06 00       	mov    0x601fc,%eax
   113e8:	83 c8 03             	or     $0x3,%eax
   113eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    
    task -> tss.esp =  esp;
   113ee:	8b 45 08             	mov    0x8(%ebp),%eax
   113f1:	8b 55 10             	mov    0x10(%ebp),%edx
   113f4:	89 90 94 02 00 00    	mov    %edx,0x294(%eax)
    task -> tss.esp0 = kernel_page + MEM_PAGE_SIZE;
   113fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   113fd:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   11403:	8b 45 08             	mov    0x8(%ebp),%eax
   11406:	89 90 60 02 00 00    	mov    %edx,0x260(%eax)
    task -> tss.ds  = task -> tss.es = task -> tss.fs = task -> tss.gs = data_sel;
   1140c:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1140f:	8b 45 08             	mov    0x8(%ebp),%eax
   11412:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%eax)
   11418:	8b 45 08             	mov    0x8(%ebp),%eax
   1141b:	8b 90 b8 02 00 00    	mov    0x2b8(%eax),%edx
   11421:	8b 45 08             	mov    0x8(%ebp),%eax
   11424:	89 90 b4 02 00 00    	mov    %edx,0x2b4(%eax)
   1142a:	8b 45 08             	mov    0x8(%ebp),%eax
   1142d:	8b 90 b4 02 00 00    	mov    0x2b4(%eax),%edx
   11433:	8b 45 08             	mov    0x8(%ebp),%eax
   11436:	89 90 a4 02 00 00    	mov    %edx,0x2a4(%eax)
   1143c:	8b 45 08             	mov    0x8(%ebp),%eax
   1143f:	8b 90 a4 02 00 00    	mov    0x2a4(%eax),%edx
   11445:	8b 45 08             	mov    0x8(%ebp),%eax
   11448:	89 90 b0 02 00 00    	mov    %edx,0x2b0(%eax)
    task -> tss.eip = entry;
   1144e:	8b 45 08             	mov    0x8(%ebp),%eax
   11451:	8b 55 0c             	mov    0xc(%ebp),%edx
   11454:	89 90 7c 02 00 00    	mov    %edx,0x27c(%eax)
    task -> tss.eflags =  EFLAGS_DEFAULT | EFLAGS_IF;
   1145a:	8b 45 08             	mov    0x8(%ebp),%eax
   1145d:	c7 80 80 02 00 00 02 	movl   $0x202,0x280(%eax)
   11464:	02 00 00 
    task -> tss.ss =  data_sel;
   11467:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1146a:	8b 45 08             	mov    0x8(%ebp),%eax
   1146d:	89 90 ac 02 00 00    	mov    %edx,0x2ac(%eax)
    task -> tss.ss0 = KERNEL_SELECTOR_DS;
   11473:	8b 45 08             	mov    0x8(%ebp),%eax
   11476:	c7 80 64 02 00 00 10 	movl   $0x10,0x264(%eax)
   1147d:	00 00 00 
    task -> tss.cs = code_sel;
   11480:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11483:	8b 45 08             	mov    0x8(%ebp),%eax
   11486:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%eax)
    task -> tss_selector = selector;
   1148c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1148f:	89 c2                	mov    %eax,%edx
   11491:	8b 45 08             	mov    0x8(%ebp),%eax
   11494:	66 89 90 c4 02 00 00 	mov    %dx,0x2c4(%eax)
    uint32_t page_dir = memory_create_uvm();
   1149b:	e8 88 f3 ff ff       	call   10828 <memory_create_uvm>
   114a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(page_dir == 0)
   114a3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   114a7:	74 16                	je     114bf <tss_init+0x18c>
    {
        goto tss_init_fault;
    }
    task-> tss.cr3 = page_dir;
   114a9:	8b 45 08             	mov    0x8(%ebp),%eax
   114ac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   114af:	89 90 78 02 00 00    	mov    %edx,0x278(%eax)
    return 0;
   114b5:	b8 00 00 00 00       	mov    $0x0,%eax
   114ba:	eb 2b                	jmp    114e7 <tss_init+0x1b4>
        goto tss_init_fault;
   114bc:	90                   	nop
   114bd:	eb 01                	jmp    114c0 <tss_init+0x18d>
        goto tss_init_fault;
   114bf:	90                   	nop
tss_init_fault:
    gdt_free_tss(selector);
   114c0:	83 ec 0c             	sub    $0xc,%esp
   114c3:	ff 75 ec             	pushl  -0x14(%ebp)
   114c6:	e8 2a 14 00 00       	call   128f5 <gdt_free_tss>
   114cb:	83 c4 10             	add    $0x10,%esp
    if(kernel_page)
   114ce:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   114d2:	74 0e                	je     114e2 <tss_init+0x1af>
        memory_free_page(kernel_page);
   114d4:	83 ec 0c             	sub    $0xc,%esp
   114d7:	ff 75 e8             	pushl  -0x18(%ebp)
   114da:	e8 c1 f4 ff ff       	call   109a0 <memory_free_page>
   114df:	83 c4 10             	add    $0x10,%esp
    return -1;
   114e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    
}
   114e7:	c9                   	leave  
   114e8:	c3                   	ret    

000114e9 <task_init>:

int  task_init(task_t* task, const char* name, uint32_t entry, uint32_t esp, int flag)
{
   114e9:	55                   	push   %ebp
   114ea:	89 e5                	mov    %esp,%ebp
   114ec:	83 ec 18             	sub    $0x18,%esp
    int err = tss_init(task, entry, esp, flag);
   114ef:	ff 75 18             	pushl  0x18(%ebp)
   114f2:	ff 75 14             	pushl  0x14(%ebp)
   114f5:	ff 75 10             	pushl  0x10(%ebp)
   114f8:	ff 75 08             	pushl  0x8(%ebp)
   114fb:	e8 33 fe ff ff       	call   11333 <tss_init>
   11500:	83 c4 10             	add    $0x10,%esp
   11503:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (err < 0) {
   11506:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1150a:	79 18                	jns    11524 <task_init+0x3b>
        log_printf("init task failed.\n");
   1150c:	83 ec 0c             	sub    $0xc,%esp
   1150f:	68 77 93 01 00       	push   $0x19377
   11514:	e8 33 7a 00 00       	call   18f4c <log_printf>
   11519:	83 c4 10             	add    $0x10,%esp
        return err;
   1151c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1151f:	e9 ed 00 00 00       	jmp    11611 <task_init+0x128>
    }
    task->pid = (uint32_t) task;
   11524:	8b 55 08             	mov    0x8(%ebp),%edx
   11527:	8b 45 08             	mov    0x8(%ebp),%eax
   1152a:	89 50 04             	mov    %edx,0x4(%eax)
    task->heap_start = 0;
   1152d:	8b 45 08             	mov    0x8(%ebp),%eax
   11530:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    task->heap_end = 0;
   11537:	8b 45 08             	mov    0x8(%ebp),%eax
   1153a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    task->parent = (task_t*)0;
   11541:	8b 45 08             	mov    0x8(%ebp),%eax
   11544:	c7 80 28 02 00 00 00 	movl   $0x0,0x228(%eax)
   1154b:	00 00 00 
    task->sleep_ticks = 0;
   1154e:	8b 45 08             	mov    0x8(%ebp),%eax
   11551:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%eax)
   11558:	00 00 00 
    task->time_ticks = TASK_TIME_TICKS;
   1155b:	8b 45 08             	mov    0x8(%ebp),%eax
   1155e:	c7 80 54 02 00 00 0a 	movl   $0xa,0x254(%eax)
   11565:	00 00 00 
    task->slice_ticks = task->time_ticks;
   11568:	8b 45 08             	mov    0x8(%ebp),%eax
   1156b:	8b 90 54 02 00 00    	mov    0x254(%eax),%edx
   11571:	8b 45 08             	mov    0x8(%ebp),%eax
   11574:	89 90 50 02 00 00    	mov    %edx,0x250(%eax)
    task->status = 0;
   1157a:	8b 45 08             	mov    0x8(%ebp),%eax
   1157d:	c7 80 58 02 00 00 00 	movl   $0x0,0x258(%eax)
   11584:	00 00 00 
    kernel_strncpy(task->name, name, TASK_NAME_SIZE);
   11587:	8b 45 08             	mov    0x8(%ebp),%eax
   1158a:	05 2c 02 00 00       	add    $0x22c,%eax
   1158f:	83 ec 04             	sub    $0x4,%esp
   11592:	6a 20                	push   $0x20
   11594:	ff 75 0c             	pushl  0xc(%ebp)
   11597:	50                   	push   %eax
   11598:	e8 91 72 00 00       	call   1882e <kernel_strncpy>
   1159d:	83 c4 10             	add    $0x10,%esp
    task->state = CREATE;
   115a0:	8b 45 08             	mov    0x8(%ebp),%eax
   115a3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_node_init(&task->all_node);
   115a9:	8b 45 08             	mov    0x8(%ebp),%eax
   115ac:	83 c0 20             	add    $0x20,%eax
   115af:	83 ec 0c             	sub    $0xc,%esp
   115b2:	50                   	push   %eax
   115b3:	e8 63 fb ff ff       	call   1111b <list_node_init>
   115b8:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   115bb:	8b 45 08             	mov    0x8(%ebp),%eax
   115be:	83 c0 18             	add    $0x18,%eax
   115c1:	83 ec 0c             	sub    $0xc,%esp
   115c4:	50                   	push   %eax
   115c5:	e8 51 fb ff ff       	call   1111b <list_node_init>
   115ca:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   115cd:	8b 45 08             	mov    0x8(%ebp),%eax
   115d0:	83 c0 10             	add    $0x10,%eax
   115d3:	83 ec 0c             	sub    $0xc,%esp
   115d6:	50                   	push   %eax
   115d7:	e8 3f fb ff ff       	call   1111b <list_node_init>
   115dc:	83 c4 10             	add    $0x10,%esp
    irq_state_t state =  enter_protection();
   115df:	e8 42 1e 00 00       	call   13426 <enter_protection>
   115e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    // 插入就绪队列中和所有的任务队列中
    
    list_insert_last(&task_manager.task_list, &task->all_node);
   115e7:	8b 45 08             	mov    0x8(%ebp),%eax
   115ea:	83 c0 20             	add    $0x20,%eax
   115ed:	83 ec 08             	sub    $0x8,%esp
   115f0:	50                   	push   %eax
   115f1:	68 4c fc 05 00       	push   $0x5fc4c
   115f6:	e8 c1 77 00 00       	call   18dbc <list_insert_last>
   115fb:	83 c4 10             	add    $0x10,%esp
    leave_protection(state);
   115fe:	83 ec 0c             	sub    $0xc,%esp
   11601:	ff 75 f0             	pushl  -0x10(%ebp)
   11604:	e8 35 1e 00 00       	call   1343e <leave_protection>
   11609:	83 c4 10             	add    $0x10,%esp
    return 0;
   1160c:	b8 00 00 00 00       	mov    $0x0,%eax
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     *(--pesp) = 0;
    //     task->stack = pesp;
    // }
}
   11611:	c9                   	leave  
   11612:	c3                   	ret    

00011613 <task_start>:

void task_start(task_t* task)
{
   11613:	55                   	push   %ebp
   11614:	89 e5                	mov    %esp,%ebp
   11616:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state =  enter_protection();
   11619:	e8 08 1e 00 00       	call   13426 <enter_protection>
   1161e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    set_ready(task);
   11621:	83 ec 0c             	sub    $0xc,%esp
   11624:	ff 75 08             	pushl  0x8(%ebp)
   11627:	e8 b1 02 00 00       	call   118dd <set_ready>
   1162c:	83 c4 10             	add    $0x10,%esp
    leave_protection(state);
   1162f:	83 ec 0c             	sub    $0xc,%esp
   11632:	ff 75 f4             	pushl  -0xc(%ebp)
   11635:	e8 04 1e 00 00       	call   1343e <leave_protection>
   1163a:	83 c4 10             	add    $0x10,%esp
}
   1163d:	90                   	nop
   1163e:	c9                   	leave  
   1163f:	c3                   	ret    

00011640 <task_uninit>:
void task_uninit(task_t* task)
{
   11640:	55                   	push   %ebp
   11641:	89 e5                	mov    %esp,%ebp
   11643:	83 ec 08             	sub    $0x8,%esp
    if(task->tss.esp0)
   11646:	8b 45 08             	mov    0x8(%ebp),%eax
   11649:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
   1164f:	85 c0                	test   %eax,%eax
   11651:	74 1a                	je     1166d <task_uninit+0x2d>
        memory_free_page(task->tss.esp0 - MEM_PAGE_SIZE);
   11653:	8b 45 08             	mov    0x8(%ebp),%eax
   11656:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
   1165c:	2d 00 10 00 00       	sub    $0x1000,%eax
   11661:	83 ec 0c             	sub    $0xc,%esp
   11664:	50                   	push   %eax
   11665:	e8 36 f3 ff ff       	call   109a0 <memory_free_page>
   1166a:	83 c4 10             	add    $0x10,%esp
    if(task->tss_selector)
   1166d:	8b 45 08             	mov    0x8(%ebp),%eax
   11670:	0f b7 80 c4 02 00 00 	movzwl 0x2c4(%eax),%eax
   11677:	66 85 c0             	test   %ax,%ax
   1167a:	74 19                	je     11695 <task_uninit+0x55>
        gdt_free_tss(task->tss_selector);
   1167c:	8b 45 08             	mov    0x8(%ebp),%eax
   1167f:	0f b7 80 c4 02 00 00 	movzwl 0x2c4(%eax),%eax
   11686:	0f b7 c0             	movzwl %ax,%eax
   11689:	83 ec 0c             	sub    $0xc,%esp
   1168c:	50                   	push   %eax
   1168d:	e8 63 12 00 00       	call   128f5 <gdt_free_tss>
   11692:	83 c4 10             	add    $0x10,%esp
    if(task->tss.cr3)
   11695:	8b 45 08             	mov    0x8(%ebp),%eax
   11698:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
   1169e:	85 c0                	test   %eax,%eax
   116a0:	74 15                	je     116b7 <task_uninit+0x77>
        memory_destroy_uvm(task->tss.cr3);
   116a2:	8b 45 08             	mov    0x8(%ebp),%eax
   116a5:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
   116ab:	83 ec 0c             	sub    $0xc,%esp
   116ae:	50                   	push   %eax
   116af:	e8 ea f4 ff ff       	call   10b9e <memory_destroy_uvm>
   116b4:	83 c4 10             	add    $0x10,%esp
    kernel_memset((void*)task, 0, sizeof(task_t));
   116b7:	83 ec 04             	sub    $0x4,%esp
   116ba:	68 c8 02 00 00       	push   $0x2c8
   116bf:	6a 00                	push   $0x0
   116c1:	ff 75 08             	pushl  0x8(%ebp)
   116c4:	e8 d9 72 00 00       	call   189a2 <kernel_memset>
   116c9:	83 c4 10             	add    $0x10,%esp
    

}
   116cc:	90                   	nop
   116cd:	c9                   	leave  
   116ce:	c3                   	ret    

000116cf <task_switch_from_to>:

void task_switch_from_to(task_t* from, task_t* to){
   116cf:	55                   	push   %ebp
   116d0:	89 e5                	mov    %esp,%ebp
    // log_printf("task switch -----\r\n");
    far_jump(to->tss_selector, 0);
   116d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   116d5:	0f b7 80 c4 02 00 00 	movzwl 0x2c4(%eax),%eax
   116dc:	0f b7 c0             	movzwl %ax,%eax
   116df:	6a 00                	push   $0x0
   116e1:	50                   	push   %eax
   116e2:	e8 fc f9 ff ff       	call   110e3 <far_jump>
   116e7:	83 c4 08             	add    $0x8,%esp
    // simple_switch(&from->stack, to->stack);
}
   116ea:	90                   	nop
   116eb:	c9                   	leave  
   116ec:	c3                   	ret    

000116ed <idle_task_func>:

void idle_task_func(void){
   116ed:	55                   	push   %ebp
   116ee:	89 e5                	mov    %esp,%ebp
    for(;;){
        hlt();
   116f0:	e8 08 fa ff ff       	call   110fd <hlt>
   116f5:	eb f9                	jmp    116f0 <idle_task_func+0x3>

000116f7 <task_manager_init>:
    }
}
void task_manager_init(void)
{
   116f7:	55                   	push   %ebp
   116f8:	89 e5                	mov    %esp,%ebp
   116fa:	83 ec 18             	sub    $0x18,%esp
    kernel_memset((void*)task_table, 0, sizeof(task_table));
   116fd:	83 ec 04             	sub    $0x4,%esp
   11700:	68 00 64 01 00       	push   $0x16400
   11705:	6a 00                	push   $0x0
   11707:	68 20 f0 01 00       	push   $0x1f020
   1170c:	e8 91 72 00 00       	call   189a2 <kernel_memset>
   11711:	83 c4 10             	add    $0x10,%esp
    mutex_init(&task_table_mutex);
   11714:	83 ec 0c             	sub    $0xc,%esp
   11717:	68 00 f0 01 00       	push   $0x1f000
   1171c:	e8 35 6b 00 00       	call   18256 <mutex_init>
   11721:	83 c4 10             	add    $0x10,%esp
    uint32_t sel =  gdt_alloc_desc();
   11724:	e8 57 11 00 00       	call   12880 <gdt_alloc_desc>
   11729:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel, (uint32_t)0, 0xFFFFFFFF, 
   1172c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1172f:	68 fa 40 00 00       	push   $0x40fa
   11734:	6a ff                	push   $0xffffffff
   11736:	6a 00                	push   $0x0
   11738:	50                   	push   %eax
   11739:	e8 d3 0f 00 00       	call   12711 <segment_desc_set>
   1173e:	83 c4 10             	add    $0x10,%esp
    SEG_DPL3|SEG_P_PRESENT|SEG_S_NORMAL|SEG_TYPE_CODE|SEG_TYPE_RW|SEG_D);
    task_manager.app_code_sel = sel;
   11741:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11744:	a3 f8 01 06 00       	mov    %eax,0x601f8
    sel = gdt_alloc_desc();
   11749:	e8 32 11 00 00       	call   12880 <gdt_alloc_desc>
   1174e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(sel, (uint32_t)0, 0xFFFFFFFF, 
   11751:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11754:	68 f2 40 00 00       	push   $0x40f2
   11759:	6a ff                	push   $0xffffffff
   1175b:	6a 00                	push   $0x0
   1175d:	50                   	push   %eax
   1175e:	e8 ae 0f 00 00       	call   12711 <segment_desc_set>
   11763:	83 c4 10             	add    $0x10,%esp
    SEG_DPL3|SEG_P_PRESENT|SEG_S_NORMAL|SEG_TYPE_DATA|SEG_TYPE_RW|SEG_D);
    task_manager.app_data_sel = sel;
   11766:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11769:	a3 fc 01 06 00       	mov    %eax,0x601fc
    list_init(&(task_manager.ready_list));
   1176e:	83 ec 0c             	sub    $0xc,%esp
   11771:	68 40 fc 05 00       	push   $0x5fc40
   11776:	e8 bd 75 00 00       	call   18d38 <list_init>
   1177b:	83 c4 10             	add    $0x10,%esp
    list_init(&(task_manager.task_list));
   1177e:	83 ec 0c             	sub    $0xc,%esp
   11781:	68 4c fc 05 00       	push   $0x5fc4c
   11786:	e8 ad 75 00 00       	call   18d38 <list_init>
   1178b:	83 c4 10             	add    $0x10,%esp
    list_init(&task_manager.sleep_list);
   1178e:	83 ec 0c             	sub    $0xc,%esp
   11791:	68 58 fc 05 00       	push   $0x5fc58
   11796:	e8 9d 75 00 00       	call   18d38 <list_init>
   1179b:	83 c4 10             	add    $0x10,%esp
    task_manager.curr_task = (task_t*) 0;
   1179e:	c7 05 64 fc 05 00 00 	movl   $0x0,0x5fc64
   117a5:	00 00 00 
    task_init(&task_manager.idle_task, 
   117a8:	ba fc ef 01 00       	mov    $0x1effc,%edx
   117ad:	b8 ed 16 01 00       	mov    $0x116ed,%eax
   117b2:	83 ec 0c             	sub    $0xc,%esp
   117b5:	6a 01                	push   $0x1
   117b7:	52                   	push   %edx
   117b8:	50                   	push   %eax
   117b9:	68 8a 93 01 00       	push   $0x1938a
   117be:	68 30 ff 05 00       	push   $0x5ff30
   117c3:	e8 21 fd ff ff       	call   114e9 <task_init>
   117c8:	83 c4 20             	add    $0x20,%esp
    "idle_task", (uint32_t)idle_task_func, (uint32_t)&idle_stack[1023], TASK_SYSTEM_FLAG);
    task_start(&task_manager.idle_task);
   117cb:	83 ec 0c             	sub    $0xc,%esp
   117ce:	68 30 ff 05 00       	push   $0x5ff30
   117d3:	e8 3b fe ff ff       	call   11613 <task_start>
   117d8:	83 c4 10             	add    $0x10,%esp
}
   117db:	90                   	nop
   117dc:	c9                   	leave  
   117dd:	c3                   	ret    

000117de <first_task_init>:


void first_task_init(void)
{
   117de:	55                   	push   %ebp
   117df:	89 e5                	mov    %esp,%ebp
   117e1:	83 ec 18             	sub    $0x18,%esp
    extern void _first_task_entry(void);
    extern uint8_t s_first_task[], e_first_task[];
    uint32_t first_task = (uint32_t)_first_task_entry;
   117e4:	c7 45 f4 00 00 00 80 	movl   $0x80000000,-0xc(%ebp)
    uint32_t size = (uint32_t)(e_first_task - s_first_task);
   117eb:	ba e7 05 06 00       	mov    $0x605e7,%edx
   117f0:	b8 04 02 06 00       	mov    $0x60204,%eax
   117f5:	29 c2                	sub    %eax,%edx
   117f7:	89 d0                	mov    %edx,%eax
   117f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t alloc_size = 10 * MEM_PAGE_SIZE;
   117fc:	c7 45 ec 00 a0 00 00 	movl   $0xa000,-0x14(%ebp)
    Assert(alloc_size > size);
   11803:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11806:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   11809:	77 1c                	ja     11827 <first_task_init+0x49>
   1180b:	68 94 93 01 00       	push   $0x19394
   11810:	68 c8 94 01 00       	push   $0x194c8
   11815:	68 c1 00 00 00       	push   $0xc1
   1181a:	68 a8 93 01 00       	push   $0x193a8
   1181f:	e8 cb 74 00 00       	call   18cef <pannic>
   11824:	83 c4 10             	add    $0x10,%esp
    task_init(&task_manager.first_task, "init_main", first_task, first_task + alloc_size, 0);
   11827:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1182a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1182d:	01 d0                	add    %edx,%eax
   1182f:	83 ec 0c             	sub    $0xc,%esp
   11832:	6a 00                	push   $0x0
   11834:	50                   	push   %eax
   11835:	ff 75 f4             	pushl  -0xc(%ebp)
   11838:	68 f3 93 01 00       	push   $0x193f3
   1183d:	68 68 fc 05 00       	push   $0x5fc68
   11842:	e8 a2 fc ff ff       	call   114e9 <task_init>
   11847:	83 c4 20             	add    $0x20,%esp
    task_manager.first_task.heap_start = (uint32_t)e_first_task;
   1184a:	b8 e7 05 06 00       	mov    $0x605e7,%eax
   1184f:	a3 70 fc 05 00       	mov    %eax,0x5fc70
    task_manager.first_task.heap_end = (uint32_t)e_first_task;
   11854:	b8 e7 05 06 00       	mov    $0x605e7,%eax
   11859:	a3 74 fc 05 00       	mov    %eax,0x5fc74
    task_manager.curr_task = &task_manager.first_task;
   1185e:	c7 05 64 fc 05 00 68 	movl   $0x5fc68,0x5fc64
   11865:	fc 05 00 
    mmu_set_page_dir(task_manager.curr_task->tss.cr3);
   11868:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   1186d:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
   11873:	83 ec 0c             	sub    $0xc,%esp
   11876:	50                   	push   %eax
   11877:	e8 cf f8 ff ff       	call   1114b <mmu_set_page_dir>
   1187c:	83 c4 10             	add    $0x10,%esp
    memory_alloc_for_page(first_task, alloc_size, PTE_P|PTE_W|PTE_U);
   1187f:	83 ec 04             	sub    $0x4,%esp
   11882:	6a 07                	push   $0x7
   11884:	ff 75 ec             	pushl  -0x14(%ebp)
   11887:	ff 75 f4             	pushl  -0xc(%ebp)
   1188a:	e8 21 f0 ff ff       	call   108b0 <memory_alloc_for_page>
   1188f:	83 c4 10             	add    $0x10,%esp
    kernel_memcpy((void*)first_task, (void*)s_first_task, size);
   11892:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11895:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11898:	83 ec 04             	sub    $0x4,%esp
   1189b:	52                   	push   %edx
   1189c:	68 04 02 06 00       	push   $0x60204
   118a1:	50                   	push   %eax
   118a2:	e8 ac 70 00 00       	call   18953 <kernel_memcpy>
   118a7:	83 c4 10             	add    $0x10,%esp
    ltr(task_manager.first_task.tss_selector);
   118aa:	0f b7 05 2c ff 05 00 	movzwl 0x5ff2c,%eax
   118b1:	0f b7 c0             	movzwl %ax,%eax
   118b4:	83 ec 0c             	sub    $0xc,%esp
   118b7:	50                   	push   %eax
   118b8:	e8 47 f8 ff ff       	call   11104 <ltr>
   118bd:	83 c4 10             	add    $0x10,%esp
    task_start(&task_manager.first_task);
   118c0:	83 ec 0c             	sub    $0xc,%esp
   118c3:	68 68 fc 05 00       	push   $0x5fc68
   118c8:	e8 46 fd ff ff       	call   11613 <task_start>
   118cd:	83 c4 10             	add    $0x10,%esp
}
   118d0:	90                   	nop
   118d1:	c9                   	leave  
   118d2:	c3                   	ret    

000118d3 <task_first_task>:

task_t* task_first_task(void)
{
   118d3:	55                   	push   %ebp
   118d4:	89 e5                	mov    %esp,%ebp
    return &task_manager.first_task;
   118d6:	b8 68 fc 05 00       	mov    $0x5fc68,%eax
}
   118db:	5d                   	pop    %ebp
   118dc:	c3                   	ret    

000118dd <set_ready>:

void set_ready(task_t* task){
   118dd:	55                   	push   %ebp
   118de:	89 e5                	mov    %esp,%ebp
   118e0:	83 ec 08             	sub    $0x8,%esp
    if(task == &task_manager.idle_task)
   118e3:	81 7d 08 30 ff 05 00 	cmpl   $0x5ff30,0x8(%ebp)
   118ea:	74 22                	je     1190e <set_ready+0x31>
        return;
    list_insert_last(&task_manager.ready_list, &task->run_node);
   118ec:	8b 45 08             	mov    0x8(%ebp),%eax
   118ef:	83 c0 10             	add    $0x10,%eax
   118f2:	83 ec 08             	sub    $0x8,%esp
   118f5:	50                   	push   %eax
   118f6:	68 40 fc 05 00       	push   $0x5fc40
   118fb:	e8 bc 74 00 00       	call   18dbc <list_insert_last>
   11900:	83 c4 10             	add    $0x10,%esp
    task->state = READY;
   11903:	8b 45 08             	mov    0x8(%ebp),%eax
   11906:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1190c:	eb 01                	jmp    1190f <set_ready+0x32>
        return;
   1190e:	90                   	nop
}
   1190f:	c9                   	leave  
   11910:	c3                   	ret    

00011911 <set_block>:

void set_block(task_t* task)
{
   11911:	55                   	push   %ebp
   11912:	89 e5                	mov    %esp,%ebp
   11914:	83 ec 08             	sub    $0x8,%esp
    if(task == &task_manager.idle_task)
   11917:	81 7d 08 30 ff 05 00 	cmpl   $0x5ff30,0x8(%ebp)
   1191e:	74 19                	je     11939 <set_block+0x28>
        return;
    list_remove(&task_manager.ready_list, &task->run_node);
   11920:	8b 45 08             	mov    0x8(%ebp),%eax
   11923:	83 c0 10             	add    $0x10,%eax
   11926:	83 ec 08             	sub    $0x8,%esp
   11929:	50                   	push   %eax
   1192a:	68 40 fc 05 00       	push   $0x5fc40
   1192f:	e8 64 75 00 00       	call   18e98 <list_remove>
   11934:	83 c4 10             	add    $0x10,%esp
   11937:	eb 01                	jmp    1193a <set_block+0x29>
        return;
   11939:	90                   	nop
}
   1193a:	c9                   	leave  
   1193b:	c3                   	ret    

0001193c <sys_shed_yield>:
/**
 * @brief 当前任务主动放弃CPU
 */
void sys_shed_yield(void)
{
   1193c:	55                   	push   %ebp
   1193d:	89 e5                	mov    %esp,%ebp
   1193f:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state =  enter_protection();
   11942:	e8 df 1a 00 00       	call   13426 <enter_protection>
   11947:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(list_count(&task_manager.ready_list) > 1){
   1194a:	83 ec 0c             	sub    $0xc,%esp
   1194d:	68 40 fc 05 00       	push   $0x5fc40
   11952:	e8 df f7 ff ff       	call   11136 <list_count>
   11957:	83 c4 10             	add    $0x10,%esp
   1195a:	83 f8 01             	cmp    $0x1,%eax
   1195d:	7e 29                	jle    11988 <sys_shed_yield+0x4c>
        task_t * curr = current_task();
   1195f:	e8 bc 00 00 00       	call   11a20 <current_task>
   11964:	89 45 f0             	mov    %eax,-0x10(%ebp)
        // 如果队列中还有其它任务，则将当前任务移入到队列尾部
        set_block(curr);
   11967:	83 ec 0c             	sub    $0xc,%esp
   1196a:	ff 75 f0             	pushl  -0x10(%ebp)
   1196d:	e8 9f ff ff ff       	call   11911 <set_block>
   11972:	83 c4 10             	add    $0x10,%esp
        set_ready(curr);
   11975:	83 ec 0c             	sub    $0xc,%esp
   11978:	ff 75 f0             	pushl  -0x10(%ebp)
   1197b:	e8 5d ff ff ff       	call   118dd <set_ready>
   11980:	83 c4 10             	add    $0x10,%esp
        // 切换至下一个任务，在切换完成前要保护，不然可能下一任务
        // 由于某些原因运行后阻塞或删除，再回到这里切换将发生问题
        task_dispatch();
   11983:	e8 56 00 00 00       	call   119de <task_dispatch>
        
    }
    leave_protection(state);
   11988:	83 ec 0c             	sub    $0xc,%esp
   1198b:	ff 75 f4             	pushl  -0xc(%ebp)
   1198e:	e8 ab 1a 00 00       	call   1343e <leave_protection>
   11993:	83 c4 10             	add    $0x10,%esp

    
}
   11996:	90                   	nop
   11997:	c9                   	leave  
   11998:	c3                   	ret    

00011999 <task_next_run>:
task_t* task_next_run(void){
   11999:	55                   	push   %ebp
   1199a:	89 e5                	mov    %esp,%ebp
    if(list_count(&task_manager.ready_list) == 0)
   1199c:	68 40 fc 05 00       	push   $0x5fc40
   119a1:	e8 90 f7 ff ff       	call   11136 <list_count>
   119a6:	83 c4 04             	add    $0x4,%esp
   119a9:	85 c0                	test   %eax,%eax
   119ab:	75 07                	jne    119b4 <task_next_run+0x1b>
        return &task_manager.idle_task;
   119ad:	b8 30 ff 05 00       	mov    $0x5ff30,%eax
   119b2:	eb 28                	jmp    119dc <task_next_run+0x43>

    return LIST_NODE_PARENT(list_first(&task_manager.ready_list), task_t, run_node);
   119b4:	68 40 fc 05 00       	push   $0x5fc40
   119b9:	e8 83 f7 ff ff       	call   11141 <list_first>
   119be:	83 c4 04             	add    $0x4,%esp
   119c1:	85 c0                	test   %eax,%eax
   119c3:	74 12                	je     119d7 <task_next_run+0x3e>
   119c5:	68 40 fc 05 00       	push   $0x5fc40
   119ca:	e8 72 f7 ff ff       	call   11141 <list_first>
   119cf:	83 c4 04             	add    $0x4,%esp
   119d2:	83 e8 10             	sub    $0x10,%eax
   119d5:	eb 05                	jmp    119dc <task_next_run+0x43>
   119d7:	b8 00 00 00 00       	mov    $0x0,%eax
}
   119dc:	c9                   	leave  
   119dd:	c3                   	ret    

000119de <task_dispatch>:
void task_dispatch(void){
   119de:	55                   	push   %ebp
   119df:	89 e5                	mov    %esp,%ebp
   119e1:	83 ec 10             	sub    $0x10,%esp
    // irq_state_t state =  enter_protection();
    task_t* to = task_next_run();
   119e4:	e8 b0 ff ff ff       	call   11999 <task_next_run>
   119e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(to != task_manager.curr_task){
   119ec:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   119f1:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   119f4:	74 27                	je     11a1d <task_dispatch+0x3f>
        task_t * from = task_manager.curr_task;
   119f6:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   119fb:	89 45 f8             	mov    %eax,-0x8(%ebp)
        task_manager.curr_task = to;
   119fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11a01:	a3 64 fc 05 00       	mov    %eax,0x5fc64
        to -> state = RUNNING;
   11a06:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11a09:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        // leave_protection(state);
        task_switch_from_to(from, to);
   11a0f:	ff 75 fc             	pushl  -0x4(%ebp)
   11a12:	ff 75 f8             	pushl  -0x8(%ebp)
   11a15:	e8 b5 fc ff ff       	call   116cf <task_switch_from_to>
   11a1a:	83 c4 08             	add    $0x8,%esp
        
    }
    // leave_protection(state);
}
   11a1d:	90                   	nop
   11a1e:	c9                   	leave  
   11a1f:	c3                   	ret    

00011a20 <current_task>:
task_t * current_task(void){
   11a20:	55                   	push   %ebp
   11a21:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task;
   11a23:	a1 64 fc 05 00       	mov    0x5fc64,%eax
}
   11a28:	5d                   	pop    %ebp
   11a29:	c3                   	ret    

00011a2a <task_time_tick>:

void task_time_tick(void)
{
   11a2a:	55                   	push   %ebp
   11a2b:	89 e5                	mov    %esp,%ebp
   11a2d:	83 ec 28             	sub    $0x28,%esp
    
    task_t* curr_task = current_task();
   11a30:	e8 eb ff ff ff       	call   11a20 <current_task>
   11a35:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_state_t state =  enter_protection();
   11a38:	e8 e9 19 00 00       	call   13426 <enter_protection>
   11a3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(--curr_task->slice_ticks == 0){
   11a40:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a43:	8b 80 50 02 00 00    	mov    0x250(%eax),%eax
   11a49:	8d 50 ff             	lea    -0x1(%eax),%edx
   11a4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a4f:	89 90 50 02 00 00    	mov    %edx,0x250(%eax)
   11a55:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a58:	8b 80 50 02 00 00    	mov    0x250(%eax),%eax
   11a5e:	85 c0                	test   %eax,%eax
   11a60:	75 2e                	jne    11a90 <task_time_tick+0x66>
        curr_task->slice_ticks = curr_task->time_ticks;
   11a62:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a65:	8b 90 54 02 00 00    	mov    0x254(%eax),%edx
   11a6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a6e:	89 90 50 02 00 00    	mov    %edx,0x250(%eax)
        // 调整队列的位置到尾部，不用直接操作队列
        set_block(curr_task);
   11a74:	83 ec 0c             	sub    $0xc,%esp
   11a77:	ff 75 f0             	pushl  -0x10(%ebp)
   11a7a:	e8 92 fe ff ff       	call   11911 <set_block>
   11a7f:	83 c4 10             	add    $0x10,%esp
        set_ready(curr_task);
   11a82:	83 ec 0c             	sub    $0xc,%esp
   11a85:	ff 75 f0             	pushl  -0x10(%ebp)
   11a88:	e8 50 fe ff ff       	call   118dd <set_ready>
   11a8d:	83 c4 10             	add    $0x10,%esp
    }

    
    list_node_t* curr = list_first(&task_manager.sleep_list);
   11a90:	83 ec 0c             	sub    $0xc,%esp
   11a93:	68 58 fc 05 00       	push   $0x5fc58
   11a98:	e8 a4 f6 ff ff       	call   11141 <list_first>
   11a9d:	83 c4 10             	add    $0x10,%esp
   11aa0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   11aa3:	eb 63                	jmp    11b08 <task_time_tick+0xde>
        list_node_t* next = curr->next;
   11aa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11aa8:	8b 40 04             	mov    0x4(%eax),%eax
   11aab:	89 45 e8             	mov    %eax,-0x18(%ebp)
        task_t* temp =  LIST_NODE_PARENT(curr, task_t, run_node);
   11aae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11ab2:	74 08                	je     11abc <task_time_tick+0x92>
   11ab4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ab7:	83 e8 10             	sub    $0x10,%eax
   11aba:	eb 05                	jmp    11ac1 <task_time_tick+0x97>
   11abc:	b8 00 00 00 00       	mov    $0x0,%eax
   11ac1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if((--temp->sleep_ticks == 0))
   11ac4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ac7:	8b 80 4c 02 00 00    	mov    0x24c(%eax),%eax
   11acd:	8d 50 ff             	lea    -0x1(%eax),%edx
   11ad0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ad3:	89 90 4c 02 00 00    	mov    %edx,0x24c(%eax)
   11ad9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11adc:	8b 80 4c 02 00 00    	mov    0x24c(%eax),%eax
   11ae2:	85 c0                	test   %eax,%eax
   11ae4:	75 1c                	jne    11b02 <task_time_tick+0xd8>
        {
            set_wake(temp);
   11ae6:	83 ec 0c             	sub    $0xc,%esp
   11ae9:	ff 75 e4             	pushl  -0x1c(%ebp)
   11aec:	e8 70 00 00 00       	call   11b61 <set_wake>
   11af1:	83 c4 10             	add    $0x10,%esp
            set_ready(temp);
   11af4:	83 ec 0c             	sub    $0xc,%esp
   11af7:	ff 75 e4             	pushl  -0x1c(%ebp)
   11afa:	e8 de fd ff ff       	call   118dd <set_ready>
   11aff:	83 c4 10             	add    $0x10,%esp
        }
        curr = next;
   11b02:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11b05:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(curr){
   11b08:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11b0c:	75 97                	jne    11aa5 <task_time_tick+0x7b>
    }
    leave_protection(state);
   11b0e:	83 ec 0c             	sub    $0xc,%esp
   11b11:	ff 75 ec             	pushl  -0x14(%ebp)
   11b14:	e8 25 19 00 00       	call   1343e <leave_protection>
   11b19:	83 c4 10             	add    $0x10,%esp
    task_dispatch();
   11b1c:	e8 bd fe ff ff       	call   119de <task_dispatch>
}
   11b21:	90                   	nop
   11b22:	c9                   	leave  
   11b23:	c3                   	ret    

00011b24 <set_sleep>:

void set_sleep(task_t* task, int ticks)
{
   11b24:	55                   	push   %ebp
   11b25:	89 e5                	mov    %esp,%ebp
   11b27:	83 ec 08             	sub    $0x8,%esp
    if(ticks == 0)
   11b2a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11b2e:	74 2e                	je     11b5e <set_sleep+0x3a>
        return;
    task->state = SLEEPING;
   11b30:	8b 45 08             	mov    0x8(%ebp),%eax
   11b33:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    task->sleep_ticks = ticks;
   11b39:	8b 45 08             	mov    0x8(%ebp),%eax
   11b3c:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b3f:	89 90 4c 02 00 00    	mov    %edx,0x24c(%eax)
    list_insert_last(&task_manager.sleep_list, &task->run_node);
   11b45:	8b 45 08             	mov    0x8(%ebp),%eax
   11b48:	83 c0 10             	add    $0x10,%eax
   11b4b:	83 ec 08             	sub    $0x8,%esp
   11b4e:	50                   	push   %eax
   11b4f:	68 58 fc 05 00       	push   $0x5fc58
   11b54:	e8 63 72 00 00       	call   18dbc <list_insert_last>
   11b59:	83 c4 10             	add    $0x10,%esp
   11b5c:	eb 01                	jmp    11b5f <set_sleep+0x3b>
        return;
   11b5e:	90                   	nop
    
}
   11b5f:	c9                   	leave  
   11b60:	c3                   	ret    

00011b61 <set_wake>:
void set_wake(task_t* task)
{
   11b61:	55                   	push   %ebp
   11b62:	89 e5                	mov    %esp,%ebp
   11b64:	83 ec 08             	sub    $0x8,%esp
    list_remove(&task_manager.sleep_list, &task->run_node);
   11b67:	8b 45 08             	mov    0x8(%ebp),%eax
   11b6a:	83 c0 10             	add    $0x10,%eax
   11b6d:	83 ec 08             	sub    $0x8,%esp
   11b70:	50                   	push   %eax
   11b71:	68 58 fc 05 00       	push   $0x5fc58
   11b76:	e8 1d 73 00 00       	call   18e98 <list_remove>
   11b7b:	83 c4 10             	add    $0x10,%esp
}
   11b7e:	90                   	nop
   11b7f:	c9                   	leave  
   11b80:	c3                   	ret    

00011b81 <sys_sleep>:
void sys_sleep(uint32_t ms)
{
   11b81:	55                   	push   %ebp
   11b82:	89 e5                	mov    %esp,%ebp
   11b84:	83 ec 18             	sub    $0x18,%esp
    uint32_t state =  enter_protection();
   11b87:	e8 9a 18 00 00       	call   13426 <enter_protection>
   11b8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    set_block(task_manager.curr_task);
   11b8f:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   11b94:	83 ec 0c             	sub    $0xc,%esp
   11b97:	50                   	push   %eax
   11b98:	e8 74 fd ff ff       	call   11911 <set_block>
   11b9d:	83 c4 10             	add    $0x10,%esp
    set_sleep(task_manager.curr_task, (ms + TASK_TIME_TICKS - 1)/ TASK_TIME_TICKS);
   11ba0:	8b 45 08             	mov    0x8(%ebp),%eax
   11ba3:	83 c0 09             	add    $0x9,%eax
   11ba6:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   11bab:	f7 e2                	mul    %edx
   11bad:	89 d0                	mov    %edx,%eax
   11baf:	c1 e8 03             	shr    $0x3,%eax
   11bb2:	89 c2                	mov    %eax,%edx
   11bb4:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   11bb9:	83 ec 08             	sub    $0x8,%esp
   11bbc:	52                   	push   %edx
   11bbd:	50                   	push   %eax
   11bbe:	e8 61 ff ff ff       	call   11b24 <set_sleep>
   11bc3:	83 c4 10             	add    $0x10,%esp
    
    task_dispatch();
   11bc6:	e8 13 fe ff ff       	call   119de <task_dispatch>
    leave_protection(state);
   11bcb:	83 ec 0c             	sub    $0xc,%esp
   11bce:	ff 75 f4             	pushl  -0xc(%ebp)
   11bd1:	e8 68 18 00 00       	call   1343e <leave_protection>
   11bd6:	83 c4 10             	add    $0x10,%esp
    
}
   11bd9:	90                   	nop
   11bda:	c9                   	leave  
   11bdb:	c3                   	ret    

00011bdc <sys_getpid>:

uint32_t sys_getpid(void)
{
   11bdc:	55                   	push   %ebp
   11bdd:	89 e5                	mov    %esp,%ebp
    return task_manager.curr_task->pid;
   11bdf:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   11be4:	8b 40 04             	mov    0x4(%eax),%eax
}
   11be7:	5d                   	pop    %ebp
   11be8:	c3                   	ret    

00011be9 <sys_print_msg>:

int sys_print_msg (char * fmt, int arg) {
   11be9:	55                   	push   %ebp
   11bea:	89 e5                	mov    %esp,%ebp
   11bec:	83 ec 08             	sub    $0x8,%esp
	log_printf(fmt, arg);
   11bef:	83 ec 08             	sub    $0x8,%esp
   11bf2:	ff 75 0c             	pushl  0xc(%ebp)
   11bf5:	ff 75 08             	pushl  0x8(%ebp)
   11bf8:	e8 4f 73 00 00       	call   18f4c <log_printf>
   11bfd:	83 c4 10             	add    $0x10,%esp
}
   11c00:	90                   	nop
   11c01:	c9                   	leave  
   11c02:	c3                   	ret    

00011c03 <copy_open_files>:

void copy_open_files(task_t* child)
{
   11c03:	55                   	push   %ebp
   11c04:	89 e5                	mov    %esp,%ebp
   11c06:	83 ec 18             	sub    $0x18,%esp
    task_t* task = task_manager.curr_task;
   11c09:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   11c0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mutex_lock(&task_table_mutex);
   11c11:	83 ec 0c             	sub    $0xc,%esp
   11c14:	68 00 f0 01 00       	push   $0x1f000
   11c19:	e8 66 66 00 00       	call   18284 <mutex_lock>
   11c1e:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < TASK_OFILE_NR; ++i)
   11c21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11c28:	eb 38                	jmp    11c62 <copy_open_files+0x5f>
    {   file_t * file = task->file_table[i];
   11c2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11c30:	83 c2 08             	add    $0x8,%edx
   11c33:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   11c37:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(file)
   11c3a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11c3e:	74 1e                	je     11c5e <copy_open_files+0x5b>
        {
            child->file_table[i] = file;
   11c40:	8b 45 08             	mov    0x8(%ebp),%eax
   11c43:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11c46:	8d 4a 08             	lea    0x8(%edx),%ecx
   11c49:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11c4c:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
            ref_inc(file);
   11c50:	83 ec 0c             	sub    $0xc,%esp
   11c53:	ff 75 ec             	pushl  -0x14(%ebp)
   11c56:	e8 28 55 00 00       	call   17183 <ref_inc>
   11c5b:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < TASK_OFILE_NR; ++i)
   11c5e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11c62:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   11c66:	7e c2                	jle    11c2a <copy_open_files+0x27>
        }
    }
    mutex_unlock(&task_table_mutex);
   11c68:	83 ec 0c             	sub    $0xc,%esp
   11c6b:	68 00 f0 01 00       	push   $0x1f000
   11c70:	e8 a5 66 00 00       	call   1831a <mutex_unlock>
   11c75:	83 c4 10             	add    $0x10,%esp
}
   11c78:	90                   	nop
   11c79:	c9                   	leave  
   11c7a:	c3                   	ret    

00011c7b <sys_fork>:

int sys_fork (void) {
   11c7b:	55                   	push   %ebp
   11c7c:	89 e5                	mov    %esp,%ebp
   11c7e:	83 ec 28             	sub    $0x28,%esp
    task_t * parent_task = task_manager.curr_task;
   11c81:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   11c86:	89 45 f4             	mov    %eax,-0xc(%ebp)

    // 分配任务结构
    task_t * child_task = alloc_task();
   11c89:	e8 7e 04 00 00       	call   1210c <alloc_task>
   11c8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (child_task == (task_t *)0) {
   11c91:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11c95:	0f 84 3b 01 00 00    	je     11dd6 <sys_fork+0x15b>
        goto fork_failed;
    }

    syscall_frame_t * frame = (syscall_frame_t *)(parent_task->tss.esp0 - sizeof(syscall_frame_t));
   11c9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11c9e:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
   11ca4:	83 e8 58             	sub    $0x58,%eax
   11ca7:	89 45 ec             	mov    %eax,-0x14(%ebp)

    // 对子进程进行初始化，并对必要的字段进行调整
    // 其中esp要减去系统调用的总参数字节大小，因为其是通过正常的ret返回, 而没有走系统调用处理的ret(参数个数返回)
    int err = task_init(child_task,  parent_task->name, frame->eip,
                        frame->esp + sizeof(uint32_t)*SYSCALL_PARAM, 0);
   11caa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11cad:	8b 40 50             	mov    0x50(%eax),%eax
    int err = task_init(child_task,  parent_task->name, frame->eip,
   11cb0:	8d 48 14             	lea    0x14(%eax),%ecx
   11cb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11cb6:	8b 40 34             	mov    0x34(%eax),%eax
   11cb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11cbc:	81 c2 2c 02 00 00    	add    $0x22c,%edx
   11cc2:	83 ec 0c             	sub    $0xc,%esp
   11cc5:	6a 00                	push   $0x0
   11cc7:	51                   	push   %ecx
   11cc8:	50                   	push   %eax
   11cc9:	52                   	push   %edx
   11cca:	ff 75 f0             	pushl  -0x10(%ebp)
   11ccd:	e8 17 f8 ff ff       	call   114e9 <task_init>
   11cd2:	83 c4 20             	add    $0x20,%esp
   11cd5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (err < 0) {
   11cd8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11cdc:	0f 88 f7 00 00 00    	js     11dd9 <sys_fork+0x15e>
        goto fork_failed;
    }
    copy_open_files(child_task);
   11ce2:	83 ec 0c             	sub    $0xc,%esp
   11ce5:	ff 75 f0             	pushl  -0x10(%ebp)
   11ce8:	e8 16 ff ff ff       	call   11c03 <copy_open_files>
   11ced:	83 c4 10             	add    $0x10,%esp
    // 从父进程的栈中取部分状态，然后写入tss。
    // 注意检查esp, eip等是否在用户空间范围内，不然会造成page_fault
    tss_t * tss = &child_task->tss;
   11cf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11cf3:	05 5c 02 00 00       	add    $0x25c,%eax
   11cf8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tss->eax = 0;                       // 子进程返回0
   11cfb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11cfe:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    tss->ebx = frame->ebx;
   11d05:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d08:	8b 50 24             	mov    0x24(%eax),%edx
   11d0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d0e:	89 50 34             	mov    %edx,0x34(%eax)
    tss->ecx = frame->ecx;
   11d11:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d14:	8b 50 2c             	mov    0x2c(%eax),%edx
   11d17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d1a:	89 50 2c             	mov    %edx,0x2c(%eax)
    tss->edx = frame->edx;
   11d1d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d20:	8b 50 28             	mov    0x28(%eax),%edx
   11d23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d26:	89 50 30             	mov    %edx,0x30(%eax)
    tss->esi = frame->esi;
   11d29:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d2c:	8b 50 18             	mov    0x18(%eax),%edx
   11d2f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d32:	89 50 40             	mov    %edx,0x40(%eax)
    tss->edi = frame->edi;
   11d35:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d38:	8b 50 14             	mov    0x14(%eax),%edx
   11d3b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d3e:	89 50 44             	mov    %edx,0x44(%eax)
    tss->ebp = frame->ebp;
   11d41:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d44:	8b 50 1c             	mov    0x1c(%eax),%edx
   11d47:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d4a:	89 50 3c             	mov    %edx,0x3c(%eax)

    tss->cs = frame->cs;
   11d4d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d50:	8b 50 38             	mov    0x38(%eax),%edx
   11d53:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d56:	89 50 4c             	mov    %edx,0x4c(%eax)
    tss->ds = frame->ds;
   11d59:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d5c:	8b 50 10             	mov    0x10(%eax),%edx
   11d5f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d62:	89 50 54             	mov    %edx,0x54(%eax)
    tss->es = frame->es;
   11d65:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d68:	8b 50 0c             	mov    0xc(%eax),%edx
   11d6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d6e:	89 50 48             	mov    %edx,0x48(%eax)
    tss->fs = frame->fs;
   11d71:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d74:	8b 50 08             	mov    0x8(%eax),%edx
   11d77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d7a:	89 50 58             	mov    %edx,0x58(%eax)
    tss->gs = frame->gs;
   11d7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d80:	8b 50 04             	mov    0x4(%eax),%edx
   11d83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d86:	89 50 5c             	mov    %edx,0x5c(%eax)
    tss->eflags = frame->eflags;
   11d89:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d8c:	8b 10                	mov    (%eax),%edx
   11d8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11d91:	89 50 24             	mov    %edx,0x24(%eax)

    child_task->parent = parent_task;
   11d94:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d97:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11d9a:	89 90 28 02 00 00    	mov    %edx,0x228(%eax)
    
    // 复制父进程的内存空间到子进程
    if ((child_task->tss.cr3 = memory_copy_uvm(parent_task->tss.cr3)) < 0) {
   11da0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11da3:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
   11da9:	83 ec 0c             	sub    $0xc,%esp
   11dac:	50                   	push   %eax
   11dad:	e8 97 ec ff ff       	call   10a49 <memory_copy_uvm>
   11db2:	83 c4 10             	add    $0x10,%esp
   11db5:	89 c2                	mov    %eax,%edx
   11db7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11dba:	89 90 78 02 00 00    	mov    %edx,0x278(%eax)
        goto fork_failed;
    }
    task_start(child_task);
   11dc0:	83 ec 0c             	sub    $0xc,%esp
   11dc3:	ff 75 f0             	pushl  -0x10(%ebp)
   11dc6:	e8 48 f8 ff ff       	call   11613 <task_start>
   11dcb:	83 c4 10             	add    $0x10,%esp
    // 创建成功，返回子进程的pid
    return child_task->pid;
   11dce:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11dd1:	8b 40 04             	mov    0x4(%eax),%eax
   11dd4:	eb 2b                	jmp    11e01 <sys_fork+0x186>
        goto fork_failed;
   11dd6:	90                   	nop
   11dd7:	eb 01                	jmp    11dda <sys_fork+0x15f>
        goto fork_failed;
   11dd9:	90                   	nop
fork_failed:
    if (child_task) {
   11dda:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11dde:	74 1c                	je     11dfc <sys_fork+0x181>
        task_uninit (child_task);
   11de0:	83 ec 0c             	sub    $0xc,%esp
   11de3:	ff 75 f0             	pushl  -0x10(%ebp)
   11de6:	e8 55 f8 ff ff       	call   11640 <task_uninit>
   11deb:	83 c4 10             	add    $0x10,%esp
        free_task(child_task);
   11dee:	83 ec 0c             	sub    $0xc,%esp
   11df1:	ff 75 f0             	pushl  -0x10(%ebp)
   11df4:	e8 7f 03 00 00       	call   12178 <free_task>
   11df9:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11dfc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11e01:	c9                   	leave  
   11e02:	c3                   	ret    

00011e03 <sys_execve>:

int sys_execve(const char*name , char* const* argv, char* const* env)
{
   11e03:	55                   	push   %ebp
   11e04:	89 e5                	mov    %esp,%ebp
   11e06:	83 ec 28             	sub    $0x28,%esp
    task_t* task = task_manager.curr_task;
   11e09:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   11e0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_strncpy(task->name, get_filename(name), TASK_NAME_SIZE);
   11e11:	83 ec 0c             	sub    $0xc,%esp
   11e14:	ff 75 08             	pushl  0x8(%ebp)
   11e17:	e8 85 69 00 00       	call   187a1 <get_filename>
   11e1c:	83 c4 10             	add    $0x10,%esp
   11e1f:	89 c2                	mov    %eax,%edx
   11e21:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e24:	05 2c 02 00 00       	add    $0x22c,%eax
   11e29:	83 ec 04             	sub    $0x4,%esp
   11e2c:	6a 20                	push   $0x20
   11e2e:	52                   	push   %edx
   11e2f:	50                   	push   %eax
   11e30:	e8 f9 69 00 00       	call   1882e <kernel_strncpy>
   11e35:	83 c4 10             	add    $0x10,%esp
    uint32_t old_page_dir = task->tss.cr3;
   11e38:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11e3b:	8b 80 78 02 00 00    	mov    0x278(%eax),%eax
   11e41:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t new_page_dir = memory_create_uvm();
   11e44:	e8 df e9 ff ff       	call   10828 <memory_create_uvm>
   11e49:	89 45 ec             	mov    %eax,-0x14(%ebp)
    
    if(!new_page_dir)
   11e4c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11e50:	0f 84 4d 01 00 00    	je     11fa3 <sys_execve+0x1a0>
        goto execve_failed;
    uint32_t entry = load_elf_file(task, name, new_page_dir);
   11e56:	83 ec 04             	sub    $0x4,%esp
   11e59:	ff 75 ec             	pushl  -0x14(%ebp)
   11e5c:	ff 75 08             	pushl  0x8(%ebp)
   11e5f:	ff 75 f4             	pushl  -0xc(%ebp)
   11e62:	e8 44 03 00 00       	call   121ab <load_elf_file>
   11e67:	83 c4 10             	add    $0x10,%esp
   11e6a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(entry == 0)
   11e6d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11e71:	0f 84 2f 01 00 00    	je     11fa6 <sys_execve+0x1a3>
        goto execve_failed;
    uint32_t stack_top = MEM_STACK_TOP - MEM_ARG_SIZE;
   11e77:	c7 45 e4 00 c0 ff df 	movl   $0xdfffc000,-0x1c(%ebp)
    int err = memory_alloc_for_page_dir(new_page_dir, MEM_STACK_TOP - MEM_STACK_SIZE, MEM_STACK_SIZE, PTE_P|PTE_U|PTE_W);
   11e7e:	6a 07                	push   $0x7
   11e80:	68 00 40 1f 00       	push   $0x1f4000
   11e85:	68 00 c0 e0 df       	push   $0xdfe0c000
   11e8a:	ff 75 ec             	pushl  -0x14(%ebp)
   11e8d:	e8 43 ea ff ff       	call   108d5 <memory_alloc_for_page_dir>
   11e92:	83 c4 10             	add    $0x10,%esp
   11e95:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(err == -1)
   11e98:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
   11e9c:	75 15                	jne    11eb3 <sys_execve+0xb0>
    {
        log_printf("alloc err");
   11e9e:	83 ec 0c             	sub    $0xc,%esp
   11ea1:	68 fd 93 01 00       	push   $0x193fd
   11ea6:	e8 a1 70 00 00       	call   18f4c <log_printf>
   11eab:	83 c4 10             	add    $0x10,%esp
        goto execve_failed;
   11eae:	e9 f4 00 00 00       	jmp    11fa7 <sys_execve+0x1a4>
    }
    int argc = count_string(argv);
   11eb3:	83 ec 0c             	sub    $0xc,%esp
   11eb6:	ff 75 0c             	pushl  0xc(%ebp)
   11eb9:	e8 b8 68 00 00       	call   18776 <count_string>
   11ebe:	83 c4 10             	add    $0x10,%esp
   11ec1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    err = cpy_to_stack((char*)stack_top, new_page_dir, argc, argv);
   11ec4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11ec7:	ff 75 0c             	pushl  0xc(%ebp)
   11eca:	ff 75 dc             	pushl  -0x24(%ebp)
   11ecd:	ff 75 ec             	pushl  -0x14(%ebp)
   11ed0:	50                   	push   %eax
   11ed1:	e8 06 01 00 00       	call   11fdc <cpy_to_stack>
   11ed6:	83 c4 10             	add    $0x10,%esp
   11ed9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(err < 0)
   11edc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   11ee0:	79 15                	jns    11ef7 <sys_execve+0xf4>
    {
        log_printf("cpy args err");
   11ee2:	83 ec 0c             	sub    $0xc,%esp
   11ee5:	68 07 94 01 00       	push   $0x19407
   11eea:	e8 5d 70 00 00       	call   18f4c <log_printf>
   11eef:	83 c4 10             	add    $0x10,%esp
        goto execve_failed;
   11ef2:	e9 b0 00 00 00       	jmp    11fa7 <sys_execve+0x1a4>
    }
    syscall_frame_t* frame = (syscall_frame_t*)(task->tss.esp0 - sizeof(syscall_frame_t));
   11ef7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11efa:	8b 80 60 02 00 00    	mov    0x260(%eax),%eax
   11f00:	83 e8 58             	sub    $0x58,%eax
   11f03:	89 45 d8             	mov    %eax,-0x28(%ebp)
    frame->eip = entry;
   11f06:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f09:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11f0c:	89 50 34             	mov    %edx,0x34(%eax)
    frame->eax = frame->ebx = frame->ecx = frame->edx = 0;
   11f0f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f12:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   11f19:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f1c:	8b 50 28             	mov    0x28(%eax),%edx
   11f1f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f22:	89 50 2c             	mov    %edx,0x2c(%eax)
   11f25:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f28:	8b 50 2c             	mov    0x2c(%eax),%edx
   11f2b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f2e:	89 50 24             	mov    %edx,0x24(%eax)
   11f31:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f34:	8b 50 24             	mov    0x24(%eax),%edx
   11f37:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f3a:	89 50 30             	mov    %edx,0x30(%eax)
    frame->esi = frame->edi = frame->ebp = 0;
   11f3d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f40:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   11f47:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f4a:	8b 50 1c             	mov    0x1c(%eax),%edx
   11f4d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f50:	89 50 14             	mov    %edx,0x14(%eax)
   11f53:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f56:	8b 50 14             	mov    0x14(%eax),%edx
   11f59:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f5c:	89 50 18             	mov    %edx,0x18(%eax)
    frame->eflags = EFLAGS_DEFAULT| EFLAGS_IF;
   11f5f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f62:	c7 00 02 02 00 00    	movl   $0x202,(%eax)
    frame->esp = stack_top - sizeof(uint32_t)*SYSCALL_PARAM;
   11f68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11f6b:	8d 50 ec             	lea    -0x14(%eax),%edx
   11f6e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11f71:	89 50 50             	mov    %edx,0x50(%eax)
    task->tss.cr3 = new_page_dir;
   11f74:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11f77:	8b 55 ec             	mov    -0x14(%ebp),%edx
   11f7a:	89 90 78 02 00 00    	mov    %edx,0x278(%eax)
    mmu_set_page_dir(new_page_dir);
   11f80:	83 ec 0c             	sub    $0xc,%esp
   11f83:	ff 75 ec             	pushl  -0x14(%ebp)
   11f86:	e8 c0 f1 ff ff       	call   1114b <mmu_set_page_dir>
   11f8b:	83 c4 10             	add    $0x10,%esp
    memory_destroy_uvm(old_page_dir);
   11f8e:	83 ec 0c             	sub    $0xc,%esp
   11f91:	ff 75 f0             	pushl  -0x10(%ebp)
   11f94:	e8 05 ec ff ff       	call   10b9e <memory_destroy_uvm>
   11f99:	83 c4 10             	add    $0x10,%esp
    return 0;
   11f9c:	b8 00 00 00 00       	mov    $0x0,%eax
   11fa1:	eb 37                	jmp    11fda <sys_execve+0x1d7>
        goto execve_failed;
   11fa3:	90                   	nop
   11fa4:	eb 01                	jmp    11fa7 <sys_execve+0x1a4>
        goto execve_failed;
   11fa6:	90                   	nop
execve_failed:
    if (new_page_dir) {
   11fa7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11fab:	74 28                	je     11fd5 <sys_execve+0x1d2>
        task->tss.cr3 = old_page_dir;
   11fad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11fb0:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11fb3:	89 90 78 02 00 00    	mov    %edx,0x278(%eax)
        mmu_set_page_dir(old_page_dir);
   11fb9:	83 ec 0c             	sub    $0xc,%esp
   11fbc:	ff 75 f0             	pushl  -0x10(%ebp)
   11fbf:	e8 87 f1 ff ff       	call   1114b <mmu_set_page_dir>
   11fc4:	83 c4 10             	add    $0x10,%esp
        memory_destroy_uvm(new_page_dir);
   11fc7:	83 ec 0c             	sub    $0xc,%esp
   11fca:	ff 75 ec             	pushl  -0x14(%ebp)
   11fcd:	e8 cc eb ff ff       	call   10b9e <memory_destroy_uvm>
   11fd2:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   11fd5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11fda:	c9                   	leave  
   11fdb:	c3                   	ret    

00011fdc <cpy_to_stack>:
int cpy_to_stack(char* to, uint32_t page_dir, int argc, char* const* argv)
{
   11fdc:	55                   	push   %ebp
   11fdd:	89 e5                	mov    %esp,%ebp
   11fdf:	83 ec 38             	sub    $0x38,%esp
    task_arg_t task_arg;
    task_arg.argc = argc;
   11fe2:	8b 45 10             	mov    0x10(%ebp),%eax
   11fe5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    task_arg.argv = (char **)(to + sizeof(task_arg_t));
   11fe8:	8b 45 08             	mov    0x8(%ebp),%eax
   11feb:	83 c0 0c             	add    $0xc,%eax
   11fee:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char * dest_arg = to + sizeof(task_arg_t) + sizeof(char *) * (argc + 1);
   11ff1:	8b 45 10             	mov    0x10(%ebp),%eax
   11ff4:	83 c0 04             	add    $0x4,%eax
   11ff7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   11ffe:	8b 45 08             	mov    0x8(%ebp),%eax
   12001:	01 d0                	add    %edx,%eax
   12003:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char ** dest_argv_tb = (char **)memory_get_paddr(page_dir, (uint32_t)(to + sizeof(task_arg_t)));
   12006:	8b 45 08             	mov    0x8(%ebp),%eax
   12009:	83 c0 0c             	add    $0xc,%eax
   1200c:	83 ec 08             	sub    $0x8,%esp
   1200f:	50                   	push   %eax
   12010:	ff 75 0c             	pushl  0xc(%ebp)
   12013:	e8 85 ec ff ff       	call   10c9d <memory_get_paddr>
   12018:	83 c4 10             	add    $0x10,%esp
   1201b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    Assert(dest_argv_tb != 0);
   1201e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12022:	75 1c                	jne    12040 <cpy_to_stack+0x64>
   12024:	68 14 94 01 00       	push   $0x19414
   12029:	68 d8 94 01 00       	push   $0x194d8
   1202e:	68 bf 01 00 00       	push   $0x1bf
   12033:	68 a8 93 01 00       	push   $0x193a8
   12038:	e8 b2 6c 00 00       	call   18cef <pannic>
   1203d:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < argc; ++i)
   12040:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12047:	e9 82 00 00 00       	jmp    120ce <cpy_to_stack+0xf2>
    {
        char* from = argv[i];
   1204c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1204f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12056:	8b 45 14             	mov    0x14(%ebp),%eax
   12059:	01 d0                	add    %edx,%eax
   1205b:	8b 00                	mov    (%eax),%eax
   1205d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int len = kernel_strlen(from) + 1;
   12060:	83 ec 0c             	sub    $0xc,%esp
   12063:	ff 75 e8             	pushl  -0x18(%ebp)
   12066:	e8 33 68 00 00       	call   1889e <kernel_strlen>
   1206b:	83 c4 10             	add    $0x10,%esp
   1206e:	83 c0 01             	add    $0x1,%eax
   12071:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err = memory_copy_uvm_data((uint32_t)dest_arg, page_dir, (uint32_t)from, len);
   12074:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   12077:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1207a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1207d:	51                   	push   %ecx
   1207e:	52                   	push   %edx
   1207f:	ff 75 0c             	pushl  0xc(%ebp)
   12082:	50                   	push   %eax
   12083:	e8 5b ec ff ff       	call   10ce3 <memory_copy_uvm_data>
   12088:	83 c4 10             	add    $0x10,%esp
   1208b:	89 45 e0             	mov    %eax,-0x20(%ebp)
        Assert(err >= 0);
   1208e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   12092:	79 1c                	jns    120b0 <cpy_to_stack+0xd4>
   12094:	68 26 94 01 00       	push   $0x19426
   12099:	68 d8 94 01 00       	push   $0x194d8
   1209e:	68 c5 01 00 00       	push   $0x1c5
   120a3:	68 a8 93 01 00       	push   $0x193a8
   120a8:	e8 42 6c 00 00       	call   18cef <pannic>
   120ad:	83 c4 10             	add    $0x10,%esp
        dest_argv_tb[i] = dest_arg;
   120b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   120ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120bd:	01 c2                	add    %eax,%edx
   120bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   120c2:	89 02                	mov    %eax,(%edx)
        dest_arg += len;
   120c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   120c7:	01 45 f4             	add    %eax,-0xc(%ebp)
    for(int i = 0; i < argc; ++i)
   120ca:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   120ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120d1:	3b 45 10             	cmp    0x10(%ebp),%eax
   120d4:	0f 8c 72 ff ff ff    	jl     1204c <cpy_to_stack+0x70>
    }
    if(argc)
   120da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   120de:	74 15                	je     120f5 <cpy_to_stack+0x119>
        dest_argv_tb[argc] = '\0';
   120e0:	8b 45 10             	mov    0x10(%ebp),%eax
   120e3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   120ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120ed:	01 d0                	add    %edx,%eax
   120ef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    return memory_copy_uvm_data((uint32_t)to, page_dir, (uint32_t)&task_arg, sizeof(task_arg_t));
   120f5:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   120f8:	8b 45 08             	mov    0x8(%ebp),%eax
   120fb:	6a 0c                	push   $0xc
   120fd:	52                   	push   %edx
   120fe:	ff 75 0c             	pushl  0xc(%ebp)
   12101:	50                   	push   %eax
   12102:	e8 dc eb ff ff       	call   10ce3 <memory_copy_uvm_data>
   12107:	83 c4 10             	add    $0x10,%esp
}
   1210a:	c9                   	leave  
   1210b:	c3                   	ret    

0001210c <alloc_task>:
static task_t * alloc_task (void) {
   1210c:	55                   	push   %ebp
   1210d:	89 e5                	mov    %esp,%ebp
   1210f:	83 ec 18             	sub    $0x18,%esp
    task_t * task = (task_t *)0;
   12112:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&task_table_mutex);
   12119:	83 ec 0c             	sub    $0xc,%esp
   1211c:	68 00 f0 01 00       	push   $0x1f000
   12121:	e8 5e 61 00 00       	call   18284 <mutex_lock>
   12126:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < TASK_NUM; i++) {
   12129:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12130:	eb 2b                	jmp    1215d <alloc_task+0x51>
        task_t * curr = task_table + i;
   12132:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12135:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   1213b:	05 20 f0 01 00       	add    $0x1f020,%eax
   12140:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (curr->name[0] == 0) {
   12143:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12146:	0f b6 80 2c 02 00 00 	movzbl 0x22c(%eax),%eax
   1214d:	84 c0                	test   %al,%al
   1214f:	75 08                	jne    12159 <alloc_task+0x4d>
            task = curr;
   12151:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12154:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   12157:	eb 0a                	jmp    12163 <alloc_task+0x57>
    for (int i = 0; i < TASK_NUM; i++) {
   12159:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1215d:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
   12161:	7e cf                	jle    12132 <alloc_task+0x26>
        }
    }
    mutex_unlock(&task_table_mutex);
   12163:	83 ec 0c             	sub    $0xc,%esp
   12166:	68 00 f0 01 00       	push   $0x1f000
   1216b:	e8 aa 61 00 00       	call   1831a <mutex_unlock>
   12170:	83 c4 10             	add    $0x10,%esp

    return task;
   12173:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   12176:	c9                   	leave  
   12177:	c3                   	ret    

00012178 <free_task>:

static void free_task (task_t * task) {
   12178:	55                   	push   %ebp
   12179:	89 e5                	mov    %esp,%ebp
   1217b:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&task_table_mutex);
   1217e:	83 ec 0c             	sub    $0xc,%esp
   12181:	68 00 f0 01 00       	push   $0x1f000
   12186:	e8 f9 60 00 00       	call   18284 <mutex_lock>
   1218b:	83 c4 10             	add    $0x10,%esp
    task->name[0] = 0;
   1218e:	8b 45 08             	mov    0x8(%ebp),%eax
   12191:	c6 80 2c 02 00 00 00 	movb   $0x0,0x22c(%eax)
    mutex_unlock(&task_table_mutex);
   12198:	83 ec 0c             	sub    $0xc,%esp
   1219b:	68 00 f0 01 00       	push   $0x1f000
   121a0:	e8 75 61 00 00       	call   1831a <mutex_unlock>
   121a5:	83 c4 10             	add    $0x10,%esp
}
   121a8:	90                   	nop
   121a9:	c9                   	leave  
   121aa:	c3                   	ret    

000121ab <load_elf_file>:

static uint32_t load_elf_file (task_t * task, const char * name, uint32_t page_dir) {
   121ab:	55                   	push   %ebp
   121ac:	89 e5                	mov    %esp,%ebp
   121ae:	83 ec 78             	sub    $0x78,%esp
    Elf32_Ehdr elf_hdr;
    Elf32_Phdr elf_phdr;

    // 以只读方式打开
    int file = sys_open(name, 0);   // todo: flags暂时用0替代
   121b1:	83 ec 08             	sub    $0x8,%esp
   121b4:	6a 00                	push   $0x0
   121b6:	ff 75 0c             	pushl  0xc(%ebp)
   121b9:	e8 4e 53 00 00       	call   1750c <sys_open>
   121be:	83 c4 10             	add    $0x10,%esp
   121c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (file < 0) {
   121c4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   121c8:	79 18                	jns    121e2 <load_elf_file+0x37>
        log_printf("open file failed.%s", name);
   121ca:	83 ec 08             	sub    $0x8,%esp
   121cd:	ff 75 0c             	pushl  0xc(%ebp)
   121d0:	68 2f 94 01 00       	push   $0x1942f
   121d5:	e8 72 6d 00 00       	call   18f4c <log_printf>
   121da:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   121dd:	e9 91 01 00 00       	jmp    12373 <load_elf_file+0x1c8>
    }

    // 先读取文件头
    int cnt = sys_read(file, (char *)&elf_hdr, sizeof(Elf32_Ehdr));
   121e2:	83 ec 04             	sub    $0x4,%esp
   121e5:	6a 34                	push   $0x34
   121e7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   121ea:	50                   	push   %eax
   121eb:	ff 75 ec             	pushl  -0x14(%ebp)
   121ee:	e8 d5 54 00 00       	call   176c8 <sys_read>
   121f3:	83 c4 10             	add    $0x10,%esp
   121f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (cnt < sizeof(Elf32_Ehdr)) {
   121f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121fc:	83 f8 33             	cmp    $0x33,%eax
   121ff:	77 18                	ja     12219 <load_elf_file+0x6e>
        log_printf("elf hdr too small. size=%d", cnt);
   12201:	83 ec 08             	sub    $0x8,%esp
   12204:	ff 75 e8             	pushl  -0x18(%ebp)
   12207:	68 43 94 01 00       	push   $0x19443
   1220c:	e8 3b 6d 00 00       	call   18f4c <log_printf>
   12211:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   12214:	e9 5a 01 00 00       	jmp    12373 <load_elf_file+0x1c8>
    }

    // 做点必要性的检查。当然可以再做其它检查
    if ((elf_hdr.e_ident[0] != ELF_MAGIC) || (elf_hdr.e_ident[1] != 'E')
   12219:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   1221d:	3c 7f                	cmp    $0x7f,%al
   1221f:	75 18                	jne    12239 <load_elf_file+0x8e>
   12221:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
   12225:	3c 45                	cmp    $0x45,%al
   12227:	75 10                	jne    12239 <load_elf_file+0x8e>
        || (elf_hdr.e_ident[2] != 'L') || (elf_hdr.e_ident[3] != 'F')) {
   12229:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
   1222d:	3c 4c                	cmp    $0x4c,%al
   1222f:	75 08                	jne    12239 <load_elf_file+0x8e>
   12231:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
   12235:	3c 46                	cmp    $0x46,%al
   12237:	74 15                	je     1224e <load_elf_file+0xa3>
        log_printf("check elf indent failed.");
   12239:	83 ec 0c             	sub    $0xc,%esp
   1223c:	68 5e 94 01 00       	push   $0x1945e
   12241:	e8 06 6d 00 00       	call   18f4c <log_printf>
   12246:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   12249:	e9 25 01 00 00       	jmp    12373 <load_elf_file+0x1c8>
    }


    // 必须有程序头部
    if ((elf_hdr.e_phentsize == 0) || (elf_hdr.e_phoff == 0)) {
   1224e:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   12252:	66 85 c0             	test   %ax,%ax
   12255:	74 07                	je     1225e <load_elf_file+0xb3>
   12257:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1225a:	85 c0                	test   %eax,%eax
   1225c:	75 15                	jne    12273 <load_elf_file+0xc8>
        log_printf("none programe header");
   1225e:	83 ec 0c             	sub    $0xc,%esp
   12261:	68 77 94 01 00       	push   $0x19477
   12266:	e8 e1 6c 00 00       	call   18f4c <log_printf>
   1226b:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   1226e:	e9 00 01 00 00       	jmp    12373 <load_elf_file+0x1c8>
    }

    // 然后从中加载程序头，将内容拷贝到相应的位置
    uint32_t e_phoff = elf_hdr.e_phoff;
   12273:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12276:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for (int i = 0; i < elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) {
   12279:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12280:	e9 cb 00 00 00       	jmp    12350 <load_elf_file+0x1a5>
        if (sys_lseek(file, e_phoff, 0) < 0) {
   12285:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12288:	83 ec 04             	sub    $0x4,%esp
   1228b:	6a 00                	push   $0x0
   1228d:	50                   	push   %eax
   1228e:	ff 75 ec             	pushl  -0x14(%ebp)
   12291:	e8 16 55 00 00       	call   177ac <sys_lseek>
   12296:	83 c4 10             	add    $0x10,%esp
   12299:	85 c0                	test   %eax,%eax
   1229b:	79 15                	jns    122b2 <load_elf_file+0x107>
            log_printf("read file failed");
   1229d:	83 ec 0c             	sub    $0xc,%esp
   122a0:	68 8c 94 01 00       	push   $0x1948c
   122a5:	e8 a2 6c 00 00       	call   18f4c <log_printf>
   122aa:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   122ad:	e9 c1 00 00 00       	jmp    12373 <load_elf_file+0x1c8>
        }

        // 读取程序头后解析，这里不用读取到新进程的页表中，因为只是临时使用下
        cnt = sys_read(file, (char *)&elf_phdr, sizeof(Elf32_Phdr));
   122b2:	83 ec 04             	sub    $0x4,%esp
   122b5:	6a 20                	push   $0x20
   122b7:	8d 45 90             	lea    -0x70(%ebp),%eax
   122ba:	50                   	push   %eax
   122bb:	ff 75 ec             	pushl  -0x14(%ebp)
   122be:	e8 05 54 00 00       	call   176c8 <sys_read>
   122c3:	83 c4 10             	add    $0x10,%esp
   122c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (cnt < sizeof(Elf32_Phdr)) {
   122c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   122cc:	83 f8 1f             	cmp    $0x1f,%eax
   122cf:	77 15                	ja     122e6 <load_elf_file+0x13b>
            log_printf("read file failed");
   122d1:	83 ec 0c             	sub    $0xc,%esp
   122d4:	68 8c 94 01 00       	push   $0x1948c
   122d9:	e8 6e 6c 00 00       	call   18f4c <log_printf>
   122de:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   122e1:	e9 8d 00 00 00       	jmp    12373 <load_elf_file+0x1c8>
        }

        // 简单做一些检查，如有必要，可自行加更多
        // 主要判断是否是可加载的类型，并且要求加载的地址必须是用户空间
        if ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr < MEMORY_TASK_BASE)) {
   122e6:	8b 45 90             	mov    -0x70(%ebp),%eax
   122e9:	83 f8 01             	cmp    $0x1,%eax
   122ec:	75 53                	jne    12341 <load_elf_file+0x196>
   122ee:	8b 45 98             	mov    -0x68(%ebp),%eax
   122f1:	85 c0                	test   %eax,%eax
   122f3:	79 4c                	jns    12341 <load_elf_file+0x196>
           continue;
        }

        // 加载当前程序头
        int err = load_phdr(file, &elf_phdr, page_dir);
   122f5:	83 ec 04             	sub    $0x4,%esp
   122f8:	ff 75 10             	pushl  0x10(%ebp)
   122fb:	8d 45 90             	lea    -0x70(%ebp),%eax
   122fe:	50                   	push   %eax
   122ff:	ff 75 ec             	pushl  -0x14(%ebp)
   12302:	e8 87 00 00 00       	call   1238e <load_phdr>
   12307:	83 c4 10             	add    $0x10,%esp
   1230a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0) {
   1230d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12311:	79 12                	jns    12325 <load_elf_file+0x17a>
            log_printf("load program hdr failed");
   12313:	83 ec 0c             	sub    $0xc,%esp
   12316:	68 9d 94 01 00       	push   $0x1949d
   1231b:	e8 2c 6c 00 00       	call   18f4c <log_printf>
   12320:	83 c4 10             	add    $0x10,%esp
            goto load_failed;
   12323:	eb 4e                	jmp    12373 <load_elf_file+0x1c8>
        }

        // 简单起见，不检查了，以最后的地址为bss的地址
        task->heap_start = elf_phdr.p_vaddr + elf_phdr.p_memsz;
   12325:	8b 55 98             	mov    -0x68(%ebp),%edx
   12328:	8b 45 a4             	mov    -0x5c(%ebp),%eax
   1232b:	01 c2                	add    %eax,%edx
   1232d:	8b 45 08             	mov    0x8(%ebp),%eax
   12330:	89 50 08             	mov    %edx,0x8(%eax)
        task->heap_end = task->heap_start;
   12333:	8b 45 08             	mov    0x8(%ebp),%eax
   12336:	8b 50 08             	mov    0x8(%eax),%edx
   12339:	8b 45 08             	mov    0x8(%ebp),%eax
   1233c:	89 50 0c             	mov    %edx,0xc(%eax)
   1233f:	eb 01                	jmp    12342 <load_elf_file+0x197>
           continue;
   12341:	90                   	nop
    for (int i = 0; i < elf_hdr.e_phnum; i++, e_phoff += elf_hdr.e_phentsize) {
   12342:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12346:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
   1234a:	0f b7 c0             	movzwl %ax,%eax
   1234d:	01 45 f4             	add    %eax,-0xc(%ebp)
   12350:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
   12354:	0f b7 c0             	movzwl %ax,%eax
   12357:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1235a:	0f 8c 25 ff ff ff    	jl     12285 <load_elf_file+0xda>
   }

    sys_close(file);
   12360:	83 ec 0c             	sub    $0xc,%esp
   12363:	ff 75 ec             	pushl  -0x14(%ebp)
   12366:	e8 ca 54 00 00       	call   17835 <sys_close>
   1236b:	83 c4 10             	add    $0x10,%esp
    return elf_hdr.e_entry;
   1236e:	8b 45 c8             	mov    -0x38(%ebp),%eax
   12371:	eb 19                	jmp    1238c <load_elf_file+0x1e1>

load_failed:
    if (file >= 0) {
   12373:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   12377:	78 0e                	js     12387 <load_elf_file+0x1dc>
        sys_close(file);
   12379:	83 ec 0c             	sub    $0xc,%esp
   1237c:	ff 75 ec             	pushl  -0x14(%ebp)
   1237f:	e8 b1 54 00 00       	call   17835 <sys_close>
   12384:	83 c4 10             	add    $0x10,%esp
    }

    return 0;
   12387:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1238c:	c9                   	leave  
   1238d:	c3                   	ret    

0001238e <load_phdr>:

int load_phdr(int fd, Elf32_Phdr* elf_phdr, uint32_t page_dir)
{
   1238e:	55                   	push   %ebp
   1238f:	89 e5                	mov    %esp,%ebp
   12391:	83 ec 28             	sub    $0x28,%esp

    int err = memory_alloc_for_page_dir(page_dir, elf_phdr->p_vaddr, elf_phdr->p_memsz, PTE_P|PTE_U|PTE_W);
   12394:	8b 45 0c             	mov    0xc(%ebp),%eax
   12397:	8b 50 14             	mov    0x14(%eax),%edx
   1239a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1239d:	8b 40 08             	mov    0x8(%eax),%eax
   123a0:	6a 07                	push   $0x7
   123a2:	52                   	push   %edx
   123a3:	50                   	push   %eax
   123a4:	ff 75 10             	pushl  0x10(%ebp)
   123a7:	e8 29 e5 ff ff       	call   108d5 <memory_alloc_for_page_dir>
   123ac:	83 c4 10             	add    $0x10,%esp
   123af:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(err == -1)
   123b2:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
   123b6:	75 18                	jne    123d0 <load_phdr+0x42>
    {
        log_printf("memory alloc err");
   123b8:	83 ec 0c             	sub    $0xc,%esp
   123bb:	68 b5 94 01 00       	push   $0x194b5
   123c0:	e8 87 6b 00 00       	call   18f4c <log_printf>
   123c5:	83 c4 10             	add    $0x10,%esp
        goto loadphdr_fault;
   123c8:	90                   	nop
        size -= curr_size;
        vaddr += curr_size;
    }
    return 0;
loadphdr_fault:
    return -1;
   123c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   123ce:	eb 7e                	jmp    1244e <load_phdr+0xc0>
    sys_lseek(fd, elf_phdr->p_offset, 0);
   123d0:	8b 45 0c             	mov    0xc(%ebp),%eax
   123d3:	8b 40 04             	mov    0x4(%eax),%eax
   123d6:	83 ec 04             	sub    $0x4,%esp
   123d9:	6a 00                	push   $0x0
   123db:	50                   	push   %eax
   123dc:	ff 75 08             	pushl  0x8(%ebp)
   123df:	e8 c8 53 00 00       	call   177ac <sys_lseek>
   123e4:	83 c4 10             	add    $0x10,%esp
    uint32_t vaddr = elf_phdr->p_vaddr;
   123e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   123ea:	8b 40 08             	mov    0x8(%eax),%eax
   123ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t size = elf_phdr->p_filesz;
   123f0:	8b 45 0c             	mov    0xc(%ebp),%eax
   123f3:	8b 40 10             	mov    0x10(%eax),%eax
   123f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(size > 0)
   123f9:	eb 48                	jmp    12443 <load_phdr+0xb5>
        int curr_size = size > MEM_PAGE_SIZE ? MEM_PAGE_SIZE : size;
   123fb:	b8 00 10 00 00       	mov    $0x1000,%eax
   12400:	81 7d f0 00 10 00 00 	cmpl   $0x1000,-0x10(%ebp)
   12407:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
   1240b:	89 45 e8             	mov    %eax,-0x18(%ebp)
        uint32_t paddr = memory_get_paddr(page_dir, vaddr);
   1240e:	83 ec 08             	sub    $0x8,%esp
   12411:	ff 75 f4             	pushl  -0xc(%ebp)
   12414:	ff 75 10             	pushl  0x10(%ebp)
   12417:	e8 81 e8 ff ff       	call   10c9d <memory_get_paddr>
   1241c:	83 c4 10             	add    $0x10,%esp
   1241f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        sys_read(fd, (char*)paddr, curr_size);
   12422:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12425:	83 ec 04             	sub    $0x4,%esp
   12428:	ff 75 e8             	pushl  -0x18(%ebp)
   1242b:	50                   	push   %eax
   1242c:	ff 75 08             	pushl  0x8(%ebp)
   1242f:	e8 94 52 00 00       	call   176c8 <sys_read>
   12434:	83 c4 10             	add    $0x10,%esp
        size -= curr_size;
   12437:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1243a:	29 45 f0             	sub    %eax,-0x10(%ebp)
        vaddr += curr_size;
   1243d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12440:	01 45 f4             	add    %eax,-0xc(%ebp)
    while(size > 0)
   12443:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12447:	75 b2                	jne    123fb <load_phdr+0x6d>
    return 0;
   12449:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1244e:	c9                   	leave  
   1244f:	c3                   	ret    

00012450 <sys_wait>:

int sys_wait(int* status) {
   12450:	55                   	push   %ebp
   12451:	89 e5                	mov    %esp,%ebp
   12453:	83 ec 18             	sub    $0x18,%esp
    task_t* task = task_manager.curr_task;
   12456:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   1245b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(;;)
    {
        mutex_lock(&task_table_mutex);
   1245e:	83 ec 0c             	sub    $0xc,%esp
   12461:	68 00 f0 01 00       	push   $0x1f000
   12466:	e8 19 5e 00 00       	call   18284 <mutex_lock>
   1246b:	83 c4 10             	add    $0x10,%esp
        for(int i = 0; i < TASK_NUM; ++i)
   1246e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12475:	e9 d1 00 00 00       	jmp    1254b <sys_wait+0xfb>
        {
            if(task_table[i].parent == task)
   1247a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1247d:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   12483:	05 48 f2 01 00       	add    $0x1f248,%eax
   12488:	8b 00                	mov    (%eax),%eax
   1248a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1248d:	0f 85 b4 00 00 00    	jne    12547 <sys_wait+0xf7>
            {
                if(task_table[i].state == ZOMBIE)
   12493:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12496:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   1249c:	05 20 f0 01 00       	add    $0x1f020,%eax
   124a1:	8b 00                	mov    (%eax),%eax
   124a3:	83 f8 05             	cmp    $0x5,%eax
   124a6:	0f 85 9b 00 00 00    	jne    12547 <sys_wait+0xf7>
                {
                    int pid = task_table[i].pid;
   124ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   124af:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   124b5:	05 24 f0 01 00       	add    $0x1f024,%eax
   124ba:	8b 00                	mov    (%eax),%eax
   124bc:	89 45 ec             	mov    %eax,-0x14(%ebp)
                    *status = task_table[i].status;
   124bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   124c2:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   124c8:	05 78 f2 01 00       	add    $0x1f278,%eax
   124cd:	8b 10                	mov    (%eax),%edx
   124cf:	8b 45 08             	mov    0x8(%ebp),%eax
   124d2:	89 10                	mov    %edx,(%eax)
                    memory_destroy_uvm(task_table[i].tss.cr3);
   124d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   124d7:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   124dd:	05 98 f2 01 00       	add    $0x1f298,%eax
   124e2:	8b 00                	mov    (%eax),%eax
   124e4:	83 ec 0c             	sub    $0xc,%esp
   124e7:	50                   	push   %eax
   124e8:	e8 b1 e6 ff ff       	call   10b9e <memory_destroy_uvm>
   124ed:	83 c4 10             	add    $0x10,%esp
                    memory_free_page(task_table[i].tss.esp0 - MEM_PAGE_SIZE);
   124f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   124f3:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   124f9:	05 80 f2 01 00       	add    $0x1f280,%eax
   124fe:	8b 00                	mov    (%eax),%eax
   12500:	2d 00 10 00 00       	sub    $0x1000,%eax
   12505:	83 ec 0c             	sub    $0xc,%esp
   12508:	50                   	push   %eax
   12509:	e8 92 e4 ff ff       	call   109a0 <memory_free_page>
   1250e:	83 c4 10             	add    $0x10,%esp
                    kernel_memset((void*)&task_table[i], 0, sizeof(task_t));
   12511:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12514:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   1251a:	05 20 f0 01 00       	add    $0x1f020,%eax
   1251f:	83 ec 04             	sub    $0x4,%esp
   12522:	68 c8 02 00 00       	push   $0x2c8
   12527:	6a 00                	push   $0x0
   12529:	50                   	push   %eax
   1252a:	e8 73 64 00 00       	call   189a2 <kernel_memset>
   1252f:	83 c4 10             	add    $0x10,%esp
                    mutex_unlock(&task_table_mutex);
   12532:	83 ec 0c             	sub    $0xc,%esp
   12535:	68 00 f0 01 00       	push   $0x1f000
   1253a:	e8 db 5d 00 00       	call   1831a <mutex_unlock>
   1253f:	83 c4 10             	add    $0x10,%esp
                    return pid;
   12542:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12545:	eb 3f                	jmp    12586 <sys_wait+0x136>
        for(int i = 0; i < TASK_NUM; ++i)
   12547:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1254b:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   1254f:	0f 8e 25 ff ff ff    	jle    1247a <sys_wait+0x2a>
                }
            }
        }
        mutex_unlock(&task_table_mutex);
   12555:	83 ec 0c             	sub    $0xc,%esp
   12558:	68 00 f0 01 00       	push   $0x1f000
   1255d:	e8 b8 5d 00 00       	call   1831a <mutex_unlock>
   12562:	83 c4 10             	add    $0x10,%esp
        // irq_state_t state = enter_protection();
        task->state = WAITING;
   12565:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12568:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
        set_block(task);
   1256e:	83 ec 0c             	sub    $0xc,%esp
   12571:	ff 75 f0             	pushl  -0x10(%ebp)
   12574:	e8 98 f3 ff ff       	call   11911 <set_block>
   12579:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   1257c:	e8 5d f4 ff ff       	call   119de <task_dispatch>
        mutex_lock(&task_table_mutex);
   12581:	e9 d8 fe ff ff       	jmp    1245e <sys_wait+0xe>
        // leave_protection(state);
        
    }
	return 0;
}
   12586:	c9                   	leave  
   12587:	c3                   	ret    

00012588 <sys_exit>:
void sys_exit(int status) {
   12588:	55                   	push   %ebp
   12589:	89 e5                	mov    %esp,%ebp
   1258b:	83 ec 28             	sub    $0x28,%esp
	task_t* task = task_manager.curr_task;
   1258e:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   12593:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for(int i = 0; i < TASK_OFILE_NR; ++i)
   12596:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1259d:	eb 37                	jmp    125d6 <sys_exit+0x4e>
    {
        file_t* file = task_file(i);
   1259f:	ff 75 f4             	pushl  -0xc(%ebp)
   125a2:	e8 e4 ec ff ff       	call   1128b <task_file>
   125a7:	83 c4 04             	add    $0x4,%esp
   125aa:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if(file)
   125ad:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   125b1:	74 1f                	je     125d2 <sys_exit+0x4a>
        {
            sys_close(i);
   125b3:	83 ec 0c             	sub    $0xc,%esp
   125b6:	ff 75 f4             	pushl  -0xc(%ebp)
   125b9:	e8 77 52 00 00       	call   17835 <sys_close>
   125be:	83 c4 10             	add    $0x10,%esp
            task->file_table[i] = (file_t*)0;
   125c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   125c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   125c7:	83 c2 08             	add    $0x8,%edx
   125ca:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
   125d1:	00 
    for(int i = 0; i < TASK_OFILE_NR; ++i)
   125d2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   125d6:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   125da:	7e c3                	jle    1259f <sys_exit+0x17>
        }
    }

    mutex_lock(&task_table_mutex);
   125dc:	83 ec 0c             	sub    $0xc,%esp
   125df:	68 00 f0 01 00       	push   $0x1f000
   125e4:	e8 9b 5c 00 00       	call   18284 <mutex_lock>
   125e9:	83 c4 10             	add    $0x10,%esp
    int move_child = 0;
   125ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    for(int i = 0; i < TASK_NUM;++i)
   125f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   125fa:	eb 49                	jmp    12645 <sys_exit+0xbd>
    {
        if(task_table[i].parent == task)
   125fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   125ff:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   12605:	05 48 f2 01 00       	add    $0x1f248,%eax
   1260a:	8b 00                	mov    (%eax),%eax
   1260c:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   1260f:	75 30                	jne    12641 <sys_exit+0xb9>
        {
            task_table[i].parent = &task_manager.first_task;
   12611:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12614:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   1261a:	05 48 f2 01 00       	add    $0x1f248,%eax
   1261f:	c7 00 68 fc 05 00    	movl   $0x5fc68,(%eax)
            if(task_table[i].state == ZOMBIE)
   12625:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12628:	69 c0 c8 02 00 00    	imul   $0x2c8,%eax,%eax
   1262e:	05 20 f0 01 00       	add    $0x1f020,%eax
   12633:	8b 00                	mov    (%eax),%eax
   12635:	83 f8 05             	cmp    $0x5,%eax
   12638:	75 07                	jne    12641 <sys_exit+0xb9>
            {
                move_child = 1;
   1263a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    for(int i = 0; i < TASK_NUM;++i)
   12641:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12645:	83 7d ec 7f          	cmpl   $0x7f,-0x14(%ebp)
   12649:	7e b1                	jle    125fc <sys_exit+0x74>
            }
        }
    }
    mutex_unlock(&task_table_mutex);
   1264b:	83 ec 0c             	sub    $0xc,%esp
   1264e:	68 00 f0 01 00       	push   $0x1f000
   12653:	e8 c2 5c 00 00       	call   1831a <mutex_unlock>
   12658:	83 c4 10             	add    $0x10,%esp
    irq_state_t state = enter_protection();
   1265b:	e8 c6 0d 00 00       	call   13426 <enter_protection>
   12660:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    task_t* parent = task->parent;
   12663:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12666:	8b 80 28 02 00 00    	mov    0x228(%eax),%eax
   1266c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(move_child && (parent != &task_manager.first_task))
   1266f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12673:	74 23                	je     12698 <sys_exit+0x110>
   12675:	81 7d e0 68 fc 05 00 	cmpl   $0x5fc68,-0x20(%ebp)
   1267c:	74 1a                	je     12698 <sys_exit+0x110>
    {
        if(task_manager.first_task.state == WAITING)
   1267e:	a1 68 fc 05 00       	mov    0x5fc68,%eax
   12683:	83 f8 04             	cmp    $0x4,%eax
   12686:	75 10                	jne    12698 <sys_exit+0x110>
            set_ready(&task_manager.first_task);
   12688:	83 ec 0c             	sub    $0xc,%esp
   1268b:	68 68 fc 05 00       	push   $0x5fc68
   12690:	e8 48 f2 ff ff       	call   118dd <set_ready>
   12695:	83 c4 10             	add    $0x10,%esp
    }
    if(parent->state == WAITING)
   12698:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1269b:	8b 00                	mov    (%eax),%eax
   1269d:	83 f8 04             	cmp    $0x4,%eax
   126a0:	75 0e                	jne    126b0 <sys_exit+0x128>
        set_ready(parent);
   126a2:	83 ec 0c             	sub    $0xc,%esp
   126a5:	ff 75 e0             	pushl  -0x20(%ebp)
   126a8:	e8 30 f2 ff ff       	call   118dd <set_ready>
   126ad:	83 c4 10             	add    $0x10,%esp
    task->status = status;
   126b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   126b3:	8b 55 08             	mov    0x8(%ebp),%edx
   126b6:	89 90 58 02 00 00    	mov    %edx,0x258(%eax)
    task->state = ZOMBIE;
   126bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   126bf:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    set_block(task);
   126c5:	83 ec 0c             	sub    $0xc,%esp
   126c8:	ff 75 e8             	pushl  -0x18(%ebp)
   126cb:	e8 41 f2 ff ff       	call   11911 <set_block>
   126d0:	83 c4 10             	add    $0x10,%esp
    task_dispatch();
   126d3:	e8 06 f3 ff ff       	call   119de <task_dispatch>
    leave_protection(state);
   126d8:	83 ec 0c             	sub    $0xc,%esp
   126db:	ff 75 e4             	pushl  -0x1c(%ebp)
   126de:	e8 5b 0d 00 00       	call   1343e <leave_protection>
   126e3:	83 c4 10             	add    $0x10,%esp
    
    return;
   126e6:	90                   	nop

   126e7:	c9                   	leave  
   126e8:	c3                   	ret    

000126e9 <lgdt>:
static inline void lgdt(uint32_t start, uint32_t size) {
   126e9:	55                   	push   %ebp
   126ea:	89 e5                	mov    %esp,%ebp
   126ec:	83 ec 10             	sub    $0x10,%esp
	gdt.start31_16 = start >> 16;
   126ef:	8b 45 08             	mov    0x8(%ebp),%eax
   126f2:	c1 e8 10             	shr    $0x10,%eax
   126f5:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	gdt.start15_0 = start & 0xFFFF;
   126f9:	8b 45 08             	mov    0x8(%ebp),%eax
   126fc:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	gdt.limit = size - 1;
   12700:	8b 45 0c             	mov    0xc(%ebp),%eax
   12703:	83 e8 01             	sub    $0x1,%eax
   12706:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	__asm__ __volatile__("lgdt %[g]"::[g]"m"(gdt));
   1270a:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   1270e:	90                   	nop
   1270f:	c9                   	leave  
   12710:	c3                   	ret    

00012711 <segment_desc_set>:
#include "cpu/irq.h"
#include "ipc/mutex.h"
#include "core/syscall.h"
static segment_desc_t gdt_table[GDT_TABLE_SIZE];
static mutex_t mutex;
void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr){
   12711:	55                   	push   %ebp
   12712:	89 e5                	mov    %esp,%ebp
   12714:	83 ec 14             	sub    $0x14,%esp
   12717:	8b 45 14             	mov    0x14(%ebp),%eax
   1271a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t* desc = gdt_table + (selector >> 3); //segment_desc_t是8个字节
   1271e:	8b 45 08             	mov    0x8(%ebp),%eax
   12721:	c1 f8 03             	sar    $0x3,%eax
   12724:	c1 e0 03             	shl    $0x3,%eax
   12727:	05 20 54 03 00       	add    $0x35420,%eax
   1272c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(limit > 0xfffff){
   1272f:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   12736:	76 0f                	jbe    12747 <segment_desc_set+0x36>
        attr |= 0x8000;
   12738:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
        limit /= 0x1000;
   1273e:	8b 45 10             	mov    0x10(%ebp),%eax
   12741:	c1 e8 0c             	shr    $0xc,%eax
   12744:	89 45 10             	mov    %eax,0x10(%ebp)
    }
    desc -> limit15_0 = limit & 0xFFFF;
   12747:	8b 45 10             	mov    0x10(%ebp),%eax
   1274a:	89 c2                	mov    %eax,%edx
   1274c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1274f:	66 89 10             	mov    %dx,(%eax)
    desc -> base15_0 = base & 0xFFFF;
   12752:	8b 45 0c             	mov    0xc(%ebp),%eax
   12755:	89 c2                	mov    %eax,%edx
   12757:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1275a:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc -> base23_16 = (base >> 16) & 0xFF;
   1275e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12761:	c1 e8 10             	shr    $0x10,%eax
   12764:	89 c2                	mov    %eax,%edx
   12766:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12769:	88 50 04             	mov    %dl,0x4(%eax)
    desc -> attr = attr |(((limit >> 16) &0xF) << 8);
   1276c:	8b 45 10             	mov    0x10(%ebp),%eax
   1276f:	c1 e8 10             	shr    $0x10,%eax
   12772:	c1 e0 08             	shl    $0x8,%eax
   12775:	66 25 00 0f          	and    $0xf00,%ax
   12779:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   1277d:	89 c2                	mov    %eax,%edx
   1277f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12782:	66 89 50 05          	mov    %dx,0x5(%eax)
    desc -> base31_24 = (base >> 24) & 0xFF;
   12786:	8b 45 0c             	mov    0xc(%ebp),%eax
   12789:	c1 e8 18             	shr    $0x18,%eax
   1278c:	89 c2                	mov    %eax,%edx
   1278e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12791:	88 50 07             	mov    %dl,0x7(%eax)
}
   12794:	90                   	nop
   12795:	c9                   	leave  
   12796:	c3                   	ret    

00012797 <gate_desc_set>:
void gate_desc_set(gate_desc_t* desc, uint16_t selector, uint32_t offset, uint16_t attr)
{
   12797:	55                   	push   %ebp
   12798:	89 e5                	mov    %esp,%ebp
   1279a:	83 ec 08             	sub    $0x8,%esp
   1279d:	8b 55 0c             	mov    0xc(%ebp),%edx
   127a0:	8b 45 14             	mov    0x14(%ebp),%eax
   127a3:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   127a7:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    desc -> selector = selector;
   127ab:	8b 45 08             	mov    0x8(%ebp),%eax
   127ae:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   127b2:	66 89 50 02          	mov    %dx,0x2(%eax)
    desc -> offset15_0 = offset & 0xffff;
   127b6:	8b 45 10             	mov    0x10(%ebp),%eax
   127b9:	89 c2                	mov    %eax,%edx
   127bb:	8b 45 08             	mov    0x8(%ebp),%eax
   127be:	66 89 10             	mov    %dx,(%eax)
    desc -> attr = attr;
   127c1:	8b 45 08             	mov    0x8(%ebp),%eax
   127c4:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   127c8:	66 89 50 04          	mov    %dx,0x4(%eax)
    desc -> offset31_16 = (offset >> 16) &0xFFFF;
   127cc:	8b 45 10             	mov    0x10(%ebp),%eax
   127cf:	c1 e8 10             	shr    $0x10,%eax
   127d2:	89 c2                	mov    %eax,%edx
   127d4:	8b 45 08             	mov    0x8(%ebp),%eax
   127d7:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   127db:	90                   	nop
   127dc:	c9                   	leave  
   127dd:	c3                   	ret    

000127de <init_gdt>:
void init_gdt(void){
   127de:	55                   	push   %ebp
   127df:	89 e5                	mov    %esp,%ebp
   127e1:	83 ec 10             	sub    $0x10,%esp
    for(int i = 0; i < GDT_TABLE_SIZE; ++i)
   127e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   127eb:	eb 15                	jmp    12802 <init_gdt+0x24>
        segment_desc_set(i * sizeof(segment_desc_set), 0, 0, 0);
   127ed:	6a 00                	push   $0x0
   127ef:	6a 00                	push   $0x0
   127f1:	6a 00                	push   $0x0
   127f3:	ff 75 fc             	pushl  -0x4(%ebp)
   127f6:	e8 16 ff ff ff       	call   12711 <segment_desc_set>
   127fb:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < GDT_TABLE_SIZE; ++i)
   127fe:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12802:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
   12809:	7e e2                	jle    127ed <init_gdt+0xf>

    segment_desc_set(KERNEL_SELECTOR_CS, 0x00000000, 0xFFFFFFFF, 
   1280b:	68 9a c0 00 00       	push   $0xc09a
   12810:	6a ff                	push   $0xffffffff
   12812:	6a 00                	push   $0x0
   12814:	6a 08                	push   $0x8
   12816:	e8 f6 fe ff ff       	call   12711 <segment_desc_set>
   1281b:	83 c4 10             	add    $0x10,%esp
    (SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE
                     | SEG_TYPE_RW | SEG_D | SEG_G)
    );
    segment_desc_set(KERNEL_SELECTOR_DS, 0x00000000, 0xffffffff, 
   1281e:	68 92 c0 00 00       	push   $0xc092
   12823:	6a ff                	push   $0xffffffff
   12825:	6a 00                	push   $0x0
   12827:	6a 10                	push   $0x10
   12829:	e8 e3 fe ff ff       	call   12711 <segment_desc_set>
   1282e:	83 c4 10             	add    $0x10,%esp
    (SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA
                     | SEG_TYPE_RW | SEG_D | SEG_G)
    );
    gate_desc_set((gate_desc_t*)(gdt_table + (SYSTEM_SELECTOR >> 3)), KERNEL_SELECTOR_CS,
   12831:	ba c9 02 01 00       	mov    $0x102c9,%edx
   12836:	b8 38 54 03 00       	mov    $0x35438,%eax
   1283b:	68 05 ec 00 00       	push   $0xec05
   12840:	52                   	push   %edx
   12841:	6a 08                	push   $0x8
   12843:	50                   	push   %eax
   12844:	e8 4e ff ff ff       	call   12797 <gate_desc_set>
   12849:	83 c4 10             	add    $0x10,%esp
    (uint32_t)exception_handler_syscall,
    GATE_P_PRESENT | GATE_DPL3 |  GATE_TYPE_SYSCALL | SYSCALL_PARAM
    );

    
    lgdt((uint32_t)gdt_table, sizeof(gdt_table));
   1284c:	b8 20 54 03 00       	mov    $0x35420,%eax
   12851:	68 00 08 00 00       	push   $0x800
   12856:	50                   	push   %eax
   12857:	e8 8d fe ff ff       	call   126e9 <lgdt>
   1285c:	83 c4 08             	add    $0x8,%esp
}
   1285f:	90                   	nop
   12860:	c9                   	leave  
   12861:	c3                   	ret    

00012862 <cpu_init>:

void cpu_init(void){
   12862:	55                   	push   %ebp
   12863:	89 e5                	mov    %esp,%ebp
   12865:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   12868:	83 ec 0c             	sub    $0xc,%esp
   1286b:	68 20 5c 03 00       	push   $0x35c20
   12870:	e8 e1 59 00 00       	call   18256 <mutex_init>
   12875:	83 c4 10             	add    $0x10,%esp
    init_gdt();
   12878:	e8 61 ff ff ff       	call   127de <init_gdt>
}
   1287d:	90                   	nop
   1287e:	c9                   	leave  
   1287f:	c3                   	ret    

00012880 <gdt_alloc_desc>:

int gdt_alloc_desc(void){
   12880:	55                   	push   %ebp
   12881:	89 e5                	mov    %esp,%ebp
   12883:	83 ec 18             	sub    $0x18,%esp
    mutex_lock(&mutex);
   12886:	83 ec 0c             	sub    $0xc,%esp
   12889:	68 20 5c 03 00       	push   $0x35c20
   1288e:	e8 f1 59 00 00       	call   18284 <mutex_lock>
   12893:	83 c4 10             	add    $0x10,%esp
    for(int i = 1; i < GDT_TABLE_SIZE; ++i){
   12896:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   1289d:	eb 3b                	jmp    128da <gdt_alloc_desc+0x5a>
        segment_desc_t * desc = gdt_table;
   1289f:	c7 45 f0 20 54 03 00 	movl   $0x35420,-0x10(%ebp)
        if((desc + i) -> attr == 0)
   128a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   128a9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   128b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   128b3:	01 d0                	add    %edx,%eax
   128b5:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   128b9:	66 85 c0             	test   %ax,%ax
   128bc:	75 18                	jne    128d6 <gdt_alloc_desc+0x56>
        {
            mutex_unlock(&mutex);
   128be:	83 ec 0c             	sub    $0xc,%esp
   128c1:	68 20 5c 03 00       	push   $0x35c20
   128c6:	e8 4f 5a 00 00       	call   1831a <mutex_unlock>
   128cb:	83 c4 10             	add    $0x10,%esp
            return i * sizeof(segment_desc_t);
   128ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
   128d1:	c1 e0 03             	shl    $0x3,%eax
   128d4:	eb 1d                	jmp    128f3 <gdt_alloc_desc+0x73>
    for(int i = 1; i < GDT_TABLE_SIZE; ++i){
   128d6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   128da:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   128e1:	7e bc                	jle    1289f <gdt_alloc_desc+0x1f>
        }
            
    }
    mutex_unlock(&mutex);
   128e3:	83 ec 0c             	sub    $0xc,%esp
   128e6:	68 20 5c 03 00       	push   $0x35c20
   128eb:	e8 2a 5a 00 00       	call   1831a <mutex_unlock>
   128f0:	83 c4 10             	add    $0x10,%esp
}
   128f3:	c9                   	leave  
   128f4:	c3                   	ret    

000128f5 <gdt_free_tss>:

void gdt_free_tss(int selector)
{
   128f5:	55                   	push   %ebp
   128f6:	89 e5                	mov    %esp,%ebp
   128f8:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&mutex);
   128fb:	83 ec 0c             	sub    $0xc,%esp
   128fe:	68 20 5c 03 00       	push   $0x35c20
   12903:	e8 7c 59 00 00       	call   18284 <mutex_lock>
   12908:	83 c4 10             	add    $0x10,%esp
    gdt_table[selector / sizeof(segment_desc_t)].attr = 0;
   1290b:	8b 45 08             	mov    0x8(%ebp),%eax
   1290e:	c1 e8 03             	shr    $0x3,%eax
   12911:	66 c7 04 c5 25 54 03 	movw   $0x0,0x35425(,%eax,8)
   12918:	00 00 00 
    mutex_unlock(&mutex);
   1291b:	83 ec 0c             	sub    $0xc,%esp
   1291e:	68 20 5c 03 00       	push   $0x35c20
   12923:	e8 f2 59 00 00       	call   1831a <mutex_unlock>
   12928:	83 c4 10             	add    $0x10,%esp
   1292b:	90                   	nop
   1292c:	c9                   	leave  
   1292d:	c3                   	ret    

0001292e <inb>:
static inline uint8_t inb(uint16_t  port) {
   1292e:	55                   	push   %ebp
   1292f:	89 e5                	mov    %esp,%ebp
   12931:	83 ec 14             	sub    $0x14,%esp
   12934:	8b 45 08             	mov    0x8(%ebp),%eax
   12937:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   1293b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1293f:	89 c2                	mov    %eax,%edx
   12941:	ec                   	in     (%dx),%al
   12942:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   12945:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   12949:	c9                   	leave  
   1294a:	c3                   	ret    

0001294b <inw>:
static inline uint16_t inw(uint16_t  port) {
   1294b:	55                   	push   %ebp
   1294c:	89 e5                	mov    %esp,%ebp
   1294e:	83 ec 14             	sub    $0x14,%esp
   12951:	8b 45 08             	mov    0x8(%ebp),%eax
   12954:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   12958:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1295c:	89 c2                	mov    %eax,%edx
   1295e:	66 ed                	in     (%dx),%ax
   12960:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   12964:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   12968:	c9                   	leave  
   12969:	c3                   	ret    

0001296a <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   1296a:	55                   	push   %ebp
   1296b:	89 e5                	mov    %esp,%ebp
   1296d:	83 ec 08             	sub    $0x8,%esp
   12970:	8b 55 08             	mov    0x8(%ebp),%edx
   12973:	8b 45 0c             	mov    0xc(%ebp),%eax
   12976:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1297a:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   1297d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   12981:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   12985:	ee                   	out    %al,(%dx)
}
   12986:	90                   	nop
   12987:	c9                   	leave  
   12988:	c3                   	ret    

00012989 <cli>:
static inline void cli() {
   12989:	55                   	push   %ebp
   1298a:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("cli");
   1298c:	fa                   	cli    
}
   1298d:	90                   	nop
   1298e:	5d                   	pop    %ebp
   1298f:	c3                   	ret    

00012990 <sti>:
static inline void sti() {
   12990:	55                   	push   %ebp
   12991:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("sti");
   12993:	fb                   	sti    
}
   12994:	90                   	nop
   12995:	5d                   	pop    %ebp
   12996:	c3                   	ret    

00012997 <lidt>:
static inline void lidt(uint32_t start, uint32_t size) {
   12997:	55                   	push   %ebp
   12998:	89 e5                	mov    %esp,%ebp
   1299a:	83 ec 10             	sub    $0x10,%esp
	idt.start31_16 = start >> 16;
   1299d:	8b 45 08             	mov    0x8(%ebp),%eax
   129a0:	c1 e8 10             	shr    $0x10,%eax
   129a3:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	idt.start15_0 = start & 0xFFFF;
   129a7:	8b 45 08             	mov    0x8(%ebp),%eax
   129aa:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	idt.limit = size - 1;
   129ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   129b1:	83 e8 01             	sub    $0x1,%eax
   129b4:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	__asm__ __volatile__("lidt %[g]"::[g]"m"(idt));
   129b8:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   129bc:	90                   	nop
   129bd:	c9                   	leave  
   129be:	c3                   	ret    

000129bf <read_cr2>:
static inline uint32_t read_cr2() {
   129bf:	55                   	push   %ebp
   129c0:	89 e5                	mov    %esp,%ebp
   129c2:	83 ec 10             	sub    $0x10,%esp
    __asm__ __volatile__("mov %%cr2, %[v]":[v]"=r"(cr2));
   129c5:	0f 20 d0             	mov    %cr2,%eax
   129c8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return cr2;
   129cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   129ce:	c9                   	leave  
   129cf:	c3                   	ret    

000129d0 <hlt>:
static inline void hlt() {
   129d0:	55                   	push   %ebp
   129d1:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("hlt");
   129d3:	f4                   	hlt    
}
   129d4:	90                   	nop
   129d5:	5d                   	pop    %ebp
   129d6:	c3                   	ret    

000129d7 <read_eflags>:

static inline uint32_t  read_eflags(void) {
   129d7:	55                   	push   %ebp
   129d8:	89 e5                	mov    %esp,%ebp
   129da:	83 ec 10             	sub    $0x10,%esp
	uint32_t state;
	__asm__ __volatile__("pushf\n\tpop %%eax":"=a"(state));
   129dd:	9c                   	pushf  
   129de:	58                   	pop    %eax
   129df:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return state;
   129e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   129e5:	c9                   	leave  
   129e6:	c3                   	ret    

000129e7 <write_eflags>:
static inline void write_eflags(uint32_t  state) {
   129e7:	55                   	push   %ebp
   129e8:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("push %%eax\n\tpopf"::"a"(state));
   129ea:	8b 45 08             	mov    0x8(%ebp),%eax
   129ed:	50                   	push   %eax
   129ee:	9d                   	popf   
}
   129ef:	90                   	nop
   129f0:	5d                   	pop    %ebp
   129f1:	c3                   	ret    

000129f2 <read_disk>:
static void read_disk(int sector, int sector_count, uint8_t * buf) {
   129f2:	55                   	push   %ebp
   129f3:	89 e5                	mov    %esp,%ebp
   129f5:	53                   	push   %ebx
   129f6:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   129f9:	68 e0 00 00 00       	push   $0xe0
   129fe:	68 f6 01 00 00       	push   $0x1f6
   12a03:	e8 62 ff ff ff       	call   1296a <outb>
   12a08:	83 c4 08             	add    $0x8,%esp
	outb(0x1F2, (uint8_t) (sector_count >> 8));
   12a0b:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a0e:	c1 f8 08             	sar    $0x8,%eax
   12a11:	0f b6 c0             	movzbl %al,%eax
   12a14:	50                   	push   %eax
   12a15:	68 f2 01 00 00       	push   $0x1f2
   12a1a:	e8 4b ff ff ff       	call   1296a <outb>
   12a1f:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		// LBA参数的24~31位
   12a22:	8b 45 08             	mov    0x8(%ebp),%eax
   12a25:	c1 f8 18             	sar    $0x18,%eax
   12a28:	0f b6 c0             	movzbl %al,%eax
   12a2b:	50                   	push   %eax
   12a2c:	68 f3 01 00 00       	push   $0x1f3
   12a31:	e8 34 ff ff ff       	call   1296a <outb>
   12a36:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					// LBA参数的32~39位
   12a39:	6a 00                	push   $0x0
   12a3b:	68 f4 01 00 00       	push   $0x1f4
   12a40:	e8 25 ff ff ff       	call   1296a <outb>
   12a45:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					// LBA参数的40~47位
   12a48:	6a 00                	push   $0x0
   12a4a:	68 f5 01 00 00       	push   $0x1f5
   12a4f:	e8 16 ff ff ff       	call   1296a <outb>
   12a54:	83 c4 08             	add    $0x8,%esp
    outb(0x1F2, (uint8_t) (sector_count));
   12a57:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a5a:	0f b6 c0             	movzbl %al,%eax
   12a5d:	50                   	push   %eax
   12a5e:	68 f2 01 00 00       	push   $0x1f2
   12a63:	e8 02 ff ff ff       	call   1296a <outb>
   12a68:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			// LBA参数的0~7位
   12a6b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a6e:	0f b6 c0             	movzbl %al,%eax
   12a71:	50                   	push   %eax
   12a72:	68 f3 01 00 00       	push   $0x1f3
   12a77:	e8 ee fe ff ff       	call   1296a <outb>
   12a7c:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		// LBA参数的8~15位
   12a7f:	8b 45 08             	mov    0x8(%ebp),%eax
   12a82:	c1 f8 08             	sar    $0x8,%eax
   12a85:	0f b6 c0             	movzbl %al,%eax
   12a88:	50                   	push   %eax
   12a89:	68 f4 01 00 00       	push   $0x1f4
   12a8e:	e8 d7 fe ff ff       	call   1296a <outb>
   12a93:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		// LBA参数的16~23位
   12a96:	8b 45 08             	mov    0x8(%ebp),%eax
   12a99:	c1 f8 10             	sar    $0x10,%eax
   12a9c:	0f b6 c0             	movzbl %al,%eax
   12a9f:	50                   	push   %eax
   12aa0:	68 f5 01 00 00       	push   $0x1f5
   12aa5:	e8 c0 fe ff ff       	call   1296a <outb>
   12aaa:	83 c4 08             	add    $0x8,%esp
	outb(0x1F7, (uint8_t) 0x24);
   12aad:	6a 24                	push   $0x24
   12aaf:	68 f7 01 00 00       	push   $0x1f7
   12ab4:	e8 b1 fe ff ff       	call   1296a <outb>
   12ab9:	83 c4 08             	add    $0x8,%esp
	uint16_t *data_buf = (uint16_t*) buf;
   12abc:	8b 45 10             	mov    0x10(%ebp),%eax
   12abf:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (sector_count-- > 0) {
   12ac2:	eb 4a                	jmp    12b0e <read_disk+0x11c>
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   12ac4:	90                   	nop
   12ac5:	68 f7 01 00 00       	push   $0x1f7
   12aca:	e8 5f fe ff ff       	call   1292e <inb>
   12acf:	83 c4 04             	add    $0x4,%esp
   12ad2:	0f b6 c0             	movzbl %al,%eax
   12ad5:	25 88 00 00 00       	and    $0x88,%eax
   12ada:	83 f8 08             	cmp    $0x8,%eax
   12add:	75 e6                	jne    12ac5 <read_disk+0xd3>
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   12adf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12ae6:	eb 1d                	jmp    12b05 <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   12ae8:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   12aeb:	8d 43 02             	lea    0x2(%ebx),%eax
   12aee:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12af1:	68 f0 01 00 00       	push   $0x1f0
   12af6:	e8 50 fe ff ff       	call   1294b <inw>
   12afb:	83 c4 04             	add    $0x4,%esp
   12afe:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   12b01:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12b05:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   12b0c:	7e da                	jle    12ae8 <read_disk+0xf6>
	while (sector_count-- > 0) {
   12b0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b11:	8d 50 ff             	lea    -0x1(%eax),%edx
   12b14:	89 55 0c             	mov    %edx,0xc(%ebp)
   12b17:	85 c0                	test   %eax,%eax
   12b19:	7f a9                	jg     12ac4 <read_disk+0xd2>
}
   12b1b:	90                   	nop
   12b1c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12b1f:	c9                   	leave  
   12b20:	c3                   	ret    

00012b21 <dump_core_regs>:
#include "tools/log.h"
#include "comm/cpu_instr.h"
#include "fs/fs.h"
static gate_desc_t idt_table[IDT_TABLE_NM];

static void dump_core_regs (exception_frame_t * frame) {
   12b21:	55                   	push   %ebp
   12b22:	89 e5                	mov    %esp,%ebp
   12b24:	57                   	push   %edi
   12b25:	56                   	push   %esi
   12b26:	53                   	push   %ebx
   12b27:	83 ec 2c             	sub    $0x2c,%esp
    // 打印CPU寄存器相关内容
    uint32_t esp, ss;
    if (frame->cs & 0x7) {
   12b2a:	8b 45 08             	mov    0x8(%ebp),%eax
   12b2d:	8b 40 3c             	mov    0x3c(%eax),%eax
   12b30:	83 e0 07             	and    $0x7,%eax
   12b33:	85 c0                	test   %eax,%eax
   12b35:	74 14                	je     12b4b <dump_core_regs+0x2a>
        ss = frame->ds;
   12b37:	8b 45 08             	mov    0x8(%ebp),%eax
   12b3a:	8b 40 0c             	mov    0xc(%eax),%eax
   12b3d:	89 45 e0             	mov    %eax,-0x20(%ebp)
        esp = frame->esp;
   12b40:	8b 45 08             	mov    0x8(%ebp),%eax
   12b43:	8b 40 1c             	mov    0x1c(%eax),%eax
   12b46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   12b49:	eb 12                	jmp    12b5d <dump_core_regs+0x3c>
    } else {
        ss = frame->ss3;
   12b4b:	8b 45 08             	mov    0x8(%ebp),%eax
   12b4e:	8b 40 48             	mov    0x48(%eax),%eax
   12b51:	89 45 e0             	mov    %eax,-0x20(%ebp)
        esp = frame->esp3;
   12b54:	8b 45 08             	mov    0x8(%ebp),%eax
   12b57:	8b 40 44             	mov    0x44(%eax),%eax
   12b5a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
    log_printf("IRQ: %d, error code: %d.", frame->num, frame->with_err_num);
   12b5d:	8b 45 08             	mov    0x8(%ebp),%eax
   12b60:	8b 50 34             	mov    0x34(%eax),%edx
   12b63:	8b 45 08             	mov    0x8(%ebp),%eax
   12b66:	8b 40 30             	mov    0x30(%eax),%eax
   12b69:	83 ec 04             	sub    $0x4,%esp
   12b6c:	52                   	push   %edx
   12b6d:	50                   	push   %eax
   12b6e:	68 e8 94 01 00       	push   $0x194e8
   12b73:	e8 d4 63 00 00       	call   18f4c <log_printf>
   12b78:	83 c4 10             	add    $0x10,%esp
    log_printf("CS: %d\nDS: %d\nES: %d\nSS: %d\nFS:%d\nGS:%d",
   12b7b:	8b 45 08             	mov    0x8(%ebp),%eax
   12b7e:	8b 30                	mov    (%eax),%esi
   12b80:	8b 45 08             	mov    0x8(%ebp),%eax
   12b83:	8b 58 04             	mov    0x4(%eax),%ebx
   12b86:	8b 45 08             	mov    0x8(%ebp),%eax
   12b89:	8b 48 08             	mov    0x8(%eax),%ecx
   12b8c:	8b 45 08             	mov    0x8(%ebp),%eax
   12b8f:	8b 50 0c             	mov    0xc(%eax),%edx
   12b92:	8b 45 08             	mov    0x8(%ebp),%eax
   12b95:	8b 40 3c             	mov    0x3c(%eax),%eax
   12b98:	83 ec 04             	sub    $0x4,%esp
   12b9b:	56                   	push   %esi
   12b9c:	53                   	push   %ebx
   12b9d:	ff 75 e0             	pushl  -0x20(%ebp)
   12ba0:	51                   	push   %ecx
   12ba1:	52                   	push   %edx
   12ba2:	50                   	push   %eax
   12ba3:	68 04 95 01 00       	push   $0x19504
   12ba8:	e8 9f 63 00 00       	call   18f4c <log_printf>
   12bad:	83 c4 20             	add    $0x20,%esp
               frame->cs, frame->ds, frame->es, ss, frame->fs, frame->gs
    );
    log_printf("EAX:0x%x\n"
   12bb0:	8b 45 08             	mov    0x8(%ebp),%eax
   12bb3:	8b 40 18             	mov    0x18(%eax),%eax
   12bb6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   12bb9:	8b 45 08             	mov    0x8(%ebp),%eax
   12bbc:	8b 78 14             	mov    0x14(%eax),%edi
   12bbf:	8b 45 08             	mov    0x8(%ebp),%eax
   12bc2:	8b 70 10             	mov    0x10(%eax),%esi
   12bc5:	8b 45 08             	mov    0x8(%ebp),%eax
   12bc8:	8b 58 24             	mov    0x24(%eax),%ebx
   12bcb:	8b 45 08             	mov    0x8(%ebp),%eax
   12bce:	8b 48 28             	mov    0x28(%eax),%ecx
   12bd1:	8b 45 08             	mov    0x8(%ebp),%eax
   12bd4:	8b 50 20             	mov    0x20(%eax),%edx
   12bd7:	8b 45 08             	mov    0x8(%ebp),%eax
   12bda:	8b 40 2c             	mov    0x2c(%eax),%eax
   12bdd:	83 ec 0c             	sub    $0xc,%esp
   12be0:	ff 75 e4             	pushl  -0x1c(%ebp)
   12be3:	ff 75 d4             	pushl  -0x2c(%ebp)
   12be6:	57                   	push   %edi
   12be7:	56                   	push   %esi
   12be8:	53                   	push   %ebx
   12be9:	51                   	push   %ecx
   12bea:	52                   	push   %edx
   12beb:	50                   	push   %eax
   12bec:	68 2c 95 01 00       	push   $0x1952c
   12bf1:	e8 56 63 00 00       	call   18f4c <log_printf>
   12bf6:	83 c4 30             	add    $0x30,%esp
                "ESI:0x%x\n"
                "EBP:0x%x\n"
                "ESP:0x%x\n",
               frame->eax, frame->ebx, frame->ecx, frame->edx,
               frame->edi, frame->esi, frame->ebp, esp);
    log_printf("EIP:0x%x\nEFLAGS:0x%x\n", frame->eip, frame->eflags);
   12bf9:	8b 45 08             	mov    0x8(%ebp),%eax
   12bfc:	8b 50 40             	mov    0x40(%eax),%edx
   12bff:	8b 45 08             	mov    0x8(%ebp),%eax
   12c02:	8b 40 38             	mov    0x38(%eax),%eax
   12c05:	83 ec 04             	sub    $0x4,%esp
   12c08:	52                   	push   %edx
   12c09:	50                   	push   %eax
   12c0a:	68 75 95 01 00       	push   $0x19575
   12c0f:	e8 38 63 00 00       	call   18f4c <log_printf>
   12c14:	83 c4 10             	add    $0x10,%esp
}
   12c17:	90                   	nop
   12c18:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12c1b:	5b                   	pop    %ebx
   12c1c:	5e                   	pop    %esi
   12c1d:	5f                   	pop    %edi
   12c1e:	5d                   	pop    %ebp
   12c1f:	c3                   	ret    

00012c20 <do_default_handler>:

static void do_default_handler (exception_frame_t * frame, const char * message) {
   12c20:	55                   	push   %ebp
   12c21:	89 e5                	mov    %esp,%ebp
   12c23:	83 ec 08             	sub    $0x8,%esp
    log_printf("--------------------------------");
   12c26:	83 ec 0c             	sub    $0xc,%esp
   12c29:	68 8c 95 01 00       	push   $0x1958c
   12c2e:	e8 19 63 00 00       	call   18f4c <log_printf>
   12c33:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: %s.", message);
   12c36:	83 ec 08             	sub    $0x8,%esp
   12c39:	ff 75 0c             	pushl  0xc(%ebp)
   12c3c:	68 ad 95 01 00       	push   $0x195ad
   12c41:	e8 06 63 00 00       	call   18f4c <log_printf>
   12c46:	83 c4 10             	add    $0x10,%esp
    dump_core_regs(frame);
   12c49:	83 ec 0c             	sub    $0xc,%esp
   12c4c:	ff 75 08             	pushl  0x8(%ebp)
   12c4f:	e8 cd fe ff ff       	call   12b21 <dump_core_regs>
   12c54:	83 c4 10             	add    $0x10,%esp
    
    // todo: 留等以后补充打印任务栈的内容

    log_printf("--------------------------------");
   12c57:	83 ec 0c             	sub    $0xc,%esp
   12c5a:	68 8c 95 01 00       	push   $0x1958c
   12c5f:	e8 e8 62 00 00       	call   18f4c <log_printf>
   12c64:	83 c4 10             	add    $0x10,%esp
    if(frame->cs & 0x3)
   12c67:	8b 45 08             	mov    0x8(%ebp),%eax
   12c6a:	8b 40 3c             	mov    0x3c(%eax),%eax
   12c6d:	83 e0 03             	and    $0x3,%eax
   12c70:	85 c0                	test   %eax,%eax
   12c72:	74 14                	je     12c88 <do_default_handler+0x68>
    {
        sys_exit(frame->with_err_num);
   12c74:	8b 45 08             	mov    0x8(%ebp),%eax
   12c77:	8b 40 34             	mov    0x34(%eax),%eax
   12c7a:	83 ec 0c             	sub    $0xc,%esp
   12c7d:	50                   	push   %eax
   12c7e:	e8 05 f9 ff ff       	call   12588 <sys_exit>
   12c83:	83 c4 10             	add    $0x10,%esp
    else{
        while (1) {
        hlt();
        }
    }
}
   12c86:	eb 07                	jmp    12c8f <do_default_handler+0x6f>
        hlt();
   12c88:	e8 43 fd ff ff       	call   129d0 <hlt>
   12c8d:	eb f9                	jmp    12c88 <do_default_handler+0x68>
}
   12c8f:	c9                   	leave  
   12c90:	c3                   	ret    

00012c91 <irq_install>:

int irq_install(int irq_num, irq_handler_t handler )
{
   12c91:	55                   	push   %ebp
   12c92:	89 e5                	mov    %esp,%ebp
   12c94:	83 ec 08             	sub    $0x8,%esp
    if(irq_num >= IDT_TABLE_NM)
   12c97:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   12c9b:	7e 07                	jle    12ca4 <irq_install+0x13>
        return -1;
   12c9d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12ca2:	eb 25                	jmp    12cc9 <irq_install+0x38>
    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, 
   12ca4:	8b 45 0c             	mov    0xc(%ebp),%eax
   12ca7:	8b 55 08             	mov    0x8(%ebp),%edx
   12caa:	c1 e2 03             	shl    $0x3,%edx
   12cad:	81 c2 40 5c 03 00    	add    $0x35c40,%edx
   12cb3:	68 00 8e 00 00       	push   $0x8e00
   12cb8:	50                   	push   %eax
   12cb9:	6a 08                	push   $0x8
   12cbb:	52                   	push   %edx
   12cbc:	e8 d6 fa ff ff       	call   12797 <gate_desc_set>
   12cc1:	83 c4 10             	add    $0x10,%esp
    (uint32_t)handler, GATE_DPL0 | GATE_P_PRESENT | GATE_TYPE_INT);
    return 0;
   12cc4:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12cc9:	c9                   	leave  
   12cca:	c3                   	ret    

00012ccb <do_handler_unknown>:


void do_handler_unknown (exception_frame_t * frame) {
   12ccb:	55                   	push   %ebp
   12ccc:	89 e5                	mov    %esp,%ebp
   12cce:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Unknown exception.");
   12cd1:	83 ec 08             	sub    $0x8,%esp
   12cd4:	68 c8 95 01 00       	push   $0x195c8
   12cd9:	ff 75 08             	pushl  0x8(%ebp)
   12cdc:	e8 3f ff ff ff       	call   12c20 <do_default_handler>
   12ce1:	83 c4 10             	add    $0x10,%esp
}
   12ce4:	90                   	nop
   12ce5:	c9                   	leave  
   12ce6:	c3                   	ret    

00012ce7 <do_handler_divider0>:

void do_handler_divider0(exception_frame_t * frame) {
   12ce7:	55                   	push   %ebp
   12ce8:	89 e5                	mov    %esp,%ebp
   12cea:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Device Error.");
   12ced:	83 ec 08             	sub    $0x8,%esp
   12cf0:	68 db 95 01 00       	push   $0x195db
   12cf5:	ff 75 08             	pushl  0x8(%ebp)
   12cf8:	e8 23 ff ff ff       	call   12c20 <do_default_handler>
   12cfd:	83 c4 10             	add    $0x10,%esp
}
   12d00:	90                   	nop
   12d01:	c9                   	leave  
   12d02:	c3                   	ret    

00012d03 <do_handler_Debug>:

void do_handler_Debug(exception_frame_t * frame) {
   12d03:	55                   	push   %ebp
   12d04:	89 e5                	mov    %esp,%ebp
   12d06:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Debug Exception");
   12d09:	83 ec 08             	sub    $0x8,%esp
   12d0c:	68 e9 95 01 00       	push   $0x195e9
   12d11:	ff 75 08             	pushl  0x8(%ebp)
   12d14:	e8 07 ff ff ff       	call   12c20 <do_default_handler>
   12d19:	83 c4 10             	add    $0x10,%esp
}
   12d1c:	90                   	nop
   12d1d:	c9                   	leave  
   12d1e:	c3                   	ret    

00012d1f <do_handler_NMI>:

void do_handler_NMI(exception_frame_t * frame) {
   12d1f:	55                   	push   %ebp
   12d20:	89 e5                	mov    %esp,%ebp
   12d22:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "NMI Interrupt.");
   12d25:	83 ec 08             	sub    $0x8,%esp
   12d28:	68 f9 95 01 00       	push   $0x195f9
   12d2d:	ff 75 08             	pushl  0x8(%ebp)
   12d30:	e8 eb fe ff ff       	call   12c20 <do_default_handler>
   12d35:	83 c4 10             	add    $0x10,%esp
}
   12d38:	90                   	nop
   12d39:	c9                   	leave  
   12d3a:	c3                   	ret    

00012d3b <do_handler_breakpoint>:

void do_handler_breakpoint(exception_frame_t * frame) {
   12d3b:	55                   	push   %ebp
   12d3c:	89 e5                	mov    %esp,%ebp
   12d3e:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Breakpoint.");
   12d41:	83 ec 08             	sub    $0x8,%esp
   12d44:	68 08 96 01 00       	push   $0x19608
   12d49:	ff 75 08             	pushl  0x8(%ebp)
   12d4c:	e8 cf fe ff ff       	call   12c20 <do_default_handler>
   12d51:	83 c4 10             	add    $0x10,%esp
}
   12d54:	90                   	nop
   12d55:	c9                   	leave  
   12d56:	c3                   	ret    

00012d57 <do_handler_overflow>:

void do_handler_overflow(exception_frame_t * frame) {
   12d57:	55                   	push   %ebp
   12d58:	89 e5                	mov    %esp,%ebp
   12d5a:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Overflow.");
   12d5d:	83 ec 08             	sub    $0x8,%esp
   12d60:	68 14 96 01 00       	push   $0x19614
   12d65:	ff 75 08             	pushl  0x8(%ebp)
   12d68:	e8 b3 fe ff ff       	call   12c20 <do_default_handler>
   12d6d:	83 c4 10             	add    $0x10,%esp
}
   12d70:	90                   	nop
   12d71:	c9                   	leave  
   12d72:	c3                   	ret    

00012d73 <do_handler_bound_range>:

void do_handler_bound_range(exception_frame_t * frame) {
   12d73:	55                   	push   %ebp
   12d74:	89 e5                	mov    %esp,%ebp
   12d76:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "BOUND Range Exceeded.");
   12d79:	83 ec 08             	sub    $0x8,%esp
   12d7c:	68 1e 96 01 00       	push   $0x1961e
   12d81:	ff 75 08             	pushl  0x8(%ebp)
   12d84:	e8 97 fe ff ff       	call   12c20 <do_default_handler>
   12d89:	83 c4 10             	add    $0x10,%esp
}
   12d8c:	90                   	nop
   12d8d:	c9                   	leave  
   12d8e:	c3                   	ret    

00012d8f <do_handler_invalid_opcode>:

void do_handler_invalid_opcode(exception_frame_t * frame) {
   12d8f:	55                   	push   %ebp
   12d90:	89 e5                	mov    %esp,%ebp
   12d92:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid Opcode.");
   12d95:	83 ec 08             	sub    $0x8,%esp
   12d98:	68 34 96 01 00       	push   $0x19634
   12d9d:	ff 75 08             	pushl  0x8(%ebp)
   12da0:	e8 7b fe ff ff       	call   12c20 <do_default_handler>
   12da5:	83 c4 10             	add    $0x10,%esp
}
   12da8:	90                   	nop
   12da9:	c9                   	leave  
   12daa:	c3                   	ret    

00012dab <do_handler_device_unavailable>:

void do_handler_device_unavailable(exception_frame_t * frame) {
   12dab:	55                   	push   %ebp
   12dac:	89 e5                	mov    %esp,%ebp
   12dae:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Device Not Available.");
   12db1:	83 ec 08             	sub    $0x8,%esp
   12db4:	68 44 96 01 00       	push   $0x19644
   12db9:	ff 75 08             	pushl  0x8(%ebp)
   12dbc:	e8 5f fe ff ff       	call   12c20 <do_default_handler>
   12dc1:	83 c4 10             	add    $0x10,%esp
}
   12dc4:	90                   	nop
   12dc5:	c9                   	leave  
   12dc6:	c3                   	ret    

00012dc7 <do_handler_double_fault>:

void do_handler_double_fault(exception_frame_t * frame) {
   12dc7:	55                   	push   %ebp
   12dc8:	89 e5                	mov    %esp,%ebp
   12dca:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Double Fault.");
   12dcd:	83 ec 08             	sub    $0x8,%esp
   12dd0:	68 5a 96 01 00       	push   $0x1965a
   12dd5:	ff 75 08             	pushl  0x8(%ebp)
   12dd8:	e8 43 fe ff ff       	call   12c20 <do_default_handler>
   12ddd:	83 c4 10             	add    $0x10,%esp
}
   12de0:	90                   	nop
   12de1:	c9                   	leave  
   12de2:	c3                   	ret    

00012de3 <do_handler_invalid_tss>:

void do_handler_invalid_tss(exception_frame_t * frame) {
   12de3:	55                   	push   %ebp
   12de4:	89 e5                	mov    %esp,%ebp
   12de6:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Invalid TSS");
   12de9:	83 ec 08             	sub    $0x8,%esp
   12dec:	68 68 96 01 00       	push   $0x19668
   12df1:	ff 75 08             	pushl  0x8(%ebp)
   12df4:	e8 27 fe ff ff       	call   12c20 <do_default_handler>
   12df9:	83 c4 10             	add    $0x10,%esp
}
   12dfc:	90                   	nop
   12dfd:	c9                   	leave  
   12dfe:	c3                   	ret    

00012dff <do_handler_segment_not_present>:

void do_handler_segment_not_present(exception_frame_t * frame) {
   12dff:	55                   	push   %ebp
   12e00:	89 e5                	mov    %esp,%ebp
   12e02:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Segment Not Present.");
   12e05:	83 ec 08             	sub    $0x8,%esp
   12e08:	68 74 96 01 00       	push   $0x19674
   12e0d:	ff 75 08             	pushl  0x8(%ebp)
   12e10:	e8 0b fe ff ff       	call   12c20 <do_default_handler>
   12e15:	83 c4 10             	add    $0x10,%esp
}
   12e18:	90                   	nop
   12e19:	c9                   	leave  
   12e1a:	c3                   	ret    

00012e1b <do_handler_stack_segment_fault>:

void do_handler_stack_segment_fault(exception_frame_t * frame) {
   12e1b:	55                   	push   %ebp
   12e1c:	89 e5                	mov    %esp,%ebp
   12e1e:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Stack-Segment Fault.");
   12e21:	83 ec 08             	sub    $0x8,%esp
   12e24:	68 89 96 01 00       	push   $0x19689
   12e29:	ff 75 08             	pushl  0x8(%ebp)
   12e2c:	e8 ef fd ff ff       	call   12c20 <do_default_handler>
   12e31:	83 c4 10             	add    $0x10,%esp
}
   12e34:	90                   	nop
   12e35:	c9                   	leave  
   12e36:	c3                   	ret    

00012e37 <do_handler_general_protection>:

void do_handler_general_protection(exception_frame_t * frame) {
   12e37:	55                   	push   %ebp
   12e38:	89 e5                	mov    %esp,%ebp
   12e3a:	83 ec 08             	sub    $0x8,%esp
    log_printf("--------------------------------");
   12e3d:	83 ec 0c             	sub    $0xc,%esp
   12e40:	68 8c 95 01 00       	push   $0x1958c
   12e45:	e8 02 61 00 00       	call   18f4c <log_printf>
   12e4a:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: General Protection.");
   12e4d:	83 ec 0c             	sub    $0xc,%esp
   12e50:	68 a0 96 01 00       	push   $0x196a0
   12e55:	e8 f2 60 00 00       	call   18f4c <log_printf>
   12e5a:	83 c4 10             	add    $0x10,%esp
    if (frame->with_err_num & ERR_EXT) {
   12e5d:	8b 45 08             	mov    0x8(%ebp),%eax
   12e60:	8b 40 34             	mov    0x34(%eax),%eax
   12e63:	83 e0 01             	and    $0x1,%eax
   12e66:	85 c0                	test   %eax,%eax
   12e68:	74 12                	je     12e7c <do_handler_general_protection+0x45>
        log_printf("the exception occurred during delivery of an "
   12e6a:	83 ec 0c             	sub    $0xc,%esp
   12e6d:	68 cc 96 01 00       	push   $0x196cc
   12e72:	e8 d5 60 00 00       	call   18f4c <log_printf>
   12e77:	83 c4 10             	add    $0x10,%esp
   12e7a:	eb 10                	jmp    12e8c <do_handler_general_protection+0x55>
                "event external to the program, such as an interrupt"
                "or an earlier exception.");
    } else {
        log_printf("the exception occurred during delivery of a"
   12e7c:	83 ec 0c             	sub    $0xc,%esp
   12e7f:	68 48 97 01 00       	push   $0x19748
   12e84:	e8 c3 60 00 00       	call   18f4c <log_printf>
   12e89:	83 c4 10             	add    $0x10,%esp
                    "software interrupt (INT n, INT3, or INTO).");
    }
    
    if (frame->with_err_num & ERR_IDT) {
   12e8c:	8b 45 08             	mov    0x8(%ebp),%eax
   12e8f:	8b 40 34             	mov    0x34(%eax),%eax
   12e92:	83 e0 02             	and    $0x2,%eax
   12e95:	85 c0                	test   %eax,%eax
   12e97:	74 12                	je     12eab <do_handler_general_protection+0x74>
        log_printf("the index portion of the error code refers "
   12e99:	83 ec 0c             	sub    $0xc,%esp
   12e9c:	68 a0 97 01 00       	push   $0x197a0
   12ea1:	e8 a6 60 00 00       	call   18f4c <log_printf>
   12ea6:	83 c4 10             	add    $0x10,%esp
   12ea9:	eb 10                	jmp    12ebb <do_handler_general_protection+0x84>
                    "to a gate descriptor in the IDT");
    } else {
        log_printf("the index refers to a descriptor in the GDT");
   12eab:	83 ec 0c             	sub    $0xc,%esp
   12eae:	68 ec 97 01 00       	push   $0x197ec
   12eb3:	e8 94 60 00 00       	call   18f4c <log_printf>
   12eb8:	83 c4 10             	add    $0x10,%esp
    }
    
    log_printf("segment index: %d", frame->with_err_num & 0xFFF8);
   12ebb:	8b 45 08             	mov    0x8(%ebp),%eax
   12ebe:	8b 40 34             	mov    0x34(%eax),%eax
   12ec1:	25 f8 ff 00 00       	and    $0xfff8,%eax
   12ec6:	83 ec 08             	sub    $0x8,%esp
   12ec9:	50                   	push   %eax
   12eca:	68 18 98 01 00       	push   $0x19818
   12ecf:	e8 78 60 00 00       	call   18f4c <log_printf>
   12ed4:	83 c4 10             	add    $0x10,%esp

    dump_core_regs(frame);
   12ed7:	83 ec 0c             	sub    $0xc,%esp
   12eda:	ff 75 08             	pushl  0x8(%ebp)
   12edd:	e8 3f fc ff ff       	call   12b21 <dump_core_regs>
   12ee2:	83 c4 10             	add    $0x10,%esp
    if(frame->cs & 0x3)
   12ee5:	8b 45 08             	mov    0x8(%ebp),%eax
   12ee8:	8b 40 3c             	mov    0x3c(%eax),%eax
   12eeb:	83 e0 03             	and    $0x3,%eax
   12eee:	85 c0                	test   %eax,%eax
   12ef0:	74 14                	je     12f06 <do_handler_general_protection+0xcf>
    {
        sys_exit(frame->with_err_num);
   12ef2:	8b 45 08             	mov    0x8(%ebp),%eax
   12ef5:	8b 40 34             	mov    0x34(%eax),%eax
   12ef8:	83 ec 0c             	sub    $0xc,%esp
   12efb:	50                   	push   %eax
   12efc:	e8 87 f6 ff ff       	call   12588 <sys_exit>
   12f01:	83 c4 10             	add    $0x10,%esp
    else{
        while (1) {
        hlt();
        }
    }	
}
   12f04:	eb 07                	jmp    12f0d <do_handler_general_protection+0xd6>
        hlt();
   12f06:	e8 c5 fa ff ff       	call   129d0 <hlt>
   12f0b:	eb f9                	jmp    12f06 <do_handler_general_protection+0xcf>
}
   12f0d:	c9                   	leave  
   12f0e:	c3                   	ret    

00012f0f <do_handler_page_fault>:

void do_handler_page_fault(exception_frame_t * frame) {
   12f0f:	55                   	push   %ebp
   12f10:	89 e5                	mov    %esp,%ebp
   12f12:	83 ec 08             	sub    $0x8,%esp
    log_printf("--------------------------------");
   12f15:	83 ec 0c             	sub    $0xc,%esp
   12f18:	68 8c 95 01 00       	push   $0x1958c
   12f1d:	e8 2a 60 00 00       	call   18f4c <log_printf>
   12f22:	83 c4 10             	add    $0x10,%esp
    log_printf("IRQ/Exception happend: Page fault.");
   12f25:	83 ec 0c             	sub    $0xc,%esp
   12f28:	68 2c 98 01 00       	push   $0x1982c
   12f2d:	e8 1a 60 00 00       	call   18f4c <log_printf>
   12f32:	83 c4 10             	add    $0x10,%esp
    if (frame->with_err_num & ERR_PAGE_P) {
   12f35:	8b 45 08             	mov    0x8(%ebp),%eax
   12f38:	8b 40 34             	mov    0x34(%eax),%eax
   12f3b:	83 e0 01             	and    $0x1,%eax
   12f3e:	85 c0                	test   %eax,%eax
   12f40:	74 18                	je     12f5a <do_handler_page_fault+0x4b>
        log_printf("\tpage-level protection violation: 0x%x.", read_cr2());
   12f42:	e8 78 fa ff ff       	call   129bf <read_cr2>
   12f47:	83 ec 08             	sub    $0x8,%esp
   12f4a:	50                   	push   %eax
   12f4b:	68 50 98 01 00       	push   $0x19850
   12f50:	e8 f7 5f 00 00       	call   18f4c <log_printf>
   12f55:	83 c4 10             	add    $0x10,%esp
   12f58:	eb 16                	jmp    12f70 <do_handler_page_fault+0x61>
    } else {
         log_printf("\tPage doesn't present 0x%x", read_cr2());
   12f5a:	e8 60 fa ff ff       	call   129bf <read_cr2>
   12f5f:	83 ec 08             	sub    $0x8,%esp
   12f62:	50                   	push   %eax
   12f63:	68 78 98 01 00       	push   $0x19878
   12f68:	e8 df 5f 00 00       	call   18f4c <log_printf>
   12f6d:	83 c4 10             	add    $0x10,%esp
   }
    
    if (frame->with_err_num & ERR_PAGE_WR) {
   12f70:	8b 45 08             	mov    0x8(%ebp),%eax
   12f73:	8b 40 34             	mov    0x34(%eax),%eax
   12f76:	83 e0 02             	and    $0x2,%eax
   12f79:	85 c0                	test   %eax,%eax
   12f7b:	74 12                	je     12f8f <do_handler_page_fault+0x80>
        log_printf("\tThe access causing the fault was a read.");
   12f7d:	83 ec 0c             	sub    $0xc,%esp
   12f80:	68 94 98 01 00       	push   $0x19894
   12f85:	e8 c2 5f 00 00       	call   18f4c <log_printf>
   12f8a:	83 c4 10             	add    $0x10,%esp
   12f8d:	eb 10                	jmp    12f9f <do_handler_page_fault+0x90>
    } else {
        log_printf("\tThe access causing the fault was a write.");
   12f8f:	83 ec 0c             	sub    $0xc,%esp
   12f92:	68 c0 98 01 00       	push   $0x198c0
   12f97:	e8 b0 5f 00 00       	call   18f4c <log_printf>
   12f9c:	83 c4 10             	add    $0x10,%esp
    }
    
    if (frame->with_err_num & ERR_PAGE_US) {
   12f9f:	8b 45 08             	mov    0x8(%ebp),%eax
   12fa2:	8b 40 34             	mov    0x34(%eax),%eax
   12fa5:	83 e0 04             	and    $0x4,%eax
   12fa8:	85 c0                	test   %eax,%eax
   12faa:	74 12                	je     12fbe <do_handler_page_fault+0xaf>
        log_printf("\tA supervisor-mode access caused the fault.");
   12fac:	83 ec 0c             	sub    $0xc,%esp
   12faf:	68 ec 98 01 00       	push   $0x198ec
   12fb4:	e8 93 5f 00 00       	call   18f4c <log_printf>
   12fb9:	83 c4 10             	add    $0x10,%esp
   12fbc:	eb 10                	jmp    12fce <do_handler_page_fault+0xbf>
    } else {
        log_printf("\tA user-mode access caused the fault.");
   12fbe:	83 ec 0c             	sub    $0xc,%esp
   12fc1:	68 18 99 01 00       	push   $0x19918
   12fc6:	e8 81 5f 00 00       	call   18f4c <log_printf>
   12fcb:	83 c4 10             	add    $0x10,%esp
    }

    dump_core_regs(frame);
   12fce:	83 ec 0c             	sub    $0xc,%esp
   12fd1:	ff 75 08             	pushl  0x8(%ebp)
   12fd4:	e8 48 fb ff ff       	call   12b21 <dump_core_regs>
   12fd9:	83 c4 10             	add    $0x10,%esp
    if(frame->cs & 0x3)
   12fdc:	8b 45 08             	mov    0x8(%ebp),%eax
   12fdf:	8b 40 3c             	mov    0x3c(%eax),%eax
   12fe2:	83 e0 03             	and    $0x3,%eax
   12fe5:	85 c0                	test   %eax,%eax
   12fe7:	74 14                	je     12ffd <do_handler_page_fault+0xee>
    {
        sys_exit(frame->with_err_num);
   12fe9:	8b 45 08             	mov    0x8(%ebp),%eax
   12fec:	8b 40 34             	mov    0x34(%eax),%eax
   12fef:	83 ec 0c             	sub    $0xc,%esp
   12ff2:	50                   	push   %eax
   12ff3:	e8 90 f5 ff ff       	call   12588 <sys_exit>
   12ff8:	83 c4 10             	add    $0x10,%esp
        while (1) {
        hlt();
        }
    }
    
}
   12ffb:	eb 07                	jmp    13004 <do_handler_page_fault+0xf5>
        hlt();
   12ffd:	e8 ce f9 ff ff       	call   129d0 <hlt>
   13002:	eb f9                	jmp    12ffd <do_handler_page_fault+0xee>
}
   13004:	c9                   	leave  
   13005:	c3                   	ret    

00013006 <do_handler_fpu_error>:
void do_handler_fpu_error(exception_frame_t * frame) {
   13006:	55                   	push   %ebp
   13007:	89 e5                	mov    %esp,%ebp
   13009:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "X87 FPU Floating Point Error.");
   1300c:	83 ec 08             	sub    $0x8,%esp
   1300f:	68 3e 99 01 00       	push   $0x1993e
   13014:	ff 75 08             	pushl  0x8(%ebp)
   13017:	e8 04 fc ff ff       	call   12c20 <do_default_handler>
   1301c:	83 c4 10             	add    $0x10,%esp
}
   1301f:	90                   	nop
   13020:	c9                   	leave  
   13021:	c3                   	ret    

00013022 <do_handler_alignment_check>:

void do_handler_alignment_check(exception_frame_t * frame) {
   13022:	55                   	push   %ebp
   13023:	89 e5                	mov    %esp,%ebp
   13025:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Alignment Check.");
   13028:	83 ec 08             	sub    $0x8,%esp
   1302b:	68 5c 99 01 00       	push   $0x1995c
   13030:	ff 75 08             	pushl  0x8(%ebp)
   13033:	e8 e8 fb ff ff       	call   12c20 <do_default_handler>
   13038:	83 c4 10             	add    $0x10,%esp
}
   1303b:	90                   	nop
   1303c:	c9                   	leave  
   1303d:	c3                   	ret    

0001303e <do_handler_machine_check>:

void do_handler_machine_check(exception_frame_t * frame) {
   1303e:	55                   	push   %ebp
   1303f:	89 e5                	mov    %esp,%ebp
   13041:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Machine Check.");
   13044:	83 ec 08             	sub    $0x8,%esp
   13047:	68 6d 99 01 00       	push   $0x1996d
   1304c:	ff 75 08             	pushl  0x8(%ebp)
   1304f:	e8 cc fb ff ff       	call   12c20 <do_default_handler>
   13054:	83 c4 10             	add    $0x10,%esp
}
   13057:	90                   	nop
   13058:	c9                   	leave  
   13059:	c3                   	ret    

0001305a <do_handler_smd_exception>:

void do_handler_smd_exception(exception_frame_t * frame) {
   1305a:	55                   	push   %ebp
   1305b:	89 e5                	mov    %esp,%ebp
   1305d:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "SIMD Floating Point Exception.");
   13060:	83 ec 08             	sub    $0x8,%esp
   13063:	68 7c 99 01 00       	push   $0x1997c
   13068:	ff 75 08             	pushl  0x8(%ebp)
   1306b:	e8 b0 fb ff ff       	call   12c20 <do_default_handler>
   13070:	83 c4 10             	add    $0x10,%esp
}
   13073:	90                   	nop
   13074:	c9                   	leave  
   13075:	c3                   	ret    

00013076 <do_handler_virtual_exception>:

void do_handler_virtual_exception(exception_frame_t * frame) {
   13076:	55                   	push   %ebp
   13077:	89 e5                	mov    %esp,%ebp
   13079:	83 ec 08             	sub    $0x8,%esp
	do_default_handler(frame, "Virtualization Exception.");
   1307c:	83 ec 08             	sub    $0x8,%esp
   1307f:	68 9b 99 01 00       	push   $0x1999b
   13084:	ff 75 08             	pushl  0x8(%ebp)
   13087:	e8 94 fb ff ff       	call   12c20 <do_default_handler>
   1308c:	83 c4 10             	add    $0x10,%esp
}
   1308f:	90                   	nop
   13090:	c9                   	leave  
   13091:	c3                   	ret    

00013092 <init_pic>:

static void init_pic(void) {
   13092:	55                   	push   %ebp
   13093:	89 e5                	mov    %esp,%ebp
    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   13095:	6a 11                	push   $0x11
   13097:	6a 20                	push   $0x20
   13099:	e8 cc f8 ff ff       	call   1296a <outb>
   1309e:	83 c4 08             	add    $0x8,%esp

    // 对应的中断号起始序号0x20
    outb(PIC0_ICW2, IRQ_PIC_START);
   130a1:	6a 20                	push   $0x20
   130a3:	6a 21                	push   $0x21
   130a5:	e8 c0 f8 ff ff       	call   1296a <outb>
   130aa:	83 c4 08             	add    $0x8,%esp

    // 主片IRQ2有从片
    outb(PIC0_ICW3, 1 << 2);
   130ad:	6a 04                	push   $0x4
   130af:	6a 21                	push   $0x21
   130b1:	e8 b4 f8 ff ff       	call   1296a <outb>
   130b6:	83 c4 08             	add    $0x8,%esp

    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC0_ICW4, PIC_ICW4_8086);
   130b9:	6a 01                	push   $0x1
   130bb:	6a 21                	push   $0x21
   130bd:	e8 a8 f8 ff ff       	call   1296a <outb>
   130c2:	83 c4 08             	add    $0x8,%esp

    // 边缘触发，级联，需要配置icw4, 8086模式
    outb(PIC1_ICW1, PIC_ICW1_ICW4 | PIC_ICW1_ALWAYS_1);
   130c5:	6a 11                	push   $0x11
   130c7:	68 a0 00 00 00       	push   $0xa0
   130cc:	e8 99 f8 ff ff       	call   1296a <outb>
   130d1:	83 c4 08             	add    $0x8,%esp

    // 起始中断序号，要加上8
    outb(PIC1_ICW2, IRQ_PIC_START + 8);
   130d4:	6a 28                	push   $0x28
   130d6:	68 a1 00 00 00       	push   $0xa1
   130db:	e8 8a f8 ff ff       	call   1296a <outb>
   130e0:	83 c4 08             	add    $0x8,%esp

    // 没有从片，连接到主片的IRQ2上
    outb(PIC1_ICW3, 2);
   130e3:	6a 02                	push   $0x2
   130e5:	68 a1 00 00 00       	push   $0xa1
   130ea:	e8 7b f8 ff ff       	call   1296a <outb>
   130ef:	83 c4 08             	add    $0x8,%esp

    // 普通全嵌套、非缓冲、非自动结束、8086模式
    outb(PIC1_ICW4, PIC_ICW4_8086);
   130f2:	6a 01                	push   $0x1
   130f4:	68 a1 00 00 00       	push   $0xa1
   130f9:	e8 6c f8 ff ff       	call   1296a <outb>
   130fe:	83 c4 08             	add    $0x8,%esp

    // 禁止所有中断, 允许从PIC1传来的中断
    outb(PIC0_IMR, 0xFF & ~(1 << 2));
   13101:	68 fb 00 00 00       	push   $0xfb
   13106:	6a 21                	push   $0x21
   13108:	e8 5d f8 ff ff       	call   1296a <outb>
   1310d:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_IMR, 0xFF);
   13110:	68 ff 00 00 00       	push   $0xff
   13115:	68 a1 00 00 00       	push   $0xa1
   1311a:	e8 4b f8 ff ff       	call   1296a <outb>
   1311f:	83 c4 08             	add    $0x8,%esp
}
   13122:	90                   	nop
   13123:	c9                   	leave  
   13124:	c3                   	ret    

00013125 <irq_disable_global>:

void irq_disable_global(void){
   13125:	55                   	push   %ebp
   13126:	89 e5                	mov    %esp,%ebp
    cli();
   13128:	e8 5c f8 ff ff       	call   12989 <cli>
}
   1312d:	90                   	nop
   1312e:	5d                   	pop    %ebp
   1312f:	c3                   	ret    

00013130 <irq_enable_global>:

void irq_enable_global(void){
   13130:	55                   	push   %ebp
   13131:	89 e5                	mov    %esp,%ebp
    sti();
   13133:	e8 58 f8 ff ff       	call   12990 <sti>
}
   13138:	90                   	nop
   13139:	5d                   	pop    %ebp
   1313a:	c3                   	ret    

0001313b <irq_enable>:

void irq_enable(int irq_num){
   1313b:	55                   	push   %ebp
   1313c:	89 e5                	mov    %esp,%ebp
   1313e:	53                   	push   %ebx
   1313f:	83 ec 10             	sub    $0x10,%esp
    if(irq_num < IRQ_PIC_START)
   13142:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   13146:	7e 78                	jle    131c0 <irq_enable+0x85>
        return;
    irq_num -= IRQ_PIC_START;
   13148:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if(irq_num < 8){
   1314c:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   13150:	7f 32                	jg     13184 <irq_enable+0x49>
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
   13152:	6a 21                	push   $0x21
   13154:	e8 d5 f7 ff ff       	call   1292e <inb>
   13159:	83 c4 04             	add    $0x4,%esp
   1315c:	89 c2                	mov    %eax,%edx
   1315e:	8b 45 08             	mov    0x8(%ebp),%eax
   13161:	bb 01 00 00 00       	mov    $0x1,%ebx
   13166:	89 c1                	mov    %eax,%ecx
   13168:	d3 e3                	shl    %cl,%ebx
   1316a:	89 d8                	mov    %ebx,%eax
   1316c:	f7 d0                	not    %eax
   1316e:	21 d0                	and    %edx,%eax
   13170:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   13173:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   13177:	50                   	push   %eax
   13178:	6a 21                	push   $0x21
   1317a:	e8 eb f7 ff ff       	call   1296a <outb>
   1317f:	83 c4 08             	add    $0x8,%esp
   13182:	eb 3d                	jmp    131c1 <irq_enable+0x86>
    }
    else{
        irq_num -= 8;
   13184:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) & ~(1 << irq_num);
   13188:	68 a1 00 00 00       	push   $0xa1
   1318d:	e8 9c f7 ff ff       	call   1292e <inb>
   13192:	83 c4 04             	add    $0x4,%esp
   13195:	89 c2                	mov    %eax,%edx
   13197:	8b 45 08             	mov    0x8(%ebp),%eax
   1319a:	bb 01 00 00 00       	mov    $0x1,%ebx
   1319f:	89 c1                	mov    %eax,%ecx
   131a1:	d3 e3                	shl    %cl,%ebx
   131a3:	89 d8                	mov    %ebx,%eax
   131a5:	f7 d0                	not    %eax
   131a7:	21 d0                	and    %edx,%eax
   131a9:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   131ac:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   131b0:	50                   	push   %eax
   131b1:	68 a1 00 00 00       	push   $0xa1
   131b6:	e8 af f7 ff ff       	call   1296a <outb>
   131bb:	83 c4 08             	add    $0x8,%esp
   131be:	eb 01                	jmp    131c1 <irq_enable+0x86>
        return;
   131c0:	90                   	nop
    } 
    
}
   131c1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   131c4:	c9                   	leave  
   131c5:	c3                   	ret    

000131c6 <irq_disable>:

void irq_disable(int irq_num){
   131c6:	55                   	push   %ebp
   131c7:	89 e5                	mov    %esp,%ebp
   131c9:	53                   	push   %ebx
   131ca:	83 ec 10             	sub    $0x10,%esp
    if(irq_num < IRQ_PIC_START)
   131cd:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   131d1:	7e 74                	jle    13247 <irq_disable+0x81>
        return;
    irq_num -= IRQ_PIC_START;
   131d3:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if(irq_num < 8){
   131d7:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   131db:	7f 30                	jg     1320d <irq_disable+0x47>
        
        uint8_t mask = inb(PIC0_IMR) | (1 << irq_num);
   131dd:	6a 21                	push   $0x21
   131df:	e8 4a f7 ff ff       	call   1292e <inb>
   131e4:	83 c4 04             	add    $0x4,%esp
   131e7:	89 c3                	mov    %eax,%ebx
   131e9:	8b 45 08             	mov    0x8(%ebp),%eax
   131ec:	ba 01 00 00 00       	mov    $0x1,%edx
   131f1:	89 c1                	mov    %eax,%ecx
   131f3:	d3 e2                	shl    %cl,%edx
   131f5:	89 d0                	mov    %edx,%eax
   131f7:	09 d8                	or     %ebx,%eax
   131f9:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   131fc:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   13200:	50                   	push   %eax
   13201:	6a 21                	push   $0x21
   13203:	e8 62 f7 ff ff       	call   1296a <outb>
   13208:	83 c4 08             	add    $0x8,%esp
   1320b:	eb 3b                	jmp    13248 <irq_disable+0x82>
    }
    else{
        irq_num -= 8;
   1320d:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) | (1 << irq_num);
   13211:	68 a1 00 00 00       	push   $0xa1
   13216:	e8 13 f7 ff ff       	call   1292e <inb>
   1321b:	83 c4 04             	add    $0x4,%esp
   1321e:	89 c3                	mov    %eax,%ebx
   13220:	8b 45 08             	mov    0x8(%ebp),%eax
   13223:	ba 01 00 00 00       	mov    $0x1,%edx
   13228:	89 c1                	mov    %eax,%ecx
   1322a:	d3 e2                	shl    %cl,%edx
   1322c:	89 d0                	mov    %edx,%eax
   1322e:	09 d8                	or     %ebx,%eax
   13230:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   13233:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   13237:	50                   	push   %eax
   13238:	68 a1 00 00 00       	push   $0xa1
   1323d:	e8 28 f7 ff ff       	call   1296a <outb>
   13242:	83 c4 08             	add    $0x8,%esp
   13245:	eb 01                	jmp    13248 <irq_disable+0x82>
        return;
   13247:	90                   	nop
    } 
    
}
   13248:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1324b:	c9                   	leave  
   1324c:	c3                   	ret    

0001324d <irq_init>:
void irq_init(void){
   1324d:	55                   	push   %ebp
   1324e:	89 e5                	mov    %esp,%ebp
   13250:	83 ec 18             	sub    $0x18,%esp
    for(int i = 0; i < IDT_TABLE_NM; ++i)
   13253:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1325a:	eb 25                	jmp    13281 <irq_init+0x34>
        gate_desc_set(idt_table + i, KERNEL_SELECTOR_CS,(uint32_t)exception_handler_unknown,
   1325c:	ba 28 00 01 00       	mov    $0x10028,%edx
   13261:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13264:	c1 e0 03             	shl    $0x3,%eax
   13267:	05 40 5c 03 00       	add    $0x35c40,%eax
   1326c:	68 00 8e 00 00       	push   $0x8e00
   13271:	52                   	push   %edx
   13272:	6a 08                	push   $0x8
   13274:	50                   	push   %eax
   13275:	e8 1d f5 ff ff       	call   12797 <gate_desc_set>
   1327a:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < IDT_TABLE_NM; ++i)
   1327d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13281:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%ebp)
   13285:	7e d5                	jle    1325c <irq_init+0xf>
         GATE_DPL0 | GATE_P_PRESENT | GATE_TYPE_INT);
    irq_install(IRQ0_DE, exception_handler_divider0);
   13287:	83 ec 08             	sub    $0x8,%esp
   1328a:	68 45 00 01 00       	push   $0x10045
   1328f:	6a 00                	push   $0x0
   13291:	e8 fb f9 ff ff       	call   12c91 <irq_install>
   13296:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ1_DB, exception_handler_Debug);
   13299:	83 ec 08             	sub    $0x8,%esp
   1329c:	68 62 00 01 00       	push   $0x10062
   132a1:	6a 01                	push   $0x1
   132a3:	e8 e9 f9 ff ff       	call   12c91 <irq_install>
   132a8:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ2_NMI, exception_handler_NMI);
   132ab:	83 ec 08             	sub    $0x8,%esp
   132ae:	68 7f 00 01 00       	push   $0x1007f
   132b3:	6a 02                	push   $0x2
   132b5:	e8 d7 f9 ff ff       	call   12c91 <irq_install>
   132ba:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ3_BP, exception_handler_breakpoint);
   132bd:	83 ec 08             	sub    $0x8,%esp
   132c0:	68 9c 00 01 00       	push   $0x1009c
   132c5:	6a 03                	push   $0x3
   132c7:	e8 c5 f9 ff ff       	call   12c91 <irq_install>
   132cc:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ4_OF, exception_handler_overflow);
   132cf:	83 ec 08             	sub    $0x8,%esp
   132d2:	68 b9 00 01 00       	push   $0x100b9
   132d7:	6a 04                	push   $0x4
   132d9:	e8 b3 f9 ff ff       	call   12c91 <irq_install>
   132de:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ5_BR, exception_handler_bound_range);
   132e1:	83 ec 08             	sub    $0x8,%esp
   132e4:	68 d6 00 01 00       	push   $0x100d6
   132e9:	6a 05                	push   $0x5
   132eb:	e8 a1 f9 ff ff       	call   12c91 <irq_install>
   132f0:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ6_UD, exception_handler_invalid_opcode);
   132f3:	83 ec 08             	sub    $0x8,%esp
   132f6:	68 f3 00 01 00       	push   $0x100f3
   132fb:	6a 06                	push   $0x6
   132fd:	e8 8f f9 ff ff       	call   12c91 <irq_install>
   13302:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ7_NM, exception_handler_device_unavailable);
   13305:	83 ec 08             	sub    $0x8,%esp
   13308:	68 10 01 01 00       	push   $0x10110
   1330d:	6a 07                	push   $0x7
   1330f:	e8 7d f9 ff ff       	call   12c91 <irq_install>
   13314:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ8_DF, exception_handler_double_fault);
   13317:	83 ec 08             	sub    $0x8,%esp
   1331a:	68 2d 01 01 00       	push   $0x1012d
   1331f:	6a 08                	push   $0x8
   13321:	e8 6b f9 ff ff       	call   12c91 <irq_install>
   13326:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ10_TS, exception_handler_invalid_tss);
   13329:	83 ec 08             	sub    $0x8,%esp
   1332c:	68 48 01 01 00       	push   $0x10148
   13331:	6a 0a                	push   $0xa
   13333:	e8 59 f9 ff ff       	call   12c91 <irq_install>
   13338:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ11_NP, exception_handler_segment_not_present);
   1333b:	83 ec 08             	sub    $0x8,%esp
   1333e:	68 63 01 01 00       	push   $0x10163
   13343:	6a 0b                	push   $0xb
   13345:	e8 47 f9 ff ff       	call   12c91 <irq_install>
   1334a:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ12_SS, exception_handler_stack_segment_fault);
   1334d:	83 ec 08             	sub    $0x8,%esp
   13350:	68 7e 01 01 00       	push   $0x1017e
   13355:	6a 0c                	push   $0xc
   13357:	e8 35 f9 ff ff       	call   12c91 <irq_install>
   1335c:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ13_GP, exception_handler_general_protection);
   1335f:	83 ec 08             	sub    $0x8,%esp
   13362:	68 99 01 01 00       	push   $0x10199
   13367:	6a 0d                	push   $0xd
   13369:	e8 23 f9 ff ff       	call   12c91 <irq_install>
   1336e:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ14_PF, exception_handler_page_fault);
   13371:	83 ec 08             	sub    $0x8,%esp
   13374:	68 b4 01 01 00       	push   $0x101b4
   13379:	6a 0e                	push   $0xe
   1337b:	e8 11 f9 ff ff       	call   12c91 <irq_install>
   13380:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ16_MF, exception_handler_fpu_error);
   13383:	83 ec 08             	sub    $0x8,%esp
   13386:	68 cf 01 01 00       	push   $0x101cf
   1338b:	6a 10                	push   $0x10
   1338d:	e8 ff f8 ff ff       	call   12c91 <irq_install>
   13392:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ17_AC, exception_handler_alignment_check);
   13395:	83 ec 08             	sub    $0x8,%esp
   13398:	68 ec 01 01 00       	push   $0x101ec
   1339d:	6a 11                	push   $0x11
   1339f:	e8 ed f8 ff ff       	call   12c91 <irq_install>
   133a4:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ18_MC, exception_handler_machine_check);
   133a7:	83 ec 08             	sub    $0x8,%esp
   133aa:	68 07 02 01 00       	push   $0x10207
   133af:	6a 12                	push   $0x12
   133b1:	e8 db f8 ff ff       	call   12c91 <irq_install>
   133b6:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ19_XM, exception_handler_smd_exception);
   133b9:	83 ec 08             	sub    $0x8,%esp
   133bc:	68 24 02 01 00       	push   $0x10224
   133c1:	6a 13                	push   $0x13
   133c3:	e8 c9 f8 ff ff       	call   12c91 <irq_install>
   133c8:	83 c4 10             	add    $0x10,%esp
	irq_install(IRQ20_VE, exception_handler_virtual_exception);
   133cb:	83 ec 08             	sub    $0x8,%esp
   133ce:	68 41 02 01 00       	push   $0x10241
   133d3:	6a 14                	push   $0x14
   133d5:	e8 b7 f8 ff ff       	call   12c91 <irq_install>
   133da:	83 c4 10             	add    $0x10,%esp
    lidt((uint32_t)idt_table, sizeof(idt_table));
   133dd:	b8 40 5c 03 00       	mov    $0x35c40,%eax
   133e2:	83 ec 08             	sub    $0x8,%esp
   133e5:	68 00 04 00 00       	push   $0x400
   133ea:	50                   	push   %eax
   133eb:	e8 a7 f5 ff ff       	call   12997 <lidt>
   133f0:	83 c4 10             	add    $0x10,%esp
    init_pic();
   133f3:	e8 9a fc ff ff       	call   13092 <init_pic>
}
   133f8:	90                   	nop
   133f9:	c9                   	leave  
   133fa:	c3                   	ret    

000133fb <pic_send_eoi>:

void pic_send_eoi(int irq_num){
   133fb:	55                   	push   %ebp
   133fc:	89 e5                	mov    %esp,%ebp
    irq_num -= IRQ_PIC_START;
   133fe:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if(irq_num >= 8){
   13402:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   13406:	7e 0f                	jle    13417 <pic_send_eoi+0x1c>
        outb(PIC1_OCW2, PIC_OCW2_EOI);
   13408:	6a 20                	push   $0x20
   1340a:	68 a0 00 00 00       	push   $0xa0
   1340f:	e8 56 f5 ff ff       	call   1296a <outb>
   13414:	83 c4 08             	add    $0x8,%esp

    }
    outb(PIC0_OCW2, PIC_OCW2_EOI);
   13417:	6a 20                	push   $0x20
   13419:	6a 20                	push   $0x20
   1341b:	e8 4a f5 ff ff       	call   1296a <outb>
   13420:	83 c4 08             	add    $0x8,%esp
}
   13423:	90                   	nop
   13424:	c9                   	leave  
   13425:	c3                   	ret    

00013426 <enter_protection>:

irq_state_t enter_protection(void)
{
   13426:	55                   	push   %ebp
   13427:	89 e5                	mov    %esp,%ebp
   13429:	83 ec 10             	sub    $0x10,%esp
    irq_state_t state = read_eflags();
   1342c:	e8 a6 f5 ff ff       	call   129d7 <read_eflags>
   13431:	89 45 fc             	mov    %eax,-0x4(%ebp)
    irq_disable_global();
   13434:	e8 ec fc ff ff       	call   13125 <irq_disable_global>
    return state;
   13439:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1343c:	c9                   	leave  
   1343d:	c3                   	ret    

0001343e <leave_protection>:
void leave_protection(irq_state_t state)
{
   1343e:	55                   	push   %ebp
   1343f:	89 e5                	mov    %esp,%ebp
    write_eflags(state);
   13441:	ff 75 08             	pushl  0x8(%ebp)
   13444:	e8 9e f5 ff ff       	call   129e7 <write_eflags>
   13449:	83 c4 04             	add    $0x4,%esp
   1344c:	90                   	nop
   1344d:	c9                   	leave  
   1344e:	c3                   	ret    

0001344f <inb>:
static inline uint8_t inb(uint16_t  port) {
   1344f:	55                   	push   %ebp
   13450:	89 e5                	mov    %esp,%ebp
   13452:	83 ec 14             	sub    $0x14,%esp
   13455:	8b 45 08             	mov    0x8(%ebp),%eax
   13458:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   1345c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   13460:	89 c2                	mov    %eax,%edx
   13462:	ec                   	in     (%dx),%al
   13463:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   13466:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1346a:	c9                   	leave  
   1346b:	c3                   	ret    

0001346c <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   1346c:	55                   	push   %ebp
   1346d:	89 e5                	mov    %esp,%ebp
   1346f:	83 ec 08             	sub    $0x8,%esp
   13472:	8b 55 08             	mov    0x8(%ebp),%edx
   13475:	8b 45 0c             	mov    0xc(%ebp),%eax
   13478:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1347c:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   1347f:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   13483:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   13487:	ee                   	out    %al,(%dx)
}
   13488:	90                   	nop
   13489:	c9                   	leave  
   1348a:	c3                   	ret    

0001348b <read_cursor_pos>:
#include "dev/tty.h"
#include "cpu/irq.h"
#define CONSOLE_NUM         8
static console_t console_buf[CONSOLE_NUM];
static int curr_console_idx = 0;
static int read_cursor_pos (void) {
   1348b:	55                   	push   %ebp
   1348c:	89 e5                	mov    %esp,%ebp
   1348e:	83 ec 18             	sub    $0x18,%esp
    int pos;
    irq_state_t state = enter_protection();
   13491:	e8 90 ff ff ff       	call   13426 <enter_protection>
   13496:	89 45 f4             	mov    %eax,-0xc(%ebp)
 	outb(0x3D4, 0x0F);		
   13499:	83 ec 08             	sub    $0x8,%esp
   1349c:	6a 0f                	push   $0xf
   1349e:	68 d4 03 00 00       	push   $0x3d4
   134a3:	e8 c4 ff ff ff       	call   1346c <outb>
   134a8:	83 c4 10             	add    $0x10,%esp
	pos = inb(0x3D5);
   134ab:	83 ec 0c             	sub    $0xc,%esp
   134ae:	68 d5 03 00 00       	push   $0x3d5
   134b3:	e8 97 ff ff ff       	call   1344f <inb>
   134b8:	83 c4 10             	add    $0x10,%esp
   134bb:	0f b6 c0             	movzbl %al,%eax
   134be:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(0x3D4, 0x0E);		
   134c1:	83 ec 08             	sub    $0x8,%esp
   134c4:	6a 0e                	push   $0xe
   134c6:	68 d4 03 00 00       	push   $0x3d4
   134cb:	e8 9c ff ff ff       	call   1346c <outb>
   134d0:	83 c4 10             	add    $0x10,%esp
	pos |= inb(0x3D5) << 8;
   134d3:	83 ec 0c             	sub    $0xc,%esp
   134d6:	68 d5 03 00 00       	push   $0x3d5
   134db:	e8 6f ff ff ff       	call   1344f <inb>
   134e0:	83 c4 10             	add    $0x10,%esp
   134e3:	0f b6 c0             	movzbl %al,%eax
   134e6:	c1 e0 08             	shl    $0x8,%eax
   134e9:	09 45 f0             	or     %eax,-0x10(%ebp)
    leave_protection(state);   
   134ec:	83 ec 0c             	sub    $0xc,%esp
   134ef:	ff 75 f4             	pushl  -0xc(%ebp)
   134f2:	e8 47 ff ff ff       	call   1343e <leave_protection>
   134f7:	83 c4 10             	add    $0x10,%esp
    return pos;
   134fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   134fd:	c9                   	leave  
   134fe:	c3                   	ret    

000134ff <update_cursor_pos>:

static void update_cursor_pos (console_t * console) {
   134ff:	55                   	push   %ebp
   13500:	89 e5                	mov    %esp,%ebp
   13502:	83 ec 18             	sub    $0x18,%esp
    uint16_t pos = (console - console_buf)*console->disp_col*console->disp_row;
   13505:	8b 45 08             	mov    0x8(%ebp),%eax
   13508:	ba 40 60 03 00       	mov    $0x36040,%edx
   1350d:	29 d0                	sub    %edx,%eax
   1350f:	c1 f8 03             	sar    $0x3,%eax
   13512:	69 c0 c5 4e ec c4    	imul   $0xc4ec4ec5,%eax,%eax
   13518:	89 c2                	mov    %eax,%edx
   1351a:	8b 45 08             	mov    0x8(%ebp),%eax
   1351d:	8b 40 0c             	mov    0xc(%eax),%eax
   13520:	0f af d0             	imul   %eax,%edx
   13523:	8b 45 08             	mov    0x8(%ebp),%eax
   13526:	8b 40 08             	mov    0x8(%eax),%eax
   13529:	0f af c2             	imul   %edx,%eax
   1352c:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	pos += console->cur_row *  console->disp_col + console->cur_col;
   13530:	8b 45 08             	mov    0x8(%ebp),%eax
   13533:	8b 40 10             	mov    0x10(%eax),%eax
   13536:	89 c2                	mov    %eax,%edx
   13538:	8b 45 08             	mov    0x8(%ebp),%eax
   1353b:	8b 40 0c             	mov    0xc(%eax),%eax
   1353e:	0f af d0             	imul   %eax,%edx
   13541:	8b 45 08             	mov    0x8(%ebp),%eax
   13544:	8b 40 14             	mov    0x14(%eax),%eax
   13547:	01 d0                	add    %edx,%eax
   13549:	66 01 45 f6          	add    %ax,-0xa(%ebp)
    irq_state_t state = enter_protection();
   1354d:	e8 d4 fe ff ff       	call   13426 <enter_protection>
   13552:	89 45 f0             	mov    %eax,-0x10(%ebp)
   
	outb(0x3D4, 0x0F);		
   13555:	83 ec 08             	sub    $0x8,%esp
   13558:	6a 0f                	push   $0xf
   1355a:	68 d4 03 00 00       	push   $0x3d4
   1355f:	e8 08 ff ff ff       	call   1346c <outb>
   13564:	83 c4 10             	add    $0x10,%esp
	outb(0x3D5, (uint8_t) (pos & 0xFF));
   13567:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   1356b:	0f b6 c0             	movzbl %al,%eax
   1356e:	83 ec 08             	sub    $0x8,%esp
   13571:	50                   	push   %eax
   13572:	68 d5 03 00 00       	push   $0x3d5
   13577:	e8 f0 fe ff ff       	call   1346c <outb>
   1357c:	83 c4 10             	add    $0x10,%esp
	outb(0x3D4, 0x0E);		
   1357f:	83 ec 08             	sub    $0x8,%esp
   13582:	6a 0e                	push   $0xe
   13584:	68 d4 03 00 00       	push   $0x3d4
   13589:	e8 de fe ff ff       	call   1346c <outb>
   1358e:	83 c4 10             	add    $0x10,%esp
	outb(0x3D5, (uint8_t) ((pos >> 8) & 0xFF));
   13591:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   13595:	66 c1 e8 08          	shr    $0x8,%ax
   13599:	0f b6 c0             	movzbl %al,%eax
   1359c:	83 ec 08             	sub    $0x8,%esp
   1359f:	50                   	push   %eax
   135a0:	68 d5 03 00 00       	push   $0x3d5
   135a5:	e8 c2 fe ff ff       	call   1346c <outb>
   135aa:	83 c4 10             	add    $0x10,%esp
    leave_protection(state);
   135ad:	83 ec 0c             	sub    $0xc,%esp
   135b0:	ff 75 f0             	pushl  -0x10(%ebp)
   135b3:	e8 86 fe ff ff       	call   1343e <leave_protection>
   135b8:	83 c4 10             	add    $0x10,%esp
}
   135bb:	90                   	nop
   135bc:	c9                   	leave  
   135bd:	c3                   	ret    

000135be <console_clear>:
void console_clear(console_t* console)
{
   135be:	55                   	push   %ebp
   135bf:	89 e5                	mov    %esp,%ebp
   135c1:	83 ec 10             	sub    $0x10,%esp
    int size = console->disp_col * console->disp_row;
   135c4:	8b 45 08             	mov    0x8(%ebp),%eax
   135c7:	8b 50 0c             	mov    0xc(%eax),%edx
   135ca:	8b 45 08             	mov    0x8(%ebp),%eax
   135cd:	8b 40 08             	mov    0x8(%eax),%eax
   135d0:	0f af c2             	imul   %edx,%eax
   135d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t* start = console->base;
   135d6:	8b 45 08             	mov    0x8(%ebp),%eax
   135d9:	8b 00                	mov    (%eax),%eax
   135db:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for(int i = 0; i < size; ++i, ++start)
   135de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   135e5:	eb 27                	jmp    1360e <console_clear+0x50>
    {
        start->value = ' ';
   135e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   135ea:	c6 00 20             	movb   $0x20,(%eax)
        start->color = (console->foreground) | (console -> background << 4);
   135ed:	8b 45 08             	mov    0x8(%ebp),%eax
   135f0:	8b 40 18             	mov    0x18(%eax),%eax
   135f3:	89 c2                	mov    %eax,%edx
   135f5:	8b 45 08             	mov    0x8(%ebp),%eax
   135f8:	8b 40 1c             	mov    0x1c(%eax),%eax
   135fb:	c1 e0 04             	shl    $0x4,%eax
   135fe:	09 c2                	or     %eax,%edx
   13600:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13603:	88 50 01             	mov    %dl,0x1(%eax)
    for(int i = 0; i < size; ++i, ++start)
   13606:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1360a:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   1360e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13611:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   13614:	7c d1                	jl     135e7 <console_clear+0x29>
    }
}
   13616:	90                   	nop
   13617:	c9                   	leave  
   13618:	c3                   	ret    

00013619 <console_init>:
int console_init(int idx)
{
   13619:	55                   	push   %ebp
   1361a:	89 e5                	mov    %esp,%ebp
   1361c:	83 ec 18             	sub    $0x18,%esp
    
    console_t* console = console_buf + idx;
   1361f:	8b 45 08             	mov    0x8(%ebp),%eax
   13622:	6b c0 68             	imul   $0x68,%eax,%eax
   13625:	05 40 60 03 00       	add    $0x36040,%eax
   1362a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    console -> disp_row = CONSOLE_ROW;
   1362d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13630:	c7 40 08 19 00 00 00 	movl   $0x19,0x8(%eax)
    console -> disp_col = CONSOLE_COL;
   13637:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1363a:	c7 40 0c 50 00 00 00 	movl   $0x50,0xc(%eax)
    console->foreground = COLOR_White;
   13641:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13644:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
    console->background = COLOR_Black;
   1364b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1364e:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    mutex_init(&console->mutex);
   13655:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13658:	83 c0 54             	add    $0x54,%eax
   1365b:	83 ec 0c             	sub    $0xc,%esp
   1365e:	50                   	push   %eax
   1365f:	e8 f2 4b 00 00       	call   18256 <mutex_init>
   13664:	83 c4 10             	add    $0x10,%esp
    if(idx == 0)
   13667:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1366b:	75 30                	jne    1369d <console_init+0x84>
    {int cursor_pos = read_cursor_pos();
   1366d:	e8 19 fe ff ff       	call   1348b <read_cursor_pos>
   13672:	89 45 f0             	mov    %eax,-0x10(%ebp)
    console->cur_row = cursor_pos / console->disp_col;
   13675:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13678:	8b 48 0c             	mov    0xc(%eax),%ecx
   1367b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1367e:	99                   	cltd   
   1367f:	f7 f9                	idiv   %ecx
   13681:	89 c2                	mov    %eax,%edx
   13683:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13686:	89 50 10             	mov    %edx,0x10(%eax)
    console->cur_col = cursor_pos % console->disp_col;}
   13689:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1368c:	8b 48 0c             	mov    0xc(%eax),%ecx
   1368f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13692:	99                   	cltd   
   13693:	f7 f9                	idiv   %ecx
   13695:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13698:	89 50 14             	mov    %edx,0x14(%eax)
   1369b:	eb 22                	jmp    136bf <console_init+0xa6>
    else{
        console->cur_row = 0;
   1369d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   136a0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
        console->cur_col = 0;
   136a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   136aa:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
        console_clear(console);
   136b1:	83 ec 0c             	sub    $0xc,%esp
   136b4:	ff 75 f4             	pushl  -0xc(%ebp)
   136b7:	e8 02 ff ff ff       	call   135be <console_clear>
   136bc:	83 c4 10             	add    $0x10,%esp
    }
    console ->curr_param_index = 0;
   136bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   136c2:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
    console -> base = (disp_char_t*)CONSOLE_BASE + (idx*CONSOLE_ROW * CONSOLE_COL);
   136c9:	8b 45 08             	mov    0x8(%ebp),%eax
   136cc:	69 c0 a0 0f 00 00    	imul   $0xfa0,%eax,%eax
   136d2:	8d 90 00 80 0b 00    	lea    0xb8000(%eax),%edx
   136d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   136db:	89 10                	mov    %edx,(%eax)
    // console_clear(console);
    console->save_cur_col = console->cur_col;
   136dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   136e0:	8b 50 14             	mov    0x14(%eax),%edx
   136e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   136e6:	89 50 20             	mov    %edx,0x20(%eax)
    console->save_cur_row = console->cur_row;
   136e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   136ec:	8b 50 10             	mov    0x10(%eax),%edx
   136ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
   136f2:	89 50 24             	mov    %edx,0x24(%eax)
    //  update_cursor_pos(console);

    return 0;
   136f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   136fa:	c9                   	leave  
   136fb:	c3                   	ret    

000136fc <move_forward>:
void  move_forward(console_t* console, int step)
{
   136fc:	55                   	push   %ebp
   136fd:	89 e5                	mov    %esp,%ebp
   136ff:	83 ec 18             	sub    $0x18,%esp
    for(int i = 0; i < step; ++i)
   13702:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13709:	eb 5c                	jmp    13767 <move_forward+0x6b>
    {
        if((++console->cur_col) >= console->disp_col)
   1370b:	8b 45 08             	mov    0x8(%ebp),%eax
   1370e:	8b 40 14             	mov    0x14(%eax),%eax
   13711:	8d 50 01             	lea    0x1(%eax),%edx
   13714:	8b 45 08             	mov    0x8(%ebp),%eax
   13717:	89 50 14             	mov    %edx,0x14(%eax)
   1371a:	8b 45 08             	mov    0x8(%ebp),%eax
   1371d:	8b 50 14             	mov    0x14(%eax),%edx
   13720:	8b 45 08             	mov    0x8(%ebp),%eax
   13723:	8b 40 0c             	mov    0xc(%eax),%eax
   13726:	39 c2                	cmp    %eax,%edx
   13728:	7c 19                	jl     13743 <move_forward+0x47>
        {
            console->cur_row +=1;
   1372a:	8b 45 08             	mov    0x8(%ebp),%eax
   1372d:	8b 40 10             	mov    0x10(%eax),%eax
   13730:	8d 50 01             	lea    0x1(%eax),%edx
   13733:	8b 45 08             	mov    0x8(%ebp),%eax
   13736:	89 50 10             	mov    %edx,0x10(%eax)
            console->cur_col = 0;
   13739:	8b 45 08             	mov    0x8(%ebp),%eax
   1373c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
        }
        if((console->cur_row) >= console->disp_row)
   13743:	8b 45 08             	mov    0x8(%ebp),%eax
   13746:	8b 50 10             	mov    0x10(%eax),%edx
   13749:	8b 45 08             	mov    0x8(%ebp),%eax
   1374c:	8b 40 08             	mov    0x8(%eax),%eax
   1374f:	39 c2                	cmp    %eax,%edx
   13751:	7c 10                	jl     13763 <move_forward+0x67>
        {
            scroll_up(console, 1);
   13753:	83 ec 08             	sub    $0x8,%esp
   13756:	6a 01                	push   $0x1
   13758:	ff 75 08             	pushl  0x8(%ebp)
   1375b:	e8 b3 07 00 00       	call   13f13 <scroll_up>
   13760:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < step; ++i)
   13763:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13767:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1376a:	3b 45 0c             	cmp    0xc(%ebp),%eax
   1376d:	7c 9c                	jl     1370b <move_forward+0xf>
        }
    }
}
   1376f:	90                   	nop
   13770:	c9                   	leave  
   13771:	c3                   	ret    

00013772 <show_console>:
void show_console(console_t* console, const char c)
{
   13772:	55                   	push   %ebp
   13773:	89 e5                	mov    %esp,%ebp
   13775:	83 ec 28             	sub    $0x28,%esp
   13778:	8b 45 0c             	mov    0xc(%ebp),%eax
   1377b:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int offset = console->cur_col + console->cur_row * console->disp_col;
   1377e:	8b 45 08             	mov    0x8(%ebp),%eax
   13781:	8b 50 14             	mov    0x14(%eax),%edx
   13784:	8b 45 08             	mov    0x8(%ebp),%eax
   13787:	8b 48 10             	mov    0x10(%eax),%ecx
   1378a:	8b 45 08             	mov    0x8(%ebp),%eax
   1378d:	8b 40 0c             	mov    0xc(%eax),%eax
   13790:	0f af c1             	imul   %ecx,%eax
   13793:	01 d0                	add    %edx,%eax
   13795:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t *p = console->base + offset;
   13798:	8b 45 08             	mov    0x8(%ebp),%eax
   1379b:	8b 00                	mov    (%eax),%eax
   1379d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   137a0:	01 d2                	add    %edx,%edx
   137a2:	01 d0                	add    %edx,%eax
   137a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    p ->value =  c;
   137a7:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
   137ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
   137ae:	88 10                	mov    %dl,(%eax)
    p ->color =  (console->foreground) | (console -> background << 4);
   137b0:	8b 45 08             	mov    0x8(%ebp),%eax
   137b3:	8b 40 18             	mov    0x18(%eax),%eax
   137b6:	89 c2                	mov    %eax,%edx
   137b8:	8b 45 08             	mov    0x8(%ebp),%eax
   137bb:	8b 40 1c             	mov    0x1c(%eax),%eax
   137be:	c1 e0 04             	shl    $0x4,%eax
   137c1:	09 c2                	or     %eax,%edx
   137c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   137c6:	88 50 01             	mov    %dl,0x1(%eax)
    move_forward(console, 1);
   137c9:	83 ec 08             	sub    $0x8,%esp
   137cc:	6a 01                	push   $0x1
   137ce:	ff 75 08             	pushl  0x8(%ebp)
   137d1:	e8 26 ff ff ff       	call   136fc <move_forward>
   137d6:	83 c4 10             	add    $0x10,%esp
}
   137d9:	90                   	nop
   137da:	c9                   	leave  
   137db:	c3                   	ret    

000137dc <erase_backword>:

void erase_backword(console_t* console)
{
   137dc:	55                   	push   %ebp
   137dd:	89 e5                	mov    %esp,%ebp
   137df:	83 ec 08             	sub    $0x8,%esp
    if(cursor_backword(console, 1) == 0)
   137e2:	83 ec 08             	sub    $0x8,%esp
   137e5:	6a 01                	push   $0x1
   137e7:	ff 75 08             	pushl  0x8(%ebp)
   137ea:	e8 e1 00 00 00       	call   138d0 <cursor_backword>
   137ef:	83 c4 10             	add    $0x10,%esp
   137f2:	85 c0                	test   %eax,%eax
   137f4:	75 20                	jne    13816 <erase_backword+0x3a>
    {
        show_console(console, ' ');
   137f6:	83 ec 08             	sub    $0x8,%esp
   137f9:	6a 20                	push   $0x20
   137fb:	ff 75 08             	pushl  0x8(%ebp)
   137fe:	e8 6f ff ff ff       	call   13772 <show_console>
   13803:	83 c4 10             	add    $0x10,%esp
        cursor_backword(console, 1);
   13806:	83 ec 08             	sub    $0x8,%esp
   13809:	6a 01                	push   $0x1
   1380b:	ff 75 08             	pushl  0x8(%ebp)
   1380e:	e8 bd 00 00 00       	call   138d0 <cursor_backword>
   13813:	83 c4 10             	add    $0x10,%esp
    }
    
}
   13816:	90                   	nop
   13817:	c9                   	leave  
   13818:	c3                   	ret    

00013819 <console_select>:
void console_select(int idx) {
   13819:	55                   	push   %ebp
   1381a:	89 e5                	mov    %esp,%ebp
   1381c:	83 ec 18             	sub    $0x18,%esp
    console_t * console = console_buf + idx;
   1381f:	8b 45 08             	mov    0x8(%ebp),%eax
   13822:	6b c0 68             	imul   $0x68,%eax,%eax
   13825:	05 40 60 03 00       	add    $0x36040,%eax
   1382a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (console->base == (disp_char_t*)0) {
   1382d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13830:	8b 00                	mov    (%eax),%eax
   13832:	85 c0                	test   %eax,%eax
   13834:	75 0e                	jne    13844 <console_select+0x2b>

        console_init(idx);
   13836:	83 ec 0c             	sub    $0xc,%esp
   13839:	ff 75 08             	pushl  0x8(%ebp)
   1383c:	e8 d8 fd ff ff       	call   13619 <console_init>
   13841:	83 c4 10             	add    $0x10,%esp
    }

	uint16_t pos = idx * console->disp_col * console->disp_row;
   13844:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13847:	8b 40 0c             	mov    0xc(%eax),%eax
   1384a:	89 c2                	mov    %eax,%edx
   1384c:	8b 45 08             	mov    0x8(%ebp),%eax
   1384f:	0f af d0             	imul   %eax,%edx
   13852:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13855:	8b 40 08             	mov    0x8(%eax),%eax
   13858:	0f af c2             	imul   %edx,%eax
   1385b:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
	outb(0x3D4, 0xC);		
   1385f:	83 ec 08             	sub    $0x8,%esp
   13862:	6a 0c                	push   $0xc
   13864:	68 d4 03 00 00       	push   $0x3d4
   13869:	e8 fe fb ff ff       	call   1346c <outb>
   1386e:	83 c4 10             	add    $0x10,%esp
	outb(0x3D5, (uint8_t) ((pos >> 8) & 0xFF));
   13871:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   13875:	66 c1 e8 08          	shr    $0x8,%ax
   13879:	0f b6 c0             	movzbl %al,%eax
   1387c:	83 ec 08             	sub    $0x8,%esp
   1387f:	50                   	push   %eax
   13880:	68 d5 03 00 00       	push   $0x3d5
   13885:	e8 e2 fb ff ff       	call   1346c <outb>
   1388a:	83 c4 10             	add    $0x10,%esp
	outb(0x3D4, 0xD);	
   1388d:	83 ec 08             	sub    $0x8,%esp
   13890:	6a 0d                	push   $0xd
   13892:	68 d4 03 00 00       	push   $0x3d4
   13897:	e8 d0 fb ff ff       	call   1346c <outb>
   1389c:	83 c4 10             	add    $0x10,%esp
	outb(0x3D5, (uint8_t) (pos & 0xFF));
   1389f:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   138a3:	0f b6 c0             	movzbl %al,%eax
   138a6:	83 ec 08             	sub    $0x8,%esp
   138a9:	50                   	push   %eax
   138aa:	68 d5 03 00 00       	push   $0x3d5
   138af:	e8 b8 fb ff ff       	call   1346c <outb>
   138b4:	83 c4 10             	add    $0x10,%esp
    curr_console_idx = idx;
   138b7:	8b 45 08             	mov    0x8(%ebp),%eax
   138ba:	a3 80 63 03 00       	mov    %eax,0x36380
    update_cursor_pos(console);
   138bf:	83 ec 0c             	sub    $0xc,%esp
   138c2:	ff 75 f4             	pushl  -0xc(%ebp)
   138c5:	e8 35 fc ff ff       	call   134ff <update_cursor_pos>
   138ca:	83 c4 10             	add    $0x10,%esp
}
   138cd:	90                   	nop
   138ce:	c9                   	leave  
   138cf:	c3                   	ret    

000138d0 <cursor_backword>:

int cursor_backword(console_t* console, int len)
{
   138d0:	55                   	push   %ebp
   138d1:	89 e5                	mov    %esp,%ebp
   138d3:	83 ec 10             	sub    $0x10,%esp
    int status = -1;
   138d6:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
    for(int i = 0; i < len; ++i)
   138dd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   138e4:	eb 55                	jmp    1393b <cursor_backword+0x6b>
    {
        if(console->cur_col > 0)
   138e6:	8b 45 08             	mov    0x8(%ebp),%eax
   138e9:	8b 40 14             	mov    0x14(%eax),%eax
   138ec:	85 c0                	test   %eax,%eax
   138ee:	7e 18                	jle    13908 <cursor_backword+0x38>
        {
            console->cur_col -- ;
   138f0:	8b 45 08             	mov    0x8(%ebp),%eax
   138f3:	8b 40 14             	mov    0x14(%eax),%eax
   138f6:	8d 50 ff             	lea    -0x1(%eax),%edx
   138f9:	8b 45 08             	mov    0x8(%ebp),%eax
   138fc:	89 50 14             	mov    %edx,0x14(%eax)
            status = 0;
   138ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   13906:	eb 2f                	jmp    13937 <cursor_backword+0x67>
        }
        else if(console->cur_row > 0)
   13908:	8b 45 08             	mov    0x8(%ebp),%eax
   1390b:	8b 40 10             	mov    0x10(%eax),%eax
   1390e:	85 c0                	test   %eax,%eax
   13910:	7e 25                	jle    13937 <cursor_backword+0x67>
        {
            console -> cur_col = console->disp_col - 1;
   13912:	8b 45 08             	mov    0x8(%ebp),%eax
   13915:	8b 40 0c             	mov    0xc(%eax),%eax
   13918:	8d 50 ff             	lea    -0x1(%eax),%edx
   1391b:	8b 45 08             	mov    0x8(%ebp),%eax
   1391e:	89 50 14             	mov    %edx,0x14(%eax)
            console -> cur_row -=1;
   13921:	8b 45 08             	mov    0x8(%ebp),%eax
   13924:	8b 40 10             	mov    0x10(%eax),%eax
   13927:	8d 50 ff             	lea    -0x1(%eax),%edx
   1392a:	8b 45 08             	mov    0x8(%ebp),%eax
   1392d:	89 50 10             	mov    %edx,0x10(%eax)
            status = 0;
   13930:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i = 0; i < len; ++i)
   13937:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1393b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1393e:	3b 45 0c             	cmp    0xc(%ebp),%eax
   13941:	7c a3                	jl     138e6 <cursor_backword+0x16>
        }
    }
    return status;
   13943:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   13946:	c9                   	leave  
   13947:	c3                   	ret    

00013948 <write_normal>:
void write_normal(console_t* console, char c)
{
   13948:	55                   	push   %ebp
   13949:	89 e5                	mov    %esp,%ebp
   1394b:	83 ec 18             	sub    $0x18,%esp
   1394e:	8b 45 0c             	mov    0xc(%ebp),%eax
   13951:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   13954:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   13958:	83 f8 0d             	cmp    $0xd,%eax
   1395b:	74 4b                	je     139a8 <write_normal+0x60>
   1395d:	83 f8 0d             	cmp    $0xd,%eax
   13960:	7f 0c                	jg     1396e <write_normal+0x26>
   13962:	83 f8 08             	cmp    $0x8,%eax
   13965:	74 2f                	je     13996 <write_normal+0x4e>
   13967:	83 f8 0a             	cmp    $0xa,%eax
   1396a:	74 4c                	je     139b8 <write_normal+0x70>
   1396c:	eb 5a                	jmp    139c8 <write_normal+0x80>
   1396e:	83 f8 1b             	cmp    $0x1b,%eax
   13971:	74 07                	je     1397a <write_normal+0x32>
   13973:	83 f8 7f             	cmp    $0x7f,%eax
   13976:	74 0e                	je     13986 <write_normal+0x3e>
   13978:	eb 4e                	jmp    139c8 <write_normal+0x80>
        {
        case ASC_ESC:
            console->write_state = CONSOLE_WRITE_ESC;
   1397a:	8b 45 08             	mov    0x8(%ebp),%eax
   1397d:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
            break; 
   13984:	eb 62                	jmp    139e8 <write_normal+0xa0>
        case 0x7F:
            erase_backword(console);
   13986:	83 ec 0c             	sub    $0xc,%esp
   13989:	ff 75 08             	pushl  0x8(%ebp)
   1398c:	e8 4b fe ff ff       	call   137dc <erase_backword>
   13991:	83 c4 10             	add    $0x10,%esp
            break;
   13994:	eb 52                	jmp    139e8 <write_normal+0xa0>
        case '\b':
            cursor_backword(console, 1);
   13996:	83 ec 08             	sub    $0x8,%esp
   13999:	6a 01                	push   $0x1
   1399b:	ff 75 08             	pushl  0x8(%ebp)
   1399e:	e8 2d ff ff ff       	call   138d0 <cursor_backword>
   139a3:	83 c4 10             	add    $0x10,%esp
            break;
   139a6:	eb 40                	jmp    139e8 <write_normal+0xa0>
        case '\r': 
            set_col0(console);
   139a8:	83 ec 0c             	sub    $0xc,%esp
   139ab:	ff 75 08             	pushl  0x8(%ebp)
   139ae:	e8 b1 04 00 00       	call   13e64 <set_col0>
   139b3:	83 c4 10             	add    $0x10,%esp
            break;
   139b6:	eb 30                	jmp    139e8 <write_normal+0xa0>
        case '\n':
            // set_col0(console);
            add_row1(console);
   139b8:	83 ec 0c             	sub    $0xc,%esp
   139bb:	ff 75 08             	pushl  0x8(%ebp)
   139be:	e8 b1 04 00 00       	call   13e74 <add_row1>
   139c3:	83 c4 10             	add    $0x10,%esp
            break;
   139c6:	eb 20                	jmp    139e8 <write_normal+0xa0>
        
        default:
            if(c >=' ' && c <= '~')
   139c8:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
   139cc:	7e 19                	jle    139e7 <write_normal+0x9f>
   139ce:	80 7d f4 7f          	cmpb   $0x7f,-0xc(%ebp)
   139d2:	74 13                	je     139e7 <write_normal+0x9f>
                show_console(console, c);
   139d4:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   139d8:	83 ec 08             	sub    $0x8,%esp
   139db:	50                   	push   %eax
   139dc:	ff 75 08             	pushl  0x8(%ebp)
   139df:	e8 8e fd ff ff       	call   13772 <show_console>
   139e4:	83 c4 10             	add    $0x10,%esp
            break;
   139e7:	90                   	nop
        }    
}
   139e8:	90                   	nop
   139e9:	c9                   	leave  
   139ea:	c3                   	ret    

000139eb <save_cursor>:
void save_cursor(console_t* console)
{
   139eb:	55                   	push   %ebp
   139ec:	89 e5                	mov    %esp,%ebp
    console->save_cur_col = console->cur_col;
   139ee:	8b 45 08             	mov    0x8(%ebp),%eax
   139f1:	8b 50 14             	mov    0x14(%eax),%edx
   139f4:	8b 45 08             	mov    0x8(%ebp),%eax
   139f7:	89 50 20             	mov    %edx,0x20(%eax)
    console->save_cur_row = console->cur_row;
   139fa:	8b 45 08             	mov    0x8(%ebp),%eax
   139fd:	8b 50 10             	mov    0x10(%eax),%edx
   13a00:	8b 45 08             	mov    0x8(%ebp),%eax
   13a03:	89 50 24             	mov    %edx,0x24(%eax)
}
   13a06:	90                   	nop
   13a07:	5d                   	pop    %ebp
   13a08:	c3                   	ret    

00013a09 <load_cursor>:
void load_cursor(console_t* console)
{
   13a09:	55                   	push   %ebp
   13a0a:	89 e5                	mov    %esp,%ebp
    console->cur_col = console->save_cur_col;
   13a0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13a0f:	8b 50 20             	mov    0x20(%eax),%edx
   13a12:	8b 45 08             	mov    0x8(%ebp),%eax
   13a15:	89 50 14             	mov    %edx,0x14(%eax)
    console->cur_row = console->save_cur_row;
   13a18:	8b 45 08             	mov    0x8(%ebp),%eax
   13a1b:	8b 50 24             	mov    0x24(%eax),%edx
   13a1e:	8b 45 08             	mov    0x8(%ebp),%eax
   13a21:	89 50 10             	mov    %edx,0x10(%eax)
}
   13a24:	90                   	nop
   13a25:	5d                   	pop    %ebp
   13a26:	c3                   	ret    

00013a27 <clear_esc_param>:
void clear_esc_param(console_t* console)
{
   13a27:	55                   	push   %ebp
   13a28:	89 e5                	mov    %esp,%ebp
   13a2a:	83 ec 08             	sub    $0x8,%esp
    kernel_memset((void*)console->esc_param, 0, sizeof(console->esc_param));
   13a2d:	8b 45 08             	mov    0x8(%ebp),%eax
   13a30:	83 c0 28             	add    $0x28,%eax
   13a33:	83 ec 04             	sub    $0x4,%esp
   13a36:	6a 28                	push   $0x28
   13a38:	6a 00                	push   $0x0
   13a3a:	50                   	push   %eax
   13a3b:	e8 62 4f 00 00       	call   189a2 <kernel_memset>
   13a40:	83 c4 10             	add    $0x10,%esp
    console->curr_param_index = 0;
   13a43:	8b 45 08             	mov    0x8(%ebp),%eax
   13a46:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
}
   13a4d:	90                   	nop
   13a4e:	c9                   	leave  
   13a4f:	c3                   	ret    

00013a50 <write_esc>:
void write_esc(console_t* console, char c)
{
   13a50:	55                   	push   %ebp
   13a51:	89 e5                	mov    %esp,%ebp
   13a53:	83 ec 18             	sub    $0x18,%esp
   13a56:	8b 45 0c             	mov    0xc(%ebp),%eax
   13a59:	88 45 f4             	mov    %al,-0xc(%ebp)
    switch (c)
   13a5c:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
   13a60:	83 f8 38             	cmp    $0x38,%eax
   13a63:	74 21                	je     13a86 <write_esc+0x36>
   13a65:	83 f8 5b             	cmp    $0x5b,%eax
   13a68:	74 33                	je     13a9d <write_esc+0x4d>
   13a6a:	83 f8 37             	cmp    $0x37,%eax
   13a6d:	75 48                	jne    13ab7 <write_esc+0x67>
        {
        case '7':
            save_cursor(console);
   13a6f:	ff 75 08             	pushl  0x8(%ebp)
   13a72:	e8 74 ff ff ff       	call   139eb <save_cursor>
   13a77:	83 c4 04             	add    $0x4,%esp
            console ->write_state = CONSOLE_WRITE_NORMAL;
   13a7a:	8b 45 08             	mov    0x8(%ebp),%eax
   13a7d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
            break;
   13a84:	eb 3c                	jmp    13ac2 <write_esc+0x72>
        case '8':
            load_cursor(console);
   13a86:	ff 75 08             	pushl  0x8(%ebp)
   13a89:	e8 7b ff ff ff       	call   13a09 <load_cursor>
   13a8e:	83 c4 04             	add    $0x4,%esp
            console ->write_state = CONSOLE_WRITE_NORMAL;
   13a91:	8b 45 08             	mov    0x8(%ebp),%eax
   13a94:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
            break;
   13a9b:	eb 25                	jmp    13ac2 <write_esc+0x72>
        case '[':
            clear_esc_param(console);
   13a9d:	83 ec 0c             	sub    $0xc,%esp
   13aa0:	ff 75 08             	pushl  0x8(%ebp)
   13aa3:	e8 7f ff ff ff       	call   13a27 <clear_esc_param>
   13aa8:	83 c4 10             	add    $0x10,%esp
            console ->write_state = CONSOLE_WRITE_ESC_SQUARE;
   13aab:	8b 45 08             	mov    0x8(%ebp),%eax
   13aae:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
            break;
   13ab5:	eb 0b                	jmp    13ac2 <write_esc+0x72>
        default:
            console ->write_state = CONSOLE_WRITE_NORMAL;
   13ab7:	8b 45 08             	mov    0x8(%ebp),%eax
   13aba:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
            break;
   13ac1:	90                   	nop
        }    
}
   13ac2:	90                   	nop
   13ac3:	c9                   	leave  
   13ac4:	c3                   	ret    

00013ac5 <set_font_style>:
static void set_font_style(console_t* console)
{
   13ac5:	55                   	push   %ebp
   13ac6:	89 e5                	mov    %esp,%ebp
   13ac8:	83 ec 10             	sub    $0x10,%esp
    static const cclor_t color_table[] = {
			COLOR_Black, COLOR_Red, COLOR_Green, COLOR_Yellow, // 0-3
			COLOR_Blue, COLOR_Magenta, COLOR_Cyan, COLOR_White, // 4-7
	};

	for (int i = 0; i < console->curr_param_index; i++) {
   13acb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   13ad2:	eb 78                	jmp    13b4c <set_font_style+0x87>
		int param = console->esc_param[i];
   13ad4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ad7:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13ada:	83 c2 08             	add    $0x8,%edx
   13add:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
   13ae1:	89 45 f8             	mov    %eax,-0x8(%ebp)
		if ((param >= 30) && (param <= 37)) {  
   13ae4:	83 7d f8 1d          	cmpl   $0x1d,-0x8(%ebp)
   13ae8:	7e 1b                	jle    13b05 <set_font_style+0x40>
   13aea:	83 7d f8 25          	cmpl   $0x25,-0x8(%ebp)
   13aee:	7f 15                	jg     13b05 <set_font_style+0x40>
			console->foreground = color_table[param - 30];
   13af0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13af3:	83 e8 1e             	sub    $0x1e,%eax
   13af6:	8b 14 85 80 9a 01 00 	mov    0x19a80(,%eax,4),%edx
   13afd:	8b 45 08             	mov    0x8(%ebp),%eax
   13b00:	89 50 18             	mov    %edx,0x18(%eax)
   13b03:	eb 43                	jmp    13b48 <set_font_style+0x83>
		} else if ((param >= 40) && (param <= 47)) {
   13b05:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   13b09:	7e 1b                	jle    13b26 <set_font_style+0x61>
   13b0b:	83 7d f8 2f          	cmpl   $0x2f,-0x8(%ebp)
   13b0f:	7f 15                	jg     13b26 <set_font_style+0x61>
			console->background = color_table[param - 40];
   13b11:	8b 45 f8             	mov    -0x8(%ebp),%eax
   13b14:	83 e8 28             	sub    $0x28,%eax
   13b17:	8b 14 85 80 9a 01 00 	mov    0x19a80(,%eax,4),%edx
   13b1e:	8b 45 08             	mov    0x8(%ebp),%eax
   13b21:	89 50 1c             	mov    %edx,0x1c(%eax)
   13b24:	eb 22                	jmp    13b48 <set_font_style+0x83>
		} else if (param == 39) { 
   13b26:	83 7d f8 27          	cmpl   $0x27,-0x8(%ebp)
   13b2a:	75 0c                	jne    13b38 <set_font_style+0x73>
			console->foreground = COLOR_White;
   13b2c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b2f:	c7 40 18 0f 00 00 00 	movl   $0xf,0x18(%eax)
   13b36:	eb 10                	jmp    13b48 <set_font_style+0x83>
		} else if (param == 49) { 
   13b38:	83 7d f8 31          	cmpl   $0x31,-0x8(%ebp)
   13b3c:	75 0a                	jne    13b48 <set_font_style+0x83>
			console->background = COLOR_Black;
   13b3e:	8b 45 08             	mov    0x8(%ebp),%eax
   13b41:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
	for (int i = 0; i < console->curr_param_index; i++) {
   13b48:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   13b4c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b4f:	8b 40 50             	mov    0x50(%eax),%eax
   13b52:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13b55:	0f 8c 79 ff ff ff    	jl     13ad4 <set_font_style+0xf>
		}
	}
}
   13b5b:	90                   	nop
   13b5c:	c9                   	leave  
   13b5d:	c3                   	ret    

00013b5e <move_right>:
static void move_right (console_t * console, int n) {
   13b5e:	55                   	push   %ebp
   13b5f:	89 e5                	mov    %esp,%ebp
   13b61:	83 ec 10             	sub    $0x10,%esp
    if (n == 0) {
   13b64:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13b68:	75 07                	jne    13b71 <move_right+0x13>
        n = 1;
   13b6a:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col = console->cur_col + n;
   13b71:	8b 45 08             	mov    0x8(%ebp),%eax
   13b74:	8b 50 14             	mov    0x14(%eax),%edx
   13b77:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b7a:	01 d0                	add    %edx,%eax
   13b7c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (col >= console->disp_col) {
   13b7f:	8b 45 08             	mov    0x8(%ebp),%eax
   13b82:	8b 40 0c             	mov    0xc(%eax),%eax
   13b85:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   13b88:	7c 11                	jl     13b9b <move_right+0x3d>
        console->cur_col = console->disp_col - 1;
   13b8a:	8b 45 08             	mov    0x8(%ebp),%eax
   13b8d:	8b 40 0c             	mov    0xc(%eax),%eax
   13b90:	8d 50 ff             	lea    -0x1(%eax),%edx
   13b93:	8b 45 08             	mov    0x8(%ebp),%eax
   13b96:	89 50 14             	mov    %edx,0x14(%eax)
    } else {
        console->cur_col = col;
    }
}
   13b99:	eb 09                	jmp    13ba4 <move_right+0x46>
        console->cur_col = col;
   13b9b:	8b 45 08             	mov    0x8(%ebp),%eax
   13b9e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   13ba1:	89 50 14             	mov    %edx,0x14(%eax)
}
   13ba4:	90                   	nop
   13ba5:	c9                   	leave  
   13ba6:	c3                   	ret    

00013ba7 <move_left>:
static void move_left (console_t * console, int n) {
   13ba7:	55                   	push   %ebp
   13ba8:	89 e5                	mov    %esp,%ebp
   13baa:	83 ec 10             	sub    $0x10,%esp
    if (n == 0) {
   13bad:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   13bb1:	75 07                	jne    13bba <move_left+0x13>
        n = 1;
   13bb3:	c7 45 0c 01 00 00 00 	movl   $0x1,0xc(%ebp)
    }

    int col = console->cur_col - n;
   13bba:	8b 45 08             	mov    0x8(%ebp),%eax
   13bbd:	8b 40 14             	mov    0x14(%eax),%eax
   13bc0:	2b 45 0c             	sub    0xc(%ebp),%eax
   13bc3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    console->cur_col = (col >= 0) ? col : 0;
   13bc6:	b8 00 00 00 00       	mov    $0x0,%eax
   13bcb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   13bcf:	0f 49 45 fc          	cmovns -0x4(%ebp),%eax
   13bd3:	89 c2                	mov    %eax,%edx
   13bd5:	8b 45 08             	mov    0x8(%ebp),%eax
   13bd8:	89 50 14             	mov    %edx,0x14(%eax)
}
   13bdb:	90                   	nop
   13bdc:	c9                   	leave  
   13bdd:	c3                   	ret    

00013bde <move_cursor>:
static void move_cursor(console_t * console) {
   13bde:	55                   	push   %ebp
   13bdf:	89 e5                	mov    %esp,%ebp
    console->cur_row = console->esc_param[0];
   13be1:	8b 45 08             	mov    0x8(%ebp),%eax
   13be4:	8b 50 28             	mov    0x28(%eax),%edx
   13be7:	8b 45 08             	mov    0x8(%ebp),%eax
   13bea:	89 50 10             	mov    %edx,0x10(%eax)
    console->cur_col = console->esc_param[1];
   13bed:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf0:	8b 50 2c             	mov    0x2c(%eax),%edx
   13bf3:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf6:	89 50 14             	mov    %edx,0x14(%eax)
}
   13bf9:	90                   	nop
   13bfa:	5d                   	pop    %ebp
   13bfb:	c3                   	ret    

00013bfc <erase_in_display>:
static void erase_in_display(console_t * console) {
   13bfc:	55                   	push   %ebp
   13bfd:	89 e5                	mov    %esp,%ebp
   13bff:	83 ec 18             	sub    $0x18,%esp
	if (console->curr_param_index < 0) {
   13c02:	8b 45 08             	mov    0x8(%ebp),%eax
   13c05:	8b 40 50             	mov    0x50(%eax),%eax
   13c08:	85 c0                	test   %eax,%eax
   13c0a:	78 41                	js     13c4d <erase_in_display+0x51>
		return;
	}

	int param = console->esc_param[0];
   13c0c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c0f:	8b 40 28             	mov    0x28(%eax),%eax
   13c12:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (param == 2) {
   13c15:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
   13c19:	75 33                	jne    13c4e <erase_in_display+0x52>
		erase_rows(console, 0, console->disp_row - 1);
   13c1b:	8b 45 08             	mov    0x8(%ebp),%eax
   13c1e:	8b 40 08             	mov    0x8(%eax),%eax
   13c21:	83 e8 01             	sub    $0x1,%eax
   13c24:	83 ec 04             	sub    $0x4,%esp
   13c27:	50                   	push   %eax
   13c28:	6a 00                	push   $0x0
   13c2a:	ff 75 08             	pushl  0x8(%ebp)
   13c2d:	e8 7a 02 00 00       	call   13eac <erase_rows>
   13c32:	83 c4 10             	add    $0x10,%esp
        console->cur_col = console->cur_row = 0;
   13c35:	8b 45 08             	mov    0x8(%ebp),%eax
   13c38:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
   13c3f:	8b 45 08             	mov    0x8(%ebp),%eax
   13c42:	8b 50 10             	mov    0x10(%eax),%edx
   13c45:	8b 45 08             	mov    0x8(%ebp),%eax
   13c48:	89 50 14             	mov    %edx,0x14(%eax)
   13c4b:	eb 01                	jmp    13c4e <erase_in_display+0x52>
		return;
   13c4d:	90                   	nop
	}
}
   13c4e:	c9                   	leave  
   13c4f:	c3                   	ret    

00013c50 <write_esc_square>:
static void write_esc_square (console_t * console, char c) {
   13c50:	55                   	push   %ebp
   13c51:	89 e5                	mov    %esp,%ebp
   13c53:	83 ec 28             	sub    $0x28,%esp
   13c56:	8b 45 0c             	mov    0xc(%ebp),%eax
   13c59:	88 45 e4             	mov    %al,-0x1c(%ebp)

    if ((c >= '0') && (c <= '9')) {
   13c5c:	80 7d e4 2f          	cmpb   $0x2f,-0x1c(%ebp)
   13c60:	7e 44                	jle    13ca6 <write_esc_square+0x56>
   13c62:	80 7d e4 39          	cmpb   $0x39,-0x1c(%ebp)
   13c66:	7f 3e                	jg     13ca6 <write_esc_square+0x56>
 
        int * param = &console->esc_param[console->curr_param_index];
   13c68:	8b 45 08             	mov    0x8(%ebp),%eax
   13c6b:	8b 40 50             	mov    0x50(%eax),%eax
   13c6e:	83 c0 08             	add    $0x8,%eax
   13c71:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13c78:	8b 45 08             	mov    0x8(%ebp),%eax
   13c7b:	01 d0                	add    %edx,%eax
   13c7d:	83 c0 08             	add    $0x8,%eax
   13c80:	89 45 f4             	mov    %eax,-0xc(%ebp)
        *param = *param * 10 + c - '0';
   13c83:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c86:	8b 10                	mov    (%eax),%edx
   13c88:	89 d0                	mov    %edx,%eax
   13c8a:	c1 e0 02             	shl    $0x2,%eax
   13c8d:	01 d0                	add    %edx,%eax
   13c8f:	01 c0                	add    %eax,%eax
   13c91:	89 c2                	mov    %eax,%edx
   13c93:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
   13c97:	01 d0                	add    %edx,%eax
   13c99:	8d 50 d0             	lea    -0x30(%eax),%edx
   13c9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13c9f:	89 10                	mov    %edx,(%eax)
    if ((c >= '0') && (c <= '9')) {
   13ca1:	e9 a1 00 00 00       	jmp    13d47 <write_esc_square+0xf7>
    } else if ((c == ';') && console->curr_param_index < ESC_PARAM_MAX) {
   13ca6:	80 7d e4 3b          	cmpb   $0x3b,-0x1c(%ebp)
   13caa:	75 1c                	jne    13cc8 <write_esc_square+0x78>
   13cac:	8b 45 08             	mov    0x8(%ebp),%eax
   13caf:	8b 40 50             	mov    0x50(%eax),%eax
   13cb2:	83 f8 09             	cmp    $0x9,%eax
   13cb5:	7f 11                	jg     13cc8 <write_esc_square+0x78>
        console->curr_param_index++;
   13cb7:	8b 45 08             	mov    0x8(%ebp),%eax
   13cba:	8b 40 50             	mov    0x50(%eax),%eax
   13cbd:	8d 50 01             	lea    0x1(%eax),%edx
   13cc0:	8b 45 08             	mov    0x8(%ebp),%eax
   13cc3:	89 50 50             	mov    %edx,0x50(%eax)
   13cc6:	eb 7f                	jmp    13d47 <write_esc_square+0xf7>
    } else {

        console->curr_param_index++;
   13cc8:	8b 45 08             	mov    0x8(%ebp),%eax
   13ccb:	8b 40 50             	mov    0x50(%eax),%eax
   13cce:	8d 50 01             	lea    0x1(%eax),%edx
   13cd1:	8b 45 08             	mov    0x8(%ebp),%eax
   13cd4:	89 50 50             	mov    %edx,0x50(%eax)

 
        switch (c) {
   13cd7:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
   13cdb:	83 e8 43             	sub    $0x43,%eax
   13cde:	83 f8 2a             	cmp    $0x2a,%eax
   13ce1:	77 5a                	ja     13d3d <write_esc_square+0xed>
   13ce3:	8b 04 85 c0 99 01 00 	mov    0x199c0(,%eax,4),%eax
   13cea:	ff e0                	jmp    *%eax
        case 'm': 
            set_font_style(console);
   13cec:	ff 75 08             	pushl  0x8(%ebp)
   13cef:	e8 d1 fd ff ff       	call   13ac5 <set_font_style>
   13cf4:	83 c4 04             	add    $0x4,%esp
            break;
   13cf7:	eb 44                	jmp    13d3d <write_esc_square+0xed>
        case 'D':	
            move_left(console, console->esc_param[0]);
   13cf9:	8b 45 08             	mov    0x8(%ebp),%eax
   13cfc:	8b 40 28             	mov    0x28(%eax),%eax
   13cff:	50                   	push   %eax
   13d00:	ff 75 08             	pushl  0x8(%ebp)
   13d03:	e8 9f fe ff ff       	call   13ba7 <move_left>
   13d08:	83 c4 08             	add    $0x8,%esp
            break;
   13d0b:	eb 30                	jmp    13d3d <write_esc_square+0xed>
        case 'C':
            move_right(console, console->esc_param[0]);
   13d0d:	8b 45 08             	mov    0x8(%ebp),%eax
   13d10:	8b 40 28             	mov    0x28(%eax),%eax
   13d13:	50                   	push   %eax
   13d14:	ff 75 08             	pushl  0x8(%ebp)
   13d17:	e8 42 fe ff ff       	call   13b5e <move_right>
   13d1c:	83 c4 08             	add    $0x8,%esp
            break;
   13d1f:	eb 1c                	jmp    13d3d <write_esc_square+0xed>
        case 'H':
        case 'f':
            move_cursor(console);
   13d21:	ff 75 08             	pushl  0x8(%ebp)
   13d24:	e8 b5 fe ff ff       	call   13bde <move_cursor>
   13d29:	83 c4 04             	add    $0x4,%esp
            break;
   13d2c:	eb 0f                	jmp    13d3d <write_esc_square+0xed>
        case 'J':
            erase_in_display(console);
   13d2e:	83 ec 0c             	sub    $0xc,%esp
   13d31:	ff 75 08             	pushl  0x8(%ebp)
   13d34:	e8 c3 fe ff ff       	call   13bfc <erase_in_display>
   13d39:	83 c4 10             	add    $0x10,%esp
            break;
   13d3c:	90                   	nop
        }
        console->write_state = CONSOLE_WRITE_NORMAL;
   13d3d:	8b 45 08             	mov    0x8(%ebp),%eax
   13d40:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    }
}
   13d47:	90                   	nop
   13d48:	c9                   	leave  
   13d49:	c3                   	ret    

00013d4a <console_write>:

int console_write (tty_t * tty) {
   13d4a:	55                   	push   %ebp
   13d4b:	89 e5                	mov    %esp,%ebp
   13d4d:	83 ec 18             	sub    $0x18,%esp
	console_t * console = console_buf + tty->console_idx;
   13d50:	8b 45 08             	mov    0x8(%ebp),%eax
   13d53:	8b 80 50 04 00 00    	mov    0x450(%eax),%eax
   13d59:	6b c0 68             	imul   $0x68,%eax,%eax
   13d5c:	05 40 60 03 00       	add    $0x36040,%eax
   13d61:	89 45 f0             	mov    %eax,-0x10(%ebp)

    int len = 0;
   13d64:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&console->mutex);
   13d6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13d6e:	83 c0 54             	add    $0x54,%eax
   13d71:	83 ec 0c             	sub    $0xc,%esp
   13d74:	50                   	push   %eax
   13d75:	e8 0a 45 00 00       	call   18284 <mutex_lock>
   13d7a:	83 c4 10             	add    $0x10,%esp
    do {
        char c;

        int err = tty_fifo_get(&tty->ofifo, &c);
   13d7d:	8b 45 08             	mov    0x8(%ebp),%eax
   13d80:	8d 90 00 02 00 00    	lea    0x200(%eax),%edx
   13d86:	83 ec 08             	sub    $0x8,%esp
   13d89:	8d 45 eb             	lea    -0x15(%ebp),%eax
   13d8c:	50                   	push   %eax
   13d8d:	52                   	push   %edx
   13d8e:	e8 6a 14 00 00       	call   151fd <tty_fifo_get>
   13d93:	83 c4 10             	add    $0x10,%esp
   13d96:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (err < 0) {
   13d99:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13d9d:	79 2d                	jns    13dcc <console_write+0x82>
                write_esc_square(console, c);
                break;
        }
        len++;
    }while (1);
    mutex_unlock(&console->mutex);
   13d9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13da2:	83 c0 54             	add    $0x54,%eax
   13da5:	83 ec 0c             	sub    $0xc,%esp
   13da8:	50                   	push   %eax
   13da9:	e8 6c 45 00 00       	call   1831a <mutex_unlock>
   13dae:	83 c4 10             	add    $0x10,%esp
    if(tty->console_idx == curr_console_idx)
   13db1:	8b 45 08             	mov    0x8(%ebp),%eax
   13db4:	8b 90 50 04 00 00    	mov    0x450(%eax),%edx
   13dba:	a1 80 63 03 00       	mov    0x36380,%eax
   13dbf:	39 c2                	cmp    %eax,%edx
   13dc1:	0f 84 80 00 00 00    	je     13e47 <console_write+0xfd>
   13dc7:	e9 89 00 00 00       	jmp    13e55 <console_write+0x10b>
        sem_notify(&tty->osem);
   13dcc:	8b 45 08             	mov    0x8(%ebp),%eax
   13dcf:	05 28 04 00 00       	add    $0x428,%eax
   13dd4:	83 ec 0c             	sub    $0xc,%esp
   13dd7:	50                   	push   %eax
   13dd8:	e8 96 46 00 00       	call   18473 <sem_notify>
   13ddd:	83 c4 10             	add    $0x10,%esp
        switch (console->write_state) {
   13de0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13de3:	8b 40 04             	mov    0x4(%eax),%eax
   13de6:	83 f8 01             	cmp    $0x1,%eax
   13de9:	74 24                	je     13e0f <console_write+0xc5>
   13deb:	83 f8 01             	cmp    $0x1,%eax
   13dee:	72 07                	jb     13df7 <console_write+0xad>
   13df0:	83 f8 02             	cmp    $0x2,%eax
   13df3:	74 32                	je     13e27 <console_write+0xdd>
   13df5:	eb 47                	jmp    13e3e <console_write+0xf4>
                write_normal(console, c);
   13df7:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13dfb:	0f be c0             	movsbl %al,%eax
   13dfe:	83 ec 08             	sub    $0x8,%esp
   13e01:	50                   	push   %eax
   13e02:	ff 75 f0             	pushl  -0x10(%ebp)
   13e05:	e8 3e fb ff ff       	call   13948 <write_normal>
   13e0a:	83 c4 10             	add    $0x10,%esp
                break;
   13e0d:	eb 2f                	jmp    13e3e <console_write+0xf4>
                write_esc(console, c);
   13e0f:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13e13:	0f be c0             	movsbl %al,%eax
   13e16:	83 ec 08             	sub    $0x8,%esp
   13e19:	50                   	push   %eax
   13e1a:	ff 75 f0             	pushl  -0x10(%ebp)
   13e1d:	e8 2e fc ff ff       	call   13a50 <write_esc>
   13e22:	83 c4 10             	add    $0x10,%esp
                break;
   13e25:	eb 17                	jmp    13e3e <console_write+0xf4>
                write_esc_square(console, c);
   13e27:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   13e2b:	0f be c0             	movsbl %al,%eax
   13e2e:	83 ec 08             	sub    $0x8,%esp
   13e31:	50                   	push   %eax
   13e32:	ff 75 f0             	pushl  -0x10(%ebp)
   13e35:	e8 16 fe ff ff       	call   13c50 <write_esc_square>
   13e3a:	83 c4 10             	add    $0x10,%esp
                break;
   13e3d:	90                   	nop
        len++;
   13e3e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    do {
   13e42:	e9 36 ff ff ff       	jmp    13d7d <console_write+0x33>
        update_cursor_pos(console);
   13e47:	83 ec 0c             	sub    $0xc,%esp
   13e4a:	ff 75 f0             	pushl  -0x10(%ebp)
   13e4d:	e8 ad f6 ff ff       	call   134ff <update_cursor_pos>
   13e52:	83 c4 10             	add    $0x10,%esp
    return len;
   13e55:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13e58:	c9                   	leave  
   13e59:	c3                   	ret    

00013e5a <console_close>:
int console_close(int console)
{
   13e5a:	55                   	push   %ebp
   13e5b:	89 e5                	mov    %esp,%ebp
    return 0;
   13e5d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13e62:	5d                   	pop    %ebp
   13e63:	c3                   	ret    

00013e64 <set_col0>:
void set_col0(console_t* console)
{
   13e64:	55                   	push   %ebp
   13e65:	89 e5                	mov    %esp,%ebp
    console->cur_col = 0;
   13e67:	8b 45 08             	mov    0x8(%ebp),%eax
   13e6a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
   13e71:	90                   	nop
   13e72:	5d                   	pop    %ebp
   13e73:	c3                   	ret    

00013e74 <add_row1>:

void add_row1(console_t* console)
{
   13e74:	55                   	push   %ebp
   13e75:	89 e5                	mov    %esp,%ebp
   13e77:	83 ec 08             	sub    $0x8,%esp
    if((++console->cur_row) >= console->disp_row)
   13e7a:	8b 45 08             	mov    0x8(%ebp),%eax
   13e7d:	8b 40 10             	mov    0x10(%eax),%eax
   13e80:	8d 50 01             	lea    0x1(%eax),%edx
   13e83:	8b 45 08             	mov    0x8(%ebp),%eax
   13e86:	89 50 10             	mov    %edx,0x10(%eax)
   13e89:	8b 45 08             	mov    0x8(%ebp),%eax
   13e8c:	8b 50 10             	mov    0x10(%eax),%edx
   13e8f:	8b 45 08             	mov    0x8(%ebp),%eax
   13e92:	8b 40 08             	mov    0x8(%eax),%eax
   13e95:	39 c2                	cmp    %eax,%edx
   13e97:	7c 10                	jl     13ea9 <add_row1+0x35>
    {
        scroll_up(console, 1);
   13e99:	83 ec 08             	sub    $0x8,%esp
   13e9c:	6a 01                	push   $0x1
   13e9e:	ff 75 08             	pushl  0x8(%ebp)
   13ea1:	e8 6d 00 00 00       	call   13f13 <scroll_up>
   13ea6:	83 c4 10             	add    $0x10,%esp
    }
}
   13ea9:	90                   	nop
   13eaa:	c9                   	leave  
   13eab:	c3                   	ret    

00013eac <erase_rows>:
static void erase_rows (console_t * console, int start, int end) {
   13eac:	55                   	push   %ebp
   13ead:	89 e5                	mov    %esp,%ebp
   13eaf:	83 ec 10             	sub    $0x10,%esp
    volatile disp_char_t * disp_start = console->base + console->disp_col * start;
   13eb2:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb5:	8b 10                	mov    (%eax),%edx
   13eb7:	8b 45 08             	mov    0x8(%ebp),%eax
   13eba:	8b 40 0c             	mov    0xc(%eax),%eax
   13ebd:	0f af 45 0c          	imul   0xc(%ebp),%eax
   13ec1:	01 c0                	add    %eax,%eax
   13ec3:	01 d0                	add    %edx,%eax
   13ec5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    volatile disp_char_t * disp_end = console->base + console->disp_col * (end + 1);
   13ec8:	8b 45 08             	mov    0x8(%ebp),%eax
   13ecb:	8b 10                	mov    (%eax),%edx
   13ecd:	8b 45 08             	mov    0x8(%ebp),%eax
   13ed0:	8b 40 0c             	mov    0xc(%eax),%eax
   13ed3:	8b 4d 10             	mov    0x10(%ebp),%ecx
   13ed6:	83 c1 01             	add    $0x1,%ecx
   13ed9:	0f af c1             	imul   %ecx,%eax
   13edc:	01 c0                	add    %eax,%eax
   13ede:	01 d0                	add    %edx,%eax
   13ee0:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (disp_start < disp_end) {
   13ee3:	eb 23                	jmp    13f08 <erase_rows+0x5c>
        disp_start->value = ' ';
   13ee5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13ee8:	c6 00 20             	movb   $0x20,(%eax)
        disp_start->color = (console->foreground) | (console -> background << 4);
   13eeb:	8b 45 08             	mov    0x8(%ebp),%eax
   13eee:	8b 40 18             	mov    0x18(%eax),%eax
   13ef1:	89 c2                	mov    %eax,%edx
   13ef3:	8b 45 08             	mov    0x8(%ebp),%eax
   13ef6:	8b 40 1c             	mov    0x1c(%eax),%eax
   13ef9:	c1 e0 04             	shl    $0x4,%eax
   13efc:	09 c2                	or     %eax,%edx
   13efe:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13f01:	88 50 01             	mov    %dl,0x1(%eax)

        disp_start++;
   13f04:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
    while (disp_start < disp_end) {
   13f08:	8b 45 fc             	mov    -0x4(%ebp),%eax
   13f0b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   13f0e:	72 d5                	jb     13ee5 <erase_rows+0x39>
    }
}
   13f10:	90                   	nop
   13f11:	c9                   	leave  
   13f12:	c3                   	ret    

00013f13 <scroll_up>:
static void scroll_up(console_t * console, int lines) {
   13f13:	55                   	push   %ebp
   13f14:	89 e5                	mov    %esp,%ebp
   13f16:	83 ec 18             	sub    $0x18,%esp
    disp_char_t * dest = console->base;
   13f19:	8b 45 08             	mov    0x8(%ebp),%eax
   13f1c:	8b 00                	mov    (%eax),%eax
   13f1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    disp_char_t * src = console->base + console->disp_col * lines;
   13f21:	8b 45 08             	mov    0x8(%ebp),%eax
   13f24:	8b 10                	mov    (%eax),%edx
   13f26:	8b 45 08             	mov    0x8(%ebp),%eax
   13f29:	8b 40 0c             	mov    0xc(%eax),%eax
   13f2c:	0f af 45 0c          	imul   0xc(%ebp),%eax
   13f30:	01 c0                	add    %eax,%eax
   13f32:	01 d0                	add    %edx,%eax
   13f34:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint32_t size = (console->disp_row - lines) * console->disp_col * sizeof(disp_char_t);
   13f37:	8b 45 08             	mov    0x8(%ebp),%eax
   13f3a:	8b 40 08             	mov    0x8(%eax),%eax
   13f3d:	2b 45 0c             	sub    0xc(%ebp),%eax
   13f40:	89 c2                	mov    %eax,%edx
   13f42:	8b 45 08             	mov    0x8(%ebp),%eax
   13f45:	8b 40 0c             	mov    0xc(%eax),%eax
   13f48:	0f af c2             	imul   %edx,%eax
   13f4b:	01 c0                	add    %eax,%eax
   13f4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    kernel_memcpy((void*)dest, (void*)src, size);
   13f50:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13f53:	83 ec 04             	sub    $0x4,%esp
   13f56:	50                   	push   %eax
   13f57:	ff 75 f0             	pushl  -0x10(%ebp)
   13f5a:	ff 75 f4             	pushl  -0xc(%ebp)
   13f5d:	e8 f1 49 00 00       	call   18953 <kernel_memcpy>
   13f62:	83 c4 10             	add    $0x10,%esp

    erase_rows(console, console->disp_row - lines, console->disp_row - 1);
   13f65:	8b 45 08             	mov    0x8(%ebp),%eax
   13f68:	8b 40 08             	mov    0x8(%eax),%eax
   13f6b:	8d 50 ff             	lea    -0x1(%eax),%edx
   13f6e:	8b 45 08             	mov    0x8(%ebp),%eax
   13f71:	8b 40 08             	mov    0x8(%eax),%eax
   13f74:	2b 45 0c             	sub    0xc(%ebp),%eax
   13f77:	83 ec 04             	sub    $0x4,%esp
   13f7a:	52                   	push   %edx
   13f7b:	50                   	push   %eax
   13f7c:	ff 75 08             	pushl  0x8(%ebp)
   13f7f:	e8 28 ff ff ff       	call   13eac <erase_rows>
   13f84:	83 c4 10             	add    $0x10,%esp

    console->cur_row -= lines;
   13f87:	8b 45 08             	mov    0x8(%ebp),%eax
   13f8a:	8b 40 10             	mov    0x10(%eax),%eax
   13f8d:	2b 45 0c             	sub    0xc(%ebp),%eax
   13f90:	89 c2                	mov    %eax,%edx
   13f92:	8b 45 08             	mov    0x8(%ebp),%eax
   13f95:	89 50 10             	mov    %edx,0x10(%eax)
   13f98:	90                   	nop
   13f99:	c9                   	leave  
   13f9a:	c3                   	ret    

00013f9b <is_devid_bad>:
    &dev_tty_desc,
    &dev_disk_desc,
};
static device_t dev_tbl[DEV_TBL_SIZE];

static int is_devid_bad (int dev_id) {
   13f9b:	55                   	push   %ebp
   13f9c:	89 e5                	mov    %esp,%ebp
    if ((dev_id < 0) || (dev_id >=  sizeof(dev_tbl) / sizeof(dev_tbl[0]))) {
   13f9e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13fa2:	78 08                	js     13fac <is_devid_bad+0x11>
   13fa4:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa7:	83 f8 7f             	cmp    $0x7f,%eax
   13faa:	76 07                	jbe    13fb3 <is_devid_bad+0x18>
        return 1;
   13fac:	b8 01 00 00 00       	mov    $0x1,%eax
   13fb1:	eb 24                	jmp    13fd7 <is_devid_bad+0x3c>
    }

    if (dev_tbl[dev_id].desc == (dev_desc_t *)0) {
   13fb3:	8b 55 08             	mov    0x8(%ebp),%edx
   13fb6:	89 d0                	mov    %edx,%eax
   13fb8:	c1 e0 02             	shl    $0x2,%eax
   13fbb:	01 d0                	add    %edx,%eax
   13fbd:	c1 e0 02             	shl    $0x2,%eax
   13fc0:	05 a0 63 03 00       	add    $0x363a0,%eax
   13fc5:	8b 00                	mov    (%eax),%eax
   13fc7:	85 c0                	test   %eax,%eax
   13fc9:	75 07                	jne    13fd2 <is_devid_bad+0x37>
        return 1;
   13fcb:	b8 01 00 00 00       	mov    $0x1,%eax
   13fd0:	eb 05                	jmp    13fd7 <is_devid_bad+0x3c>
    }

    return 0;
   13fd2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13fd7:	5d                   	pop    %ebp
   13fd8:	c3                   	ret    

00013fd9 <dev_open>:


/**
 * @brief 打开指定的设备
 */
int dev_open (int major, int minor, void * data) {
   13fd9:	55                   	push   %ebp
   13fda:	89 e5                	mov    %esp,%ebp
   13fdc:	83 ec 28             	sub    $0x28,%esp
    device_t* free = (device_t*)0;
   13fdf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    irq_state_t state =  enter_protection();
   13fe6:	e8 3b f4 ff ff       	call   13426 <enter_protection>
   13feb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    for(int i = 0; i < (sizeof(dev_tbl)/ sizeof(device_t)); ++i)
   13fee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13ff5:	eb 68                	jmp    1405f <dev_open+0x86>
    {
        device_t* device = dev_tbl + i;
   13ff7:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13ffa:	89 d0                	mov    %edx,%eax
   13ffc:	c1 e0 02             	shl    $0x2,%eax
   13fff:	01 d0                	add    %edx,%eax
   14001:	c1 e0 02             	shl    $0x2,%eax
   14004:	05 a0 63 03 00       	add    $0x363a0,%eax
   14009:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(device->open_count == 0)
   1400c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1400f:	8b 40 10             	mov    0x10(%eax),%eax
   14012:	85 c0                	test   %eax,%eax
   14014:	75 08                	jne    1401e <dev_open+0x45>
        {
            free = device;
   14016:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14019:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1401c:	eb 3d                	jmp    1405b <dev_open+0x82>
            // break;
        }
        else{
            if(device -> desc->major == major && device->minor == minor)
   1401e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14021:	8b 00                	mov    (%eax),%eax
   14023:	8b 40 20             	mov    0x20(%eax),%eax
   14026:	39 45 08             	cmp    %eax,0x8(%ebp)
   14029:	75 30                	jne    1405b <dev_open+0x82>
   1402b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1402e:	8b 40 04             	mov    0x4(%eax),%eax
   14031:	39 45 0c             	cmp    %eax,0xc(%ebp)
   14034:	75 25                	jne    1405b <dev_open+0x82>
            {
                device->open_count ++;
   14036:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14039:	8b 40 10             	mov    0x10(%eax),%eax
   1403c:	8d 50 01             	lea    0x1(%eax),%edx
   1403f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14042:	89 50 10             	mov    %edx,0x10(%eax)
                leave_protection(state);
   14045:	83 ec 0c             	sub    $0xc,%esp
   14048:	ff 75 e4             	pushl  -0x1c(%ebp)
   1404b:	e8 ee f3 ff ff       	call   1343e <leave_protection>
   14050:	83 c4 10             	add    $0x10,%esp
                return i;
   14053:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14056:	e9 c6 00 00 00       	jmp    14121 <dev_open+0x148>
    for(int i = 0; i < (sizeof(dev_tbl)/ sizeof(device_t)); ++i)
   1405b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1405f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14062:	83 f8 7f             	cmp    $0x7f,%eax
   14065:	76 90                	jbe    13ff7 <dev_open+0x1e>
            }
        }
    }

    dev_desc_t* desc = (dev_desc_t*)0;
   14067:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(int i = 0; i < (sizeof(dev_desc_tbl)/ sizeof(dev_desc_tbl[0])); ++i)
   1406e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   14075:	eb 22                	jmp    14099 <dev_open+0xc0>
    {   dev_desc_t* dev_desc = dev_desc_tbl[i];
   14077:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1407a:	8b 04 85 50 b0 01 00 	mov    0x1b050(,%eax,4),%eax
   14081:	89 45 dc             	mov    %eax,-0x24(%ebp)
        if(dev_desc -> major == major)
   14084:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14087:	8b 40 20             	mov    0x20(%eax),%eax
   1408a:	39 45 08             	cmp    %eax,0x8(%ebp)
   1408d:	75 06                	jne    14095 <dev_open+0xbc>
        {
            desc = dev_desc;
   1408f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14092:	89 45 ec             	mov    %eax,-0x14(%ebp)
    for(int i = 0; i < (sizeof(dev_desc_tbl)/ sizeof(dev_desc_tbl[0])); ++i)
   14095:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14099:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1409c:	83 f8 01             	cmp    $0x1,%eax
   1409f:	76 d6                	jbe    14077 <dev_open+0x9e>
        }
    }
    if(desc && free)
   140a1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   140a5:	74 67                	je     1410e <dev_open+0x135>
   140a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   140ab:	74 61                	je     1410e <dev_open+0x135>
    {
        free -> minor = minor;
   140ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   140b0:	8b 55 0c             	mov    0xc(%ebp),%edx
   140b3:	89 50 04             	mov    %edx,0x4(%eax)
        free -> data =data;
   140b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   140b9:	8b 55 10             	mov    0x10(%ebp),%edx
   140bc:	89 50 0c             	mov    %edx,0xc(%eax)
        free -> desc = desc;
   140bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   140c2:	8b 55 ec             	mov    -0x14(%ebp),%edx
   140c5:	89 10                	mov    %edx,(%eax)
        int err = desc->open(free);
   140c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   140ca:	8b 40 24             	mov    0x24(%eax),%eax
   140cd:	83 ec 0c             	sub    $0xc,%esp
   140d0:	ff 75 f4             	pushl  -0xc(%ebp)
   140d3:	ff d0                	call   *%eax
   140d5:	83 c4 10             	add    $0x10,%esp
   140d8:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if(err == 0)
   140db:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   140df:	75 2d                	jne    1410e <dev_open+0x135>
        {
            free -> open_count = 1;
   140e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   140e4:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
            leave_protection(state);
   140eb:	83 ec 0c             	sub    $0xc,%esp
   140ee:	ff 75 e4             	pushl  -0x1c(%ebp)
   140f1:	e8 48 f3 ff ff       	call   1343e <leave_protection>
   140f6:	83 c4 10             	add    $0x10,%esp
            return free - dev_tbl;
   140f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   140fc:	ba a0 63 03 00       	mov    $0x363a0,%edx
   14101:	29 d0                	sub    %edx,%eax
   14103:	c1 f8 02             	sar    $0x2,%eax
   14106:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
   1410c:	eb 13                	jmp    14121 <dev_open+0x148>
        }
        
    }
    leave_protection(state);
   1410e:	83 ec 0c             	sub    $0xc,%esp
   14111:	ff 75 e4             	pushl  -0x1c(%ebp)
   14114:	e8 25 f3 ff ff       	call   1343e <leave_protection>
   14119:	83 c4 10             	add    $0x10,%esp
    return -1;
   1411c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   14121:	c9                   	leave  
   14122:	c3                   	ret    

00014123 <dev_read>:

/**
 * @brief 读取指定字节的数据
 */
int dev_read (int dev_id, int addr, char * buf, int size) {
   14123:	55                   	push   %ebp
   14124:	89 e5                	mov    %esp,%ebp
   14126:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id))
   14129:	ff 75 08             	pushl  0x8(%ebp)
   1412c:	e8 6a fe ff ff       	call   13f9b <is_devid_bad>
   14131:	83 c4 04             	add    $0x4,%esp
   14134:	85 c0                	test   %eax,%eax
   14136:	74 07                	je     1413f <dev_read+0x1c>
        return -1;
   14138:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1413d:	eb 2e                	jmp    1416d <dev_read+0x4a>
    device_t* device = dev_tbl + dev_id;
   1413f:	8b 55 08             	mov    0x8(%ebp),%edx
   14142:	89 d0                	mov    %edx,%eax
   14144:	c1 e0 02             	shl    $0x2,%eax
   14147:	01 d0                	add    %edx,%eax
   14149:	c1 e0 02             	shl    $0x2,%eax
   1414c:	05 a0 63 03 00       	add    $0x363a0,%eax
   14151:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    return device->desc->read(device, addr, buf, size);
   14154:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14157:	8b 00                	mov    (%eax),%eax
   14159:	8b 40 28             	mov    0x28(%eax),%eax
   1415c:	ff 75 14             	pushl  0x14(%ebp)
   1415f:	ff 75 10             	pushl  0x10(%ebp)
   14162:	ff 75 0c             	pushl  0xc(%ebp)
   14165:	ff 75 f4             	pushl  -0xc(%ebp)
   14168:	ff d0                	call   *%eax
   1416a:	83 c4 10             	add    $0x10,%esp
}
   1416d:	c9                   	leave  
   1416e:	c3                   	ret    

0001416f <dev_write>:

/**
 * @brief 写指定字节的数据
 */
int dev_write (int dev_id, int addr, char * buf, int size) {
   1416f:	55                   	push   %ebp
   14170:	89 e5                	mov    %esp,%ebp
   14172:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id))
   14175:	ff 75 08             	pushl  0x8(%ebp)
   14178:	e8 1e fe ff ff       	call   13f9b <is_devid_bad>
   1417d:	83 c4 04             	add    $0x4,%esp
   14180:	85 c0                	test   %eax,%eax
   14182:	74 07                	je     1418b <dev_write+0x1c>
        return -1;
   14184:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14189:	eb 2e                	jmp    141b9 <dev_write+0x4a>
    device_t* device = dev_tbl + dev_id;
   1418b:	8b 55 08             	mov    0x8(%ebp),%edx
   1418e:	89 d0                	mov    %edx,%eax
   14190:	c1 e0 02             	shl    $0x2,%eax
   14193:	01 d0                	add    %edx,%eax
   14195:	c1 e0 02             	shl    $0x2,%eax
   14198:	05 a0 63 03 00       	add    $0x363a0,%eax
   1419d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    return device->desc->write(device, addr, buf, size);
   141a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   141a3:	8b 00                	mov    (%eax),%eax
   141a5:	8b 40 2c             	mov    0x2c(%eax),%eax
   141a8:	ff 75 14             	pushl  0x14(%ebp)
   141ab:	ff 75 10             	pushl  0x10(%ebp)
   141ae:	ff 75 0c             	pushl  0xc(%ebp)
   141b1:	ff 75 f4             	pushl  -0xc(%ebp)
   141b4:	ff d0                	call   *%eax
   141b6:	83 c4 10             	add    $0x10,%esp
}
   141b9:	c9                   	leave  
   141ba:	c3                   	ret    

000141bb <dev_control>:

/**
 * @brief 发送控制命令
 */

int dev_control (int dev_id, int cmd, int arg0, int arg1) {
   141bb:	55                   	push   %ebp
   141bc:	89 e5                	mov    %esp,%ebp
   141be:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id))
   141c1:	ff 75 08             	pushl  0x8(%ebp)
   141c4:	e8 d2 fd ff ff       	call   13f9b <is_devid_bad>
   141c9:	83 c4 04             	add    $0x4,%esp
   141cc:	85 c0                	test   %eax,%eax
   141ce:	74 07                	je     141d7 <dev_control+0x1c>
        return -1;
   141d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   141d5:	eb 2e                	jmp    14205 <dev_control+0x4a>
    device_t* device = dev_tbl + dev_id;
   141d7:	8b 55 08             	mov    0x8(%ebp),%edx
   141da:	89 d0                	mov    %edx,%eax
   141dc:	c1 e0 02             	shl    $0x2,%eax
   141df:	01 d0                	add    %edx,%eax
   141e1:	c1 e0 02             	shl    $0x2,%eax
   141e4:	05 a0 63 03 00       	add    $0x363a0,%eax
   141e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    return device->desc->control(device, cmd, arg0, arg1);
   141ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
   141ef:	8b 00                	mov    (%eax),%eax
   141f1:	8b 40 34             	mov    0x34(%eax),%eax
   141f4:	ff 75 14             	pushl  0x14(%ebp)
   141f7:	ff 75 10             	pushl  0x10(%ebp)
   141fa:	ff 75 0c             	pushl  0xc(%ebp)
   141fd:	ff 75 f4             	pushl  -0xc(%ebp)
   14200:	ff d0                	call   *%eax
   14202:	83 c4 10             	add    $0x10,%esp
}
   14205:	c9                   	leave  
   14206:	c3                   	ret    

00014207 <dev_close>:

/**
 * @brief 关闭设备
 */
void dev_close (int dev_id) {
   14207:	55                   	push   %ebp
   14208:	89 e5                	mov    %esp,%ebp
   1420a:	83 ec 18             	sub    $0x18,%esp
    if(is_devid_bad(dev_id))
   1420d:	ff 75 08             	pushl  0x8(%ebp)
   14210:	e8 86 fd ff ff       	call   13f9b <is_devid_bad>
   14215:	83 c4 04             	add    $0x4,%esp
   14218:	85 c0                	test   %eax,%eax
   1421a:	75 6c                	jne    14288 <dev_close+0x81>
        return;
    irq_state_t state = enter_protection();
   1421c:	e8 05 f2 ff ff       	call   13426 <enter_protection>
   14221:	89 45 f4             	mov    %eax,-0xc(%ebp)
    device_t* device = dev_tbl + dev_id;;
   14224:	8b 55 08             	mov    0x8(%ebp),%edx
   14227:	89 d0                	mov    %edx,%eax
   14229:	c1 e0 02             	shl    $0x2,%eax
   1422c:	01 d0                	add    %edx,%eax
   1422e:	c1 e0 02             	shl    $0x2,%eax
   14231:	05 a0 63 03 00       	add    $0x363a0,%eax
   14236:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(--device->open_count == 0)
   14239:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1423c:	8b 40 10             	mov    0x10(%eax),%eax
   1423f:	8d 50 ff             	lea    -0x1(%eax),%edx
   14242:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14245:	89 50 10             	mov    %edx,0x10(%eax)
   14248:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1424b:	8b 40 10             	mov    0x10(%eax),%eax
   1424e:	85 c0                	test   %eax,%eax
   14250:	75 25                	jne    14277 <dev_close+0x70>
    {
        device->desc->close(device);
   14252:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14255:	8b 00                	mov    (%eax),%eax
   14257:	8b 40 30             	mov    0x30(%eax),%eax
   1425a:	83 ec 0c             	sub    $0xc,%esp
   1425d:	ff 75 f0             	pushl  -0x10(%ebp)
   14260:	ff d0                	call   *%eax
   14262:	83 c4 10             	add    $0x10,%esp
        kernel_memset((void*)device, 0, sizeof(device_t));
   14265:	83 ec 04             	sub    $0x4,%esp
   14268:	6a 14                	push   $0x14
   1426a:	6a 00                	push   $0x0
   1426c:	ff 75 f0             	pushl  -0x10(%ebp)
   1426f:	e8 2e 47 00 00       	call   189a2 <kernel_memset>
   14274:	83 c4 10             	add    $0x10,%esp
    }
    leave_protection(state);
   14277:	83 ec 0c             	sub    $0xc,%esp
   1427a:	ff 75 f4             	pushl  -0xc(%ebp)
   1427d:	e8 bc f1 ff ff       	call   1343e <leave_protection>
   14282:	83 c4 10             	add    $0x10,%esp
    return ;
   14285:	90                   	nop
   14286:	eb 01                	jmp    14289 <dev_close+0x82>
        return;
   14288:	90                   	nop
}
   14289:	c9                   	leave  
   1428a:	c3                   	ret    

0001428b <inb>:
static inline uint8_t inb(uint16_t  port) {
   1428b:	55                   	push   %ebp
   1428c:	89 e5                	mov    %esp,%ebp
   1428e:	83 ec 14             	sub    $0x14,%esp
   14291:	8b 45 08             	mov    0x8(%ebp),%eax
   14294:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   14298:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1429c:	89 c2                	mov    %eax,%edx
   1429e:	ec                   	in     (%dx),%al
   1429f:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   142a2:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   142a6:	c9                   	leave  
   142a7:	c3                   	ret    

000142a8 <inw>:
static inline uint16_t inw(uint16_t  port) {
   142a8:	55                   	push   %ebp
   142a9:	89 e5                	mov    %esp,%ebp
   142ab:	83 ec 14             	sub    $0x14,%esp
   142ae:	8b 45 08             	mov    0x8(%ebp),%eax
   142b1:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   142b5:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   142b9:	89 c2                	mov    %eax,%edx
   142bb:	66 ed                	in     (%dx),%ax
   142bd:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   142c1:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   142c5:	c9                   	leave  
   142c6:	c3                   	ret    

000142c7 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   142c7:	55                   	push   %ebp
   142c8:	89 e5                	mov    %esp,%ebp
   142ca:	83 ec 08             	sub    $0x8,%esp
   142cd:	8b 55 08             	mov    0x8(%ebp),%edx
   142d0:	8b 45 0c             	mov    0xc(%ebp),%eax
   142d3:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   142d7:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   142da:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   142de:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   142e2:	ee                   	out    %al,(%dx)
}
   142e3:	90                   	nop
   142e4:	c9                   	leave  
   142e5:	c3                   	ret    

000142e6 <outw>:
static inline void outw(uint16_t port, uint16_t data) {
   142e6:	55                   	push   %ebp
   142e7:	89 e5                	mov    %esp,%ebp
   142e9:	83 ec 08             	sub    $0x8,%esp
   142ec:	8b 55 08             	mov    0x8(%ebp),%edx
   142ef:	8b 45 0c             	mov    0xc(%ebp),%eax
   142f2:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   142f6:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
	__asm__ __volatile__("out %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   142fa:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   142fe:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
   14302:	66 ef                	out    %ax,(%dx)
}
   14304:	90                   	nop
   14305:	c9                   	leave  
   14306:	c3                   	ret    

00014307 <disk_send_cmd>:
#include "dev/dev.h"
static disk_t disk_buf[DISK_CNT];
static mutex_t mutex;
static sem_t op_sem;
static int task_on_op;
static void disk_send_cmd (disk_t * disk, uint32_t start_sector, uint32_t sector_count, int cmd) {
   14307:	55                   	push   %ebp
   14308:	89 e5                	mov    %esp,%ebp
    outb(DISK_DRIVE(disk), DISK_DRIVE_BASE | disk->drive);		// 使用LBA寻址，并设置驱动器
   1430a:	8b 45 08             	mov    0x8(%ebp),%eax
   1430d:	8b 40 20             	mov    0x20(%eax),%eax
   14310:	83 c8 e0             	or     $0xffffffe0,%eax
   14313:	0f b6 d0             	movzbl %al,%edx
   14316:	8b 45 08             	mov    0x8(%ebp),%eax
   14319:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   1431d:	83 c0 06             	add    $0x6,%eax
   14320:	0f b7 c0             	movzwl %ax,%eax
   14323:	52                   	push   %edx
   14324:	50                   	push   %eax
   14325:	e8 9d ff ff ff       	call   142c7 <outb>
   1432a:	83 c4 08             	add    $0x8,%esp

	// 必须先写高字节
	outb(DISK_SECTOR_COUNT(disk), (uint8_t) (sector_count >> 8));	// 扇区数高8位
   1432d:	8b 45 10             	mov    0x10(%ebp),%eax
   14330:	c1 e8 08             	shr    $0x8,%eax
   14333:	0f b6 d0             	movzbl %al,%edx
   14336:	8b 45 08             	mov    0x8(%ebp),%eax
   14339:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   1433d:	83 c0 02             	add    $0x2,%eax
   14340:	0f b7 c0             	movzwl %ax,%eax
   14343:	52                   	push   %edx
   14344:	50                   	push   %eax
   14345:	e8 7d ff ff ff       	call   142c7 <outb>
   1434a:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_LO(disk), (uint8_t) (start_sector >> 24));		// LBA参数的24~31位
   1434d:	8b 45 0c             	mov    0xc(%ebp),%eax
   14350:	c1 e8 18             	shr    $0x18,%eax
   14353:	0f b6 d0             	movzbl %al,%edx
   14356:	8b 45 08             	mov    0x8(%ebp),%eax
   14359:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   1435d:	83 c0 03             	add    $0x3,%eax
   14360:	0f b7 c0             	movzwl %ax,%eax
   14363:	52                   	push   %edx
   14364:	50                   	push   %eax
   14365:	e8 5d ff ff ff       	call   142c7 <outb>
   1436a:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_MID(disk), 0);									// 高于32位不支持
   1436d:	8b 45 08             	mov    0x8(%ebp),%eax
   14370:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14374:	83 c0 04             	add    $0x4,%eax
   14377:	0f b7 c0             	movzwl %ax,%eax
   1437a:	6a 00                	push   $0x0
   1437c:	50                   	push   %eax
   1437d:	e8 45 ff ff ff       	call   142c7 <outb>
   14382:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_HI(disk), 0);										// 高于32位不支持
   14385:	8b 45 08             	mov    0x8(%ebp),%eax
   14388:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   1438c:	83 c0 05             	add    $0x5,%eax
   1438f:	0f b7 c0             	movzwl %ax,%eax
   14392:	6a 00                	push   $0x0
   14394:	50                   	push   %eax
   14395:	e8 2d ff ff ff       	call   142c7 <outb>
   1439a:	83 c4 08             	add    $0x8,%esp
	outb(DISK_SECTOR_COUNT(disk), (uint8_t) (sector_count));		// 扇区数量低8位
   1439d:	8b 45 10             	mov    0x10(%ebp),%eax
   143a0:	0f b6 d0             	movzbl %al,%edx
   143a3:	8b 45 08             	mov    0x8(%ebp),%eax
   143a6:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   143aa:	83 c0 02             	add    $0x2,%eax
   143ad:	0f b7 c0             	movzwl %ax,%eax
   143b0:	52                   	push   %edx
   143b1:	50                   	push   %eax
   143b2:	e8 10 ff ff ff       	call   142c7 <outb>
   143b7:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_LO(disk), (uint8_t) (start_sector >> 0));			// LBA参数的0-7
   143ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   143bd:	0f b6 d0             	movzbl %al,%edx
   143c0:	8b 45 08             	mov    0x8(%ebp),%eax
   143c3:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   143c7:	83 c0 03             	add    $0x3,%eax
   143ca:	0f b7 c0             	movzwl %ax,%eax
   143cd:	52                   	push   %edx
   143ce:	50                   	push   %eax
   143cf:	e8 f3 fe ff ff       	call   142c7 <outb>
   143d4:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_MID(disk), (uint8_t) (start_sector >> 8));		// LBA参数的8-15位
   143d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   143da:	c1 e8 08             	shr    $0x8,%eax
   143dd:	0f b6 d0             	movzbl %al,%edx
   143e0:	8b 45 08             	mov    0x8(%ebp),%eax
   143e3:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   143e7:	83 c0 04             	add    $0x4,%eax
   143ea:	0f b7 c0             	movzwl %ax,%eax
   143ed:	52                   	push   %edx
   143ee:	50                   	push   %eax
   143ef:	e8 d3 fe ff ff       	call   142c7 <outb>
   143f4:	83 c4 08             	add    $0x8,%esp
	outb(DISK_LBA_HI(disk), (uint8_t) (start_sector >> 16));		// LBA参数的16-23位
   143f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   143fa:	c1 e8 10             	shr    $0x10,%eax
   143fd:	0f b6 d0             	movzbl %al,%edx
   14400:	8b 45 08             	mov    0x8(%ebp),%eax
   14403:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14407:	83 c0 05             	add    $0x5,%eax
   1440a:	0f b7 c0             	movzwl %ax,%eax
   1440d:	52                   	push   %edx
   1440e:	50                   	push   %eax
   1440f:	e8 b3 fe ff ff       	call   142c7 <outb>
   14414:	83 c4 08             	add    $0x8,%esp

	// 选择对应的主-从磁盘
	outb(DISK_CMD(disk), (uint8_t)cmd);
   14417:	8b 45 14             	mov    0x14(%ebp),%eax
   1441a:	0f b6 d0             	movzbl %al,%edx
   1441d:	8b 45 08             	mov    0x8(%ebp),%eax
   14420:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14424:	83 c0 07             	add    $0x7,%eax
   14427:	0f b7 c0             	movzwl %ax,%eax
   1442a:	52                   	push   %edx
   1442b:	50                   	push   %eax
   1442c:	e8 96 fe ff ff       	call   142c7 <outb>
   14431:	83 c4 08             	add    $0x8,%esp
}
   14434:	90                   	nop
   14435:	c9                   	leave  
   14436:	c3                   	ret    

00014437 <disk_read_data>:

static inline void disk_read_data (disk_t * disk, void * buf, int size) {
   14437:	55                   	push   %ebp
   14438:	89 e5                	mov    %esp,%ebp
   1443a:	53                   	push   %ebx
   1443b:	83 ec 10             	sub    $0x10,%esp
    uint16_t * c = (uint16_t *)buf;
   1443e:	8b 45 0c             	mov    0xc(%ebp),%eax
   14441:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int i = 0; i < size / 2; i++) {
   14444:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1444b:	eb 23                	jmp    14470 <disk_read_data+0x39>
        *c++ = inw(DISK_DATA(disk));
   1444d:	8b 45 08             	mov    0x8(%ebp),%eax
   14450:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14454:	0f b7 c0             	movzwl %ax,%eax
   14457:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   1445a:	8d 53 02             	lea    0x2(%ebx),%edx
   1445d:	89 55 f8             	mov    %edx,-0x8(%ebp)
   14460:	50                   	push   %eax
   14461:	e8 42 fe ff ff       	call   142a8 <inw>
   14466:	83 c4 04             	add    $0x4,%esp
   14469:	66 89 03             	mov    %ax,(%ebx)
    for (int i = 0; i < size / 2; i++) {
   1446c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14470:	8b 45 10             	mov    0x10(%ebp),%eax
   14473:	89 c2                	mov    %eax,%edx
   14475:	c1 ea 1f             	shr    $0x1f,%edx
   14478:	01 d0                	add    %edx,%eax
   1447a:	d1 f8                	sar    %eax
   1447c:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   1447f:	7c cc                	jl     1444d <disk_read_data+0x16>
    }
}
   14481:	90                   	nop
   14482:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14485:	c9                   	leave  
   14486:	c3                   	ret    

00014487 <disk_write_data>:

static inline void disk_write_data (disk_t * disk, void * buf, int size) {
   14487:	55                   	push   %ebp
   14488:	89 e5                	mov    %esp,%ebp
   1448a:	83 ec 10             	sub    $0x10,%esp
    uint16_t * c = (uint16_t *)buf;
   1448d:	8b 45 0c             	mov    0xc(%ebp),%eax
   14490:	89 45 fc             	mov    %eax,-0x4(%ebp)
    for (int i = 0; i < size / 2; i++) {
   14493:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1449a:	eb 27                	jmp    144c3 <disk_write_data+0x3c>
        outw(DISK_DATA(disk), *c++);
   1449c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1449f:	8d 50 02             	lea    0x2(%eax),%edx
   144a2:	89 55 fc             	mov    %edx,-0x4(%ebp)
   144a5:	0f b7 00             	movzwl (%eax),%eax
   144a8:	0f b7 d0             	movzwl %ax,%edx
   144ab:	8b 45 08             	mov    0x8(%ebp),%eax
   144ae:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   144b2:	0f b7 c0             	movzwl %ax,%eax
   144b5:	52                   	push   %edx
   144b6:	50                   	push   %eax
   144b7:	e8 2a fe ff ff       	call   142e6 <outw>
   144bc:	83 c4 08             	add    $0x8,%esp
    for (int i = 0; i < size / 2; i++) {
   144bf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   144c3:	8b 45 10             	mov    0x10(%ebp),%eax
   144c6:	89 c2                	mov    %eax,%edx
   144c8:	c1 ea 1f             	shr    $0x1f,%edx
   144cb:	01 d0                	add    %edx,%eax
   144cd:	d1 f8                	sar    %eax
   144cf:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   144d2:	7c c8                	jl     1449c <disk_write_data+0x15>
    }
}
   144d4:	90                   	nop
   144d5:	c9                   	leave  
   144d6:	c3                   	ret    

000144d7 <disk_wait_data>:

static inline int disk_wait_data (disk_t * disk) {
   144d7:	55                   	push   %ebp
   144d8:	89 e5                	mov    %esp,%ebp
   144da:	83 ec 10             	sub    $0x10,%esp
    uint8_t status;
	do {
        status = inb(DISK_STATUS(disk));
   144dd:	8b 45 08             	mov    0x8(%ebp),%eax
   144e0:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   144e4:	83 c0 07             	add    $0x7,%eax
   144e7:	0f b7 c0             	movzwl %ax,%eax
   144ea:	50                   	push   %eax
   144eb:	e8 9b fd ff ff       	call   1428b <inb>
   144f0:	83 c4 04             	add    $0x4,%esp
   144f3:	88 45 ff             	mov    %al,-0x1(%ebp)
        if ((status & (DISK_STATUS_BUSY | DISK_STATUS_DRQ | DISK_STATUS_ERR))
   144f6:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
   144fa:	25 89 00 00 00       	and    $0x89,%eax
   144ff:	3d 80 00 00 00       	cmp    $0x80,%eax
   14504:	75 02                	jne    14508 <disk_wait_data+0x31>
        status = inb(DISK_STATUS(disk));
   14506:	eb d5                	jmp    144dd <disk_wait_data+0x6>
                        != DISK_STATUS_BUSY) {
            break;
   14508:	90                   	nop
        }
    }while (1);
    return (status & DISK_STATUS_ERR) ? -1 : 0;
   14509:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
   1450d:	83 e0 01             	and    $0x1,%eax
   14510:	85 c0                	test   %eax,%eax
   14512:	74 07                	je     1451b <disk_wait_data+0x44>
   14514:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14519:	eb 05                	jmp    14520 <disk_wait_data+0x49>
   1451b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14520:	c9                   	leave  
   14521:	c3                   	ret    

00014522 <print_disk_info>:
void print_disk_info(disk_t* disk)
{
   14522:	55                   	push   %ebp
   14523:	89 e5                	mov    %esp,%ebp
   14525:	53                   	push   %ebx
   14526:	83 ec 14             	sub    $0x14,%esp
    log_printf("%s:", disk->name);
   14529:	8b 45 08             	mov    0x8(%ebp),%eax
   1452c:	83 ec 08             	sub    $0x8,%esp
   1452f:	50                   	push   %eax
   14530:	68 a0 9a 01 00       	push   $0x19aa0
   14535:	e8 12 4a 00 00       	call   18f4c <log_printf>
   1453a:	83 c4 10             	add    $0x10,%esp
    log_printf("  port_base: %x", disk->port_base);
   1453d:	8b 45 08             	mov    0x8(%ebp),%eax
   14540:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   14544:	0f b7 c0             	movzwl %ax,%eax
   14547:	83 ec 08             	sub    $0x8,%esp
   1454a:	50                   	push   %eax
   1454b:	68 a4 9a 01 00       	push   $0x19aa4
   14550:	e8 f7 49 00 00       	call   18f4c <log_printf>
   14555:	83 c4 10             	add    $0x10,%esp
    log_printf("  total_size: %d m", disk->sector_count * disk->sector_size / 1024 /1024);
   14558:	8b 45 08             	mov    0x8(%ebp),%eax
   1455b:	8b 50 2c             	mov    0x2c(%eax),%edx
   1455e:	8b 45 08             	mov    0x8(%ebp),%eax
   14561:	8b 40 28             	mov    0x28(%eax),%eax
   14564:	0f af c2             	imul   %edx,%eax
   14567:	8d 90 ff ff 0f 00    	lea    0xfffff(%eax),%edx
   1456d:	85 c0                	test   %eax,%eax
   1456f:	0f 48 c2             	cmovs  %edx,%eax
   14572:	c1 f8 14             	sar    $0x14,%eax
   14575:	83 ec 08             	sub    $0x8,%esp
   14578:	50                   	push   %eax
   14579:	68 b4 9a 01 00       	push   $0x19ab4
   1457e:	e8 c9 49 00 00       	call   18f4c <log_printf>
   14583:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < DISK_PRIMARY_PART_CNT; i++) {
   14586:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1458d:	eb 4e                	jmp    145dd <print_disk_info+0xbb>
        partinfo_t * part_info = disk->partinfo + i;
   1458f:	8b 45 08             	mov    0x8(%ebp),%eax
   14592:	8d 48 30             	lea    0x30(%eax),%ecx
   14595:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14598:	89 d0                	mov    %edx,%eax
   1459a:	01 c0                	add    %eax,%eax
   1459c:	01 d0                	add    %edx,%eax
   1459e:	c1 e0 04             	shl    $0x4,%eax
   145a1:	01 c8                	add    %ecx,%eax
   145a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (part_info->type != FS_INVALID) {
   145a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145a9:	8b 40 24             	mov    0x24(%eax),%eax
   145ac:	85 c0                	test   %eax,%eax
   145ae:	74 29                	je     145d9 <print_disk_info+0xb7>
            log_printf("    %s: type: %x, start sector: %d, count %d",
   145b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145b3:	8b 58 2c             	mov    0x2c(%eax),%ebx
   145b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145b9:	8b 48 28             	mov    0x28(%eax),%ecx
                    part_info->name, part_info->type,
   145bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145bf:	8b 50 24             	mov    0x24(%eax),%edx
   145c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
            log_printf("    %s: type: %x, start sector: %d, count %d",
   145c5:	83 ec 0c             	sub    $0xc,%esp
   145c8:	53                   	push   %ebx
   145c9:	51                   	push   %ecx
   145ca:	52                   	push   %edx
   145cb:	50                   	push   %eax
   145cc:	68 c8 9a 01 00       	push   $0x19ac8
   145d1:	e8 76 49 00 00       	call   18f4c <log_printf>
   145d6:	83 c4 20             	add    $0x20,%esp
    for (int i = 0; i < DISK_PRIMARY_PART_CNT; i++) {
   145d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   145dd:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
   145e1:	7e ac                	jle    1458f <print_disk_info+0x6d>
                    part_info->start_sector, part_info->total_sector);
        }
    }
}
   145e3:	90                   	nop
   145e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   145e7:	c9                   	leave  
   145e8:	c3                   	ret    

000145e9 <identify_disk>:
int identify_disk(disk_t* disk)
{
   145e9:	55                   	push   %ebp
   145ea:	89 e5                	mov    %esp,%ebp
   145ec:	81 ec 18 02 00 00    	sub    $0x218,%esp
    disk_send_cmd(disk, 0, 0, DISK_CMD_IDENTIFY);
   145f2:	68 ec 00 00 00       	push   $0xec
   145f7:	6a 00                	push   $0x0
   145f9:	6a 00                	push   $0x0
   145fb:	ff 75 08             	pushl  0x8(%ebp)
   145fe:	e8 04 fd ff ff       	call   14307 <disk_send_cmd>
   14603:	83 c4 10             	add    $0x10,%esp
    int err = inb(DISK_STATUS(disk));
   14606:	8b 45 08             	mov    0x8(%ebp),%eax
   14609:	0f b7 40 24          	movzwl 0x24(%eax),%eax
   1460d:	83 c0 07             	add    $0x7,%eax
   14610:	0f b7 c0             	movzwl %ax,%eax
   14613:	50                   	push   %eax
   14614:	e8 72 fc ff ff       	call   1428b <inb>
   14619:	83 c4 04             	add    $0x4,%esp
   1461c:	0f b6 c0             	movzbl %al,%eax
   1461f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (err == 0) {
   14622:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   14626:	75 1e                	jne    14646 <identify_disk+0x5d>
        log_printf("%s doesn't exist\n", disk->name);
   14628:	8b 45 08             	mov    0x8(%ebp),%eax
   1462b:	83 ec 08             	sub    $0x8,%esp
   1462e:	50                   	push   %eax
   1462f:	68 f5 9a 01 00       	push   $0x19af5
   14634:	e8 13 49 00 00       	call   18f4c <log_printf>
   14639:	83 c4 10             	add    $0x10,%esp
        return -1;
   1463c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   14641:	e9 c8 00 00 00       	jmp    1470e <identify_disk+0x125>
    }
    err = disk_wait_data(disk);
   14646:	83 ec 0c             	sub    $0xc,%esp
   14649:	ff 75 08             	pushl  0x8(%ebp)
   1464c:	e8 86 fe ff ff       	call   144d7 <disk_wait_data>
   14651:	83 c4 10             	add    $0x10,%esp
   14654:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (err < 0) {
   14657:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1465b:	79 1c                	jns    14679 <identify_disk+0x90>
        log_printf("disk[%s]: read failed!\n", disk->name);
   1465d:	8b 45 08             	mov    0x8(%ebp),%eax
   14660:	83 ec 08             	sub    $0x8,%esp
   14663:	50                   	push   %eax
   14664:	68 07 9b 01 00       	push   $0x19b07
   14669:	e8 de 48 00 00       	call   18f4c <log_printf>
   1466e:	83 c4 10             	add    $0x10,%esp
        return err;
   14671:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14674:	e9 95 00 00 00       	jmp    1470e <identify_disk+0x125>
    }
    uint16_t buf[256];
    disk_read_data(disk, buf, sizeof(buf));
   14679:	83 ec 04             	sub    $0x4,%esp
   1467c:	68 00 02 00 00       	push   $0x200
   14681:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
   14687:	50                   	push   %eax
   14688:	ff 75 08             	pushl  0x8(%ebp)
   1468b:	e8 a7 fd ff ff       	call   14437 <disk_read_data>
   14690:	83 c4 10             	add    $0x10,%esp
    disk->sector_count = *(uint32_t*)(buf + 100);
   14693:	8d 85 f0 fd ff ff    	lea    -0x210(%ebp),%eax
   14699:	05 c8 00 00 00       	add    $0xc8,%eax
   1469e:	8b 00                	mov    (%eax),%eax
   146a0:	89 c2                	mov    %eax,%edx
   146a2:	8b 45 08             	mov    0x8(%ebp),%eax
   146a5:	89 50 2c             	mov    %edx,0x2c(%eax)
    disk->sector_size = SECTOR_SIZE;
   146a8:	8b 45 08             	mov    0x8(%ebp),%eax
   146ab:	c7 40 28 00 02 00 00 	movl   $0x200,0x28(%eax)
    partinfo_t * part = disk->partinfo + 0;
   146b2:	8b 45 08             	mov    0x8(%ebp),%eax
   146b5:	83 c0 30             	add    $0x30,%eax
   146b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    part->disk = disk;
   146bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146be:	8b 55 08             	mov    0x8(%ebp),%edx
   146c1:	89 50 20             	mov    %edx,0x20(%eax)
    kernel_sprintf(part->name, "%s%d", disk->name, 0);
   146c4:	8b 55 08             	mov    0x8(%ebp),%edx
   146c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146ca:	6a 00                	push   $0x0
   146cc:	52                   	push   %edx
   146cd:	68 1f 9b 01 00       	push   $0x19b1f
   146d2:	50                   	push   %eax
   146d3:	e8 a8 44 00 00       	call   18b80 <kernel_sprintf>
   146d8:	83 c4 10             	add    $0x10,%esp
    part->start_sector = 0;
   146db:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146de:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    part->total_sector = disk->sector_count;
   146e5:	8b 45 08             	mov    0x8(%ebp),%eax
   146e8:	8b 50 2c             	mov    0x2c(%eax),%edx
   146eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146ee:	89 50 2c             	mov    %edx,0x2c(%eax)
    part->type = FS_INVALID;
   146f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146f4:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
    detect_part_info(disk);
   146fb:	83 ec 0c             	sub    $0xc,%esp
   146fe:	ff 75 08             	pushl  0x8(%ebp)
   14701:	e8 0a 00 00 00       	call   14710 <detect_part_info>
   14706:	83 c4 10             	add    $0x10,%esp
    return 0;
   14709:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1470e:	c9                   	leave  
   1470f:	c3                   	ret    

00014710 <detect_part_info>:
static int detect_part_info(disk_t* disk)
{
   14710:	55                   	push   %ebp
   14711:	89 e5                	mov    %esp,%ebp
   14713:	81 ec 18 02 00 00    	sub    $0x218,%esp
    mbr_t mbr;
    disk_send_cmd(disk, 0, 1, DISK_CMD_READ);
   14719:	6a 24                	push   $0x24
   1471b:	6a 01                	push   $0x1
   1471d:	6a 00                	push   $0x0
   1471f:	ff 75 08             	pushl  0x8(%ebp)
   14722:	e8 e0 fb ff ff       	call   14307 <disk_send_cmd>
   14727:	83 c4 10             	add    $0x10,%esp
    int err = disk_wait_data(disk);
   1472a:	ff 75 08             	pushl  0x8(%ebp)
   1472d:	e8 a5 fd ff ff       	call   144d7 <disk_wait_data>
   14732:	83 c4 04             	add    $0x4,%esp
   14735:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (err < 0) {
   14738:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1473c:	79 1c                	jns    1475a <detect_part_info+0x4a>
        log_printf("disk[%s]: read failed!\n", disk->name);
   1473e:	8b 45 08             	mov    0x8(%ebp),%eax
   14741:	83 ec 08             	sub    $0x8,%esp
   14744:	50                   	push   %eax
   14745:	68 07 9b 01 00       	push   $0x19b07
   1474a:	e8 fd 47 00 00       	call   18f4c <log_printf>
   1474f:	83 c4 10             	add    $0x10,%esp
        return err;
   14752:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14755:	e9 d1 00 00 00       	jmp    1482b <detect_part_info+0x11b>
    }
    disk_read_data(disk, (void*)&mbr, sizeof(mbr));
   1475a:	83 ec 04             	sub    $0x4,%esp
   1475d:	68 00 02 00 00       	push   $0x200
   14762:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
   14768:	50                   	push   %eax
   14769:	ff 75 08             	pushl  0x8(%ebp)
   1476c:	e8 c6 fc ff ff       	call   14437 <disk_read_data>
   14771:	83 c4 10             	add    $0x10,%esp

    part_item_t* part_item = mbr.table;
   14774:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
   1477a:	05 be 01 00 00       	add    $0x1be,%eax
   1477f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    partinfo_t* part_info = disk->partinfo + 1;
   14782:	8b 45 08             	mov    0x8(%ebp),%eax
   14785:	83 c0 30             	add    $0x30,%eax
   14788:	83 c0 30             	add    $0x30,%eax
   1478b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    for(int i = 0; i < MBR_PRIMARY_PART_NUM; ++i, ++part_item, ++part_info)
   1478e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14795:	e9 87 00 00 00       	jmp    14821 <detect_part_info+0x111>
    {
        part_info->type = part_item->system_id;
   1479a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1479d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
   147a1:	0f b6 d0             	movzbl %al,%edx
   147a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147a7:	89 50 24             	mov    %edx,0x24(%eax)
        if(part_info->type == FS_INVALID)
   147aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147ad:	8b 40 24             	mov    0x24(%eax),%eax
   147b0:	85 c0                	test   %eax,%eax
   147b2:	75 20                	jne    147d4 <detect_part_info+0xc4>
        {
            part_info->start_sector = 0;
   147b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147b7:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
            part_info->total_sector = 0;
   147be:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147c1:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
            part_info->disk = (disk_t*)0;
   147c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147cb:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
   147d2:	eb 41                	jmp    14815 <detect_part_info+0x105>
        }
        else{
            kernel_sprintf(part_info->name, "%s%d", disk->name, i + 1);
   147d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   147d7:	8d 48 01             	lea    0x1(%eax),%ecx
   147da:	8b 55 08             	mov    0x8(%ebp),%edx
   147dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147e0:	51                   	push   %ecx
   147e1:	52                   	push   %edx
   147e2:	68 1f 9b 01 00       	push   $0x19b1f
   147e7:	50                   	push   %eax
   147e8:	e8 93 43 00 00       	call   18b80 <kernel_sprintf>
   147ed:	83 c4 10             	add    $0x10,%esp
            part_info->start_sector = part_item->relative_sector;
   147f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147f3:	8b 40 08             	mov    0x8(%eax),%eax
   147f6:	89 c2                	mov    %eax,%edx
   147f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   147fb:	89 50 28             	mov    %edx,0x28(%eax)
            part_info->total_sector = part_item->total_sector;
   147fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14801:	8b 40 0c             	mov    0xc(%eax),%eax
   14804:	89 c2                	mov    %eax,%edx
   14806:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14809:	89 50 2c             	mov    %edx,0x2c(%eax)
            part_info->disk = disk;
   1480c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1480f:	8b 55 08             	mov    0x8(%ebp),%edx
   14812:	89 50 20             	mov    %edx,0x20(%eax)
    for(int i = 0; i < MBR_PRIMARY_PART_NUM; ++i, ++part_item, ++part_info)
   14815:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14819:	83 45 f4 10          	addl   $0x10,-0xc(%ebp)
   1481d:	83 45 f0 30          	addl   $0x30,-0x10(%ebp)
   14821:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
   14825:	0f 8e 6f ff ff ff    	jle    1479a <detect_part_info+0x8a>
        }
    }
}
   1482b:	c9                   	leave  
   1482c:	c3                   	ret    

0001482d <disk_init>:
void disk_init(void)
{
   1482d:	55                   	push   %ebp
   1482e:	89 e5                	mov    %esp,%ebp
   14830:	83 ec 18             	sub    $0x18,%esp
    log_printf("Check disk ...... \n");
   14833:	83 ec 0c             	sub    $0xc,%esp
   14836:	68 24 9b 01 00       	push   $0x19b24
   1483b:	e8 0c 47 00 00       	call   18f4c <log_printf>
   14840:	83 c4 10             	add    $0x10,%esp
    mutex_init(&mutex);
   14843:	83 ec 0c             	sub    $0xc,%esp
   14846:	68 f0 6f 03 00       	push   $0x36ff0
   1484b:	e8 06 3a 00 00       	call   18256 <mutex_init>
   14850:	83 c4 10             	add    $0x10,%esp
    sem_init(&op_sem, 0);
   14853:	83 ec 08             	sub    $0x8,%esp
   14856:	6a 00                	push   $0x0
   14858:	68 04 70 03 00       	push   $0x37004
   1485d:	e8 83 3b 00 00       	call   183e5 <sem_init>
   14862:	83 c4 10             	add    $0x10,%esp
    kernel_memset((void*)disk_buf, 0, sizeof(disk_buf));
   14865:	83 ec 04             	sub    $0x4,%esp
   14868:	68 50 02 00 00       	push   $0x250
   1486d:	6a 00                	push   $0x0
   1486f:	68 a0 6d 03 00       	push   $0x36da0
   14874:	e8 29 41 00 00       	call   189a2 <kernel_memset>
   14879:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < DISK_CNT; ++i)
   1487c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14883:	e9 90 00 00 00       	jmp    14918 <disk_init+0xeb>
    {
        disk_t* disk = disk_buf + i;
   14888:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1488b:	69 c0 28 01 00 00    	imul   $0x128,%eax,%eax
   14891:	05 a0 6d 03 00       	add    $0x36da0,%eax
   14896:	89 45 f0             	mov    %eax,-0x10(%ebp)
        kernel_sprintf(disk->name, "sd%c", 'a' + i);
   14899:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1489c:	8d 50 61             	lea    0x61(%eax),%edx
   1489f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148a2:	83 ec 04             	sub    $0x4,%esp
   148a5:	52                   	push   %edx
   148a6:	68 38 9b 01 00       	push   $0x19b38
   148ab:	50                   	push   %eax
   148ac:	e8 cf 42 00 00       	call   18b80 <kernel_sprintf>
   148b1:	83 c4 10             	add    $0x10,%esp
        disk->drive = ((i == 0) ? DISK_DISK_MASTER : DISK_DISK_SLAVE);
   148b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   148b8:	75 07                	jne    148c1 <disk_init+0x94>
   148ba:	ba 00 00 00 00       	mov    $0x0,%edx
   148bf:	eb 05                	jmp    148c6 <disk_init+0x99>
   148c1:	ba 10 00 00 00       	mov    $0x10,%edx
   148c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148c9:	89 50 20             	mov    %edx,0x20(%eax)
        disk->port_base = IOBASE_PRIMARY;
   148cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148cf:	66 c7 40 24 f0 01    	movw   $0x1f0,0x24(%eax)
        disk->mutex = &mutex;
   148d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148d8:	c7 80 20 01 00 00 f0 	movl   $0x36ff0,0x120(%eax)
   148df:	6f 03 00 
        disk->op_sem = &op_sem;
   148e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   148e5:	c7 80 24 01 00 00 04 	movl   $0x37004,0x124(%eax)
   148ec:	70 03 00 
        int err = identify_disk(disk);
   148ef:	83 ec 0c             	sub    $0xc,%esp
   148f2:	ff 75 f0             	pushl  -0x10(%ebp)
   148f5:	e8 ef fc ff ff       	call   145e9 <identify_disk>
   148fa:	83 c4 10             	add    $0x10,%esp
   148fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(err == 0)
   14900:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14904:	75 0e                	jne    14914 <disk_init+0xe7>
        {
            print_disk_info(disk);
   14906:	83 ec 0c             	sub    $0xc,%esp
   14909:	ff 75 f0             	pushl  -0x10(%ebp)
   1490c:	e8 11 fc ff ff       	call   14522 <print_disk_info>
   14911:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < DISK_CNT; ++i)
   14914:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14918:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   1491c:	0f 8e 66 ff ff ff    	jle    14888 <disk_init+0x5b>
        }
    }
}
   14922:	90                   	nop
   14923:	c9                   	leave  
   14924:	c3                   	ret    

00014925 <disk_open>:

int disk_open (device_t * dev) {
   14925:	55                   	push   %ebp
   14926:	89 e5                	mov    %esp,%ebp
   14928:	83 ec 18             	sub    $0x18,%esp
    int disk_idx = (dev->minor >> 4) - 0xa;
   1492b:	8b 45 08             	mov    0x8(%ebp),%eax
   1492e:	8b 40 04             	mov    0x4(%eax),%eax
   14931:	c1 f8 04             	sar    $0x4,%eax
   14934:	83 e8 0a             	sub    $0xa,%eax
   14937:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int part_idx = dev->minor & 0xF;
   1493a:	8b 45 08             	mov    0x8(%ebp),%eax
   1493d:	8b 40 04             	mov    0x4(%eax),%eax
   14940:	83 e0 0f             	and    $0xf,%eax
   14943:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if ((disk_idx >= DISK_CNT) || (part_idx >= DISK_PRIMARY_PART_CNT)) {
   14946:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   1494a:	7f 06                	jg     14952 <disk_open+0x2d>
   1494c:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
   14950:	7e 21                	jle    14973 <disk_open+0x4e>
        log_printf("device minor error: %d", dev->minor);
   14952:	8b 45 08             	mov    0x8(%ebp),%eax
   14955:	8b 40 04             	mov    0x4(%eax),%eax
   14958:	83 ec 08             	sub    $0x8,%esp
   1495b:	50                   	push   %eax
   1495c:	68 3d 9b 01 00       	push   $0x19b3d
   14961:	e8 e6 45 00 00       	call   18f4c <log_printf>
   14966:	83 c4 10             	add    $0x10,%esp
        return -1;
   14969:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1496e:	e9 a5 00 00 00       	jmp    14a18 <disk_open+0xf3>
    }

    disk_t * disk = disk_buf + disk_idx;
   14973:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14976:	69 c0 28 01 00 00    	imul   $0x128,%eax,%eax
   1497c:	05 a0 6d 03 00       	add    $0x36da0,%eax
   14981:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (disk->sector_size == 0) {
   14984:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14987:	8b 40 28             	mov    0x28(%eax),%eax
   1498a:	85 c0                	test   %eax,%eax
   1498c:	75 1e                	jne    149ac <disk_open+0x87>
        log_printf("disk not exist. device:sd%x", dev->minor);
   1498e:	8b 45 08             	mov    0x8(%ebp),%eax
   14991:	8b 40 04             	mov    0x4(%eax),%eax
   14994:	83 ec 08             	sub    $0x8,%esp
   14997:	50                   	push   %eax
   14998:	68 54 9b 01 00       	push   $0x19b54
   1499d:	e8 aa 45 00 00       	call   18f4c <log_printf>
   149a2:	83 c4 10             	add    $0x10,%esp
        return -1;
   149a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   149aa:	eb 6c                	jmp    14a18 <disk_open+0xf3>
    }

    partinfo_t * part_info = disk->partinfo + part_idx;
   149ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
   149af:	8d 48 30             	lea    0x30(%eax),%ecx
   149b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
   149b5:	89 d0                	mov    %edx,%eax
   149b7:	01 c0                	add    %eax,%eax
   149b9:	01 d0                	add    %edx,%eax
   149bb:	c1 e0 04             	shl    $0x4,%eax
   149be:	01 c8                	add    %ecx,%eax
   149c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (part_info->total_sector == 0) {
   149c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   149c6:	8b 40 2c             	mov    0x2c(%eax),%eax
   149c9:	85 c0                	test   %eax,%eax
   149cb:	75 1e                	jne    149eb <disk_open+0xc6>
        log_printf("part not exist. device:sd%x", dev->minor);
   149cd:	8b 45 08             	mov    0x8(%ebp),%eax
   149d0:	8b 40 04             	mov    0x4(%eax),%eax
   149d3:	83 ec 08             	sub    $0x8,%esp
   149d6:	50                   	push   %eax
   149d7:	68 70 9b 01 00       	push   $0x19b70
   149dc:	e8 6b 45 00 00       	call   18f4c <log_printf>
   149e1:	83 c4 10             	add    $0x10,%esp
        return -1;
   149e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   149e9:	eb 2d                	jmp    14a18 <disk_open+0xf3>
    }

    
    dev->data = part_info;
   149eb:	8b 45 08             	mov    0x8(%ebp),%eax
   149ee:	8b 55 e8             	mov    -0x18(%ebp),%edx
   149f1:	89 50 0c             	mov    %edx,0xc(%eax)
    irq_install(IRQ14_HARDDISK_PRIMARY, (irq_handler_t)exception_handler_ide_primary);
   149f4:	83 ec 08             	sub    $0x8,%esp
   149f7:	68 98 02 01 00       	push   $0x10298
   149fc:	6a 2e                	push   $0x2e
   149fe:	e8 8e e2 ff ff       	call   12c91 <irq_install>
   14a03:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ14_HARDDISK_PRIMARY);
   14a06:	83 ec 0c             	sub    $0xc,%esp
   14a09:	6a 2e                	push   $0x2e
   14a0b:	e8 2b e7 ff ff       	call   1313b <irq_enable>
   14a10:	83 c4 10             	add    $0x10,%esp
    return 0;
   14a13:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14a18:	c9                   	leave  
   14a19:	c3                   	ret    

00014a1a <disk_read>:


int disk_read (device_t * dev, int start_sector, char * buf, int count) {
   14a1a:	55                   	push   %ebp
   14a1b:	89 e5                	mov    %esp,%ebp
   14a1d:	83 ec 18             	sub    $0x18,%esp
    partinfo_t* part_info = (partinfo_t*)dev->data;
   14a20:	8b 45 08             	mov    0x8(%ebp),%eax
   14a23:	8b 40 0c             	mov    0xc(%eax),%eax
   14a26:	89 45 f0             	mov    %eax,-0x10(%ebp)
    disk_t* disk = part_info->disk;
   14a29:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14a2c:	8b 40 20             	mov    0x20(%eax),%eax
   14a2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    mutex_lock(disk->mutex);
   14a32:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14a35:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
   14a3b:	83 ec 0c             	sub    $0xc,%esp
   14a3e:	50                   	push   %eax
   14a3f:	e8 40 38 00 00       	call   18284 <mutex_lock>
   14a44:	83 c4 10             	add    $0x10,%esp
    int i = 0;
   14a47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    task_on_op = 1;
   14a4e:	c7 05 14 70 03 00 01 	movl   $0x1,0x37014
   14a55:	00 00 00 
    disk_send_cmd(disk, part_info->start_sector + start_sector, count, DISK_CMD_READ);
   14a58:	8b 45 14             	mov    0x14(%ebp),%eax
   14a5b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14a5e:	8b 4a 28             	mov    0x28(%edx),%ecx
   14a61:	8b 55 0c             	mov    0xc(%ebp),%edx
   14a64:	01 ca                	add    %ecx,%edx
   14a66:	6a 24                	push   $0x24
   14a68:	50                   	push   %eax
   14a69:	52                   	push   %edx
   14a6a:	ff 75 ec             	pushl  -0x14(%ebp)
   14a6d:	e8 95 f8 ff ff       	call   14307 <disk_send_cmd>
   14a72:	83 c4 10             	add    $0x10,%esp
    for(; i < count; ++i, buf+=disk->sector_size)
   14a75:	eb 6e                	jmp    14ae5 <disk_read+0xcb>
    {
        if(task_manager.curr_task)
   14a77:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   14a7c:	85 c0                	test   %eax,%eax
   14a7e:	74 10                	je     14a90 <disk_read+0x76>
        {
            sem_wait(&op_sem);
   14a80:	83 ec 0c             	sub    $0xc,%esp
   14a83:	68 04 70 03 00       	push   $0x37004
   14a88:	e8 7b 39 00 00       	call   18408 <sem_wait>
   14a8d:	83 c4 10             	add    $0x10,%esp
        }
        
        int err = disk_wait_data(disk);
   14a90:	83 ec 0c             	sub    $0xc,%esp
   14a93:	ff 75 ec             	pushl  -0x14(%ebp)
   14a96:	e8 3c fa ff ff       	call   144d7 <disk_wait_data>
   14a9b:	83 c4 10             	add    $0x10,%esp
   14a9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (err < 0) {
   14aa1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   14aa5:	79 19                	jns    14ac0 <disk_read+0xa6>
            log_printf("disk(%s) read error: start sect %d, count %d", disk->name, start_sector, count);
   14aa7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14aaa:	ff 75 14             	pushl  0x14(%ebp)
   14aad:	ff 75 0c             	pushl  0xc(%ebp)
   14ab0:	50                   	push   %eax
   14ab1:	68 8c 9b 01 00       	push   $0x19b8c
   14ab6:	e8 91 44 00 00       	call   18f4c <log_printf>
   14abb:	83 c4 10             	add    $0x10,%esp
            break;
   14abe:	eb 2d                	jmp    14aed <disk_read+0xd3>
        }
        disk_read_data(disk, buf, disk->sector_size);
   14ac0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14ac3:	8b 40 28             	mov    0x28(%eax),%eax
   14ac6:	83 ec 04             	sub    $0x4,%esp
   14ac9:	50                   	push   %eax
   14aca:	ff 75 10             	pushl  0x10(%ebp)
   14acd:	ff 75 ec             	pushl  -0x14(%ebp)
   14ad0:	e8 62 f9 ff ff       	call   14437 <disk_read_data>
   14ad5:	83 c4 10             	add    $0x10,%esp
    for(; i < count; ++i, buf+=disk->sector_size)
   14ad8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14adc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14adf:	8b 40 28             	mov    0x28(%eax),%eax
   14ae2:	01 45 10             	add    %eax,0x10(%ebp)
   14ae5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14ae8:	3b 45 14             	cmp    0x14(%ebp),%eax
   14aeb:	7c 8a                	jl     14a77 <disk_read+0x5d>
    }
    mutex_unlock(disk->mutex);
   14aed:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14af0:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
   14af6:	83 ec 0c             	sub    $0xc,%esp
   14af9:	50                   	push   %eax
   14afa:	e8 1b 38 00 00       	call   1831a <mutex_unlock>
   14aff:	83 c4 10             	add    $0x10,%esp
    return i;
   14b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14b05:	c9                   	leave  
   14b06:	c3                   	ret    

00014b07 <disk_write>:


int disk_write (device_t * dev, int start_sector, char * buf, int count) {
   14b07:	55                   	push   %ebp
   14b08:	89 e5                	mov    %esp,%ebp
   14b0a:	83 ec 18             	sub    $0x18,%esp
    partinfo_t* part_info = (partinfo_t*)dev->data;
   14b0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14b10:	8b 40 0c             	mov    0xc(%eax),%eax
   14b13:	89 45 f0             	mov    %eax,-0x10(%ebp)
    disk_t* disk = part_info->disk;
   14b16:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b19:	8b 40 20             	mov    0x20(%eax),%eax
   14b1c:	89 45 ec             	mov    %eax,-0x14(%ebp)

    mutex_lock(disk->mutex);
   14b1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14b22:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
   14b28:	83 ec 0c             	sub    $0xc,%esp
   14b2b:	50                   	push   %eax
   14b2c:	e8 53 37 00 00       	call   18284 <mutex_lock>
   14b31:	83 c4 10             	add    $0x10,%esp
    int i = 0;
   14b34:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    task_on_op = 1;
   14b3b:	c7 05 14 70 03 00 01 	movl   $0x1,0x37014
   14b42:	00 00 00 
    disk_send_cmd(disk, part_info->start_sector + start_sector, count, DISK_CMD_WRITE);
   14b45:	8b 45 14             	mov    0x14(%ebp),%eax
   14b48:	8b 55 f0             	mov    -0x10(%ebp),%edx
   14b4b:	8b 4a 28             	mov    0x28(%edx),%ecx
   14b4e:	8b 55 0c             	mov    0xc(%ebp),%edx
   14b51:	01 ca                	add    %ecx,%edx
   14b53:	6a 34                	push   $0x34
   14b55:	50                   	push   %eax
   14b56:	52                   	push   %edx
   14b57:	ff 75 ec             	pushl  -0x14(%ebp)
   14b5a:	e8 a8 f7 ff ff       	call   14307 <disk_send_cmd>
   14b5f:	83 c4 10             	add    $0x10,%esp
    
    for(; i < count; ++i, buf+=disk->sector_size)
   14b62:	eb 6e                	jmp    14bd2 <disk_write+0xcb>
    {
        disk_write_data(disk, buf, disk->sector_size);
   14b64:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14b67:	8b 40 28             	mov    0x28(%eax),%eax
   14b6a:	83 ec 04             	sub    $0x4,%esp
   14b6d:	50                   	push   %eax
   14b6e:	ff 75 10             	pushl  0x10(%ebp)
   14b71:	ff 75 ec             	pushl  -0x14(%ebp)
   14b74:	e8 0e f9 ff ff       	call   14487 <disk_write_data>
   14b79:	83 c4 10             	add    $0x10,%esp
        if(task_manager.curr_task)
   14b7c:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   14b81:	85 c0                	test   %eax,%eax
   14b83:	74 10                	je     14b95 <disk_write+0x8e>
        {
            sem_wait(&op_sem);
   14b85:	83 ec 0c             	sub    $0xc,%esp
   14b88:	68 04 70 03 00       	push   $0x37004
   14b8d:	e8 76 38 00 00       	call   18408 <sem_wait>
   14b92:	83 c4 10             	add    $0x10,%esp
        }
        int err = disk_wait_data(disk);
   14b95:	83 ec 0c             	sub    $0xc,%esp
   14b98:	ff 75 ec             	pushl  -0x14(%ebp)
   14b9b:	e8 37 f9 ff ff       	call   144d7 <disk_wait_data>
   14ba0:	83 c4 10             	add    $0x10,%esp
   14ba3:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (err < 0) {
   14ba6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   14baa:	79 19                	jns    14bc5 <disk_write+0xbe>
            log_printf("disk(%s) read error: start sect %d, count %d", disk->name, start_sector, count);
   14bac:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14baf:	ff 75 14             	pushl  0x14(%ebp)
   14bb2:	ff 75 0c             	pushl  0xc(%ebp)
   14bb5:	50                   	push   %eax
   14bb6:	68 8c 9b 01 00       	push   $0x19b8c
   14bbb:	e8 8c 43 00 00       	call   18f4c <log_printf>
   14bc0:	83 c4 10             	add    $0x10,%esp
            break;
   14bc3:	eb 15                	jmp    14bda <disk_write+0xd3>
    for(; i < count; ++i, buf+=disk->sector_size)
   14bc5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14bc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14bcc:	8b 40 28             	mov    0x28(%eax),%eax
   14bcf:	01 45 10             	add    %eax,0x10(%ebp)
   14bd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14bd5:	3b 45 14             	cmp    0x14(%ebp),%eax
   14bd8:	7c 8a                	jl     14b64 <disk_write+0x5d>
        }
        
    }
    mutex_unlock(disk->mutex);
   14bda:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14bdd:	8b 80 20 01 00 00    	mov    0x120(%eax),%eax
   14be3:	83 ec 0c             	sub    $0xc,%esp
   14be6:	50                   	push   %eax
   14be7:	e8 2e 37 00 00       	call   1831a <mutex_unlock>
   14bec:	83 c4 10             	add    $0x10,%esp
    return i;
   14bef:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14bf2:	c9                   	leave  
   14bf3:	c3                   	ret    

00014bf4 <disk_control>:


int disk_control (device_t * dev, int cmd, int arg0, int arg1) {
   14bf4:	55                   	push   %ebp
   14bf5:	89 e5                	mov    %esp,%ebp
    return 0;
   14bf7:	b8 00 00 00 00       	mov    $0x0,%eax
}
   14bfc:	5d                   	pop    %ebp
   14bfd:	c3                   	ret    

00014bfe <disk_close>:


void disk_close (device_t * dev) {
   14bfe:	55                   	push   %ebp
   14bff:	89 e5                	mov    %esp,%ebp
}
   14c01:	90                   	nop
   14c02:	5d                   	pop    %ebp
   14c03:	c3                   	ret    

00014c04 <do_handler_ide_primary>:

void do_handler_ide_primary (exception_frame_t *frame)  {
   14c04:	55                   	push   %ebp
   14c05:	89 e5                	mov    %esp,%ebp
   14c07:	83 ec 08             	sub    $0x8,%esp
    pic_send_eoi(IRQ14_HARDDISK_PRIMARY);
   14c0a:	83 ec 0c             	sub    $0xc,%esp
   14c0d:	6a 2e                	push   $0x2e
   14c0f:	e8 e7 e7 ff ff       	call   133fb <pic_send_eoi>
   14c14:	83 c4 10             	add    $0x10,%esp
    if(task_on_op && task_manager.curr_task)
   14c17:	a1 14 70 03 00       	mov    0x37014,%eax
   14c1c:	85 c0                	test   %eax,%eax
   14c1e:	74 19                	je     14c39 <do_handler_ide_primary+0x35>
   14c20:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   14c25:	85 c0                	test   %eax,%eax
   14c27:	74 10                	je     14c39 <do_handler_ide_primary+0x35>
        sem_notify(&op_sem);
   14c29:	83 ec 0c             	sub    $0xc,%esp
   14c2c:	68 04 70 03 00       	push   $0x37004
   14c31:	e8 3d 38 00 00       	call   18473 <sem_notify>
   14c36:	83 c4 10             	add    $0x10,%esp
}
   14c39:	90                   	nop
   14c3a:	c9                   	leave  
   14c3b:	c3                   	ret    

00014c3c <inb>:
static inline uint8_t inb(uint16_t  port) {
   14c3c:	55                   	push   %ebp
   14c3d:	89 e5                	mov    %esp,%ebp
   14c3f:	83 ec 14             	sub    $0x14,%esp
   14c42:	8b 45 08             	mov    0x8(%ebp),%eax
   14c45:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   14c49:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   14c4d:	89 c2                	mov    %eax,%edx
   14c4f:	ec                   	in     (%dx),%al
   14c50:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   14c53:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   14c57:	c9                   	leave  
   14c58:	c3                   	ret    

00014c59 <is_makecode>:
        [0x35] = {'/', '?'},
        [0x39] = {' ', ' '},
};

int is_makecode(uint8_t raw_code)
{
   14c59:	55                   	push   %ebp
   14c5a:	89 e5                	mov    %esp,%ebp
   14c5c:	83 ec 04             	sub    $0x4,%esp
   14c5f:	8b 45 08             	mov    0x8(%ebp),%eax
   14c62:	88 45 fc             	mov    %al,-0x4(%ebp)
    return !(raw_code & 0x80);
   14c65:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   14c69:	f7 d0                	not    %eax
   14c6b:	c0 e8 07             	shr    $0x7,%al
   14c6e:	0f b6 c0             	movzbl %al,%eax
}
   14c71:	c9                   	leave  
   14c72:	c3                   	ret    

00014c73 <get_key>:

uint8_t get_key(uint8_t raw_code)
{
   14c73:	55                   	push   %ebp
   14c74:	89 e5                	mov    %esp,%ebp
   14c76:	83 ec 04             	sub    $0x4,%esp
   14c79:	8b 45 08             	mov    0x8(%ebp),%eax
   14c7c:	88 45 fc             	mov    %al,-0x4(%ebp)
    return raw_code & 0x7F;
   14c7f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
   14c83:	83 e0 7f             	and    $0x7f,%eax
}
   14c86:	c9                   	leave  
   14c87:	c3                   	ret    

00014c88 <do_fx_key>:
static void do_fx_key (int key) {
   14c88:	55                   	push   %ebp
   14c89:	89 e5                	mov    %esp,%ebp
   14c8b:	83 ec 18             	sub    $0x18,%esp
    int index = key - KEY_F1;
   14c8e:	8b 45 08             	mov    0x8(%ebp),%eax
   14c91:	83 e8 3b             	sub    $0x3b,%eax
   14c94:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (kbd_state.lctrl_press || kbd_state.rctrl_press) {
   14c97:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14c9e:	83 e0 20             	and    $0x20,%eax
   14ca1:	84 c0                	test   %al,%al
   14ca3:	75 0e                	jne    14cb3 <do_fx_key+0x2b>
   14ca5:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14cac:	83 e0 40             	and    $0x40,%eax
   14caf:	84 c0                	test   %al,%al
   14cb1:	74 0e                	je     14cc1 <do_fx_key+0x39>
        tty_select(index);
   14cb3:	83 ec 0c             	sub    $0xc,%esp
   14cb6:	ff 75 f4             	pushl  -0xc(%ebp)
   14cb9:	e8 8a 09 00 00       	call   15648 <tty_select>
   14cbe:	83 c4 10             	add    $0x10,%esp
    }
}
   14cc1:	90                   	nop
   14cc2:	c9                   	leave  
   14cc3:	c3                   	ret    

00014cc4 <do_normal_key>:
/**
 * @brief 按键中断处理程序
 */
static void do_normal_key (uint8_t raw_code)
{
   14cc4:	55                   	push   %ebp
   14cc5:	89 e5                	mov    %esp,%ebp
   14cc7:	83 ec 28             	sub    $0x28,%esp
   14cca:	8b 45 08             	mov    0x8(%ebp),%eax
   14ccd:	88 45 e4             	mov    %al,-0x1c(%ebp)
    int make_code = is_makecode(raw_code);
   14cd0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   14cd4:	50                   	push   %eax
   14cd5:	e8 7f ff ff ff       	call   14c59 <is_makecode>
   14cda:	83 c4 04             	add    $0x4,%esp
   14cdd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    uint8_t key = get_key(raw_code);
   14ce0:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   14ce4:	50                   	push   %eax
   14ce5:	e8 89 ff ff ff       	call   14c73 <get_key>
   14cea:	83 c4 04             	add    $0x4,%esp
   14ced:	88 45 f7             	mov    %al,-0x9(%ebp)
    switch (key)
   14cf0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14cf4:	83 e8 1d             	sub    $0x1d,%eax
   14cf7:	83 f8 25             	cmp    $0x25,%eax
   14cfa:	0f 87 f4 00 00 00    	ja     14df4 <do_normal_key+0x130>
   14d00:	8b 04 85 c0 9d 01 00 	mov    0x19dc0(,%eax,4),%eax
   14d07:	ff e0                	jmp    *%eax
    {
    case KEY_LSHIFT:
        kbd_state.lshift_press = make_code;
   14d09:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14d0c:	c1 e0 07             	shl    $0x7,%eax
   14d0f:	c0 f8 07             	sar    $0x7,%al
   14d12:	83 e0 01             	and    $0x1,%eax
   14d15:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14d18:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14d1f:	83 e0 fd             	and    $0xfffffffd,%eax
   14d22:	09 d0                	or     %edx,%eax
   14d24:	a2 00 02 06 00       	mov    %al,0x60200
        break;
   14d29:	e9 55 01 00 00       	jmp    14e83 <do_normal_key+0x1bf>
    case KEY_RSHIFT:
        kbd_state.rshift_press = make_code;
   14d2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14d31:	c1 e0 07             	shl    $0x7,%eax
   14d34:	c0 f8 07             	sar    $0x7,%al
   14d37:	83 e0 01             	and    $0x1,%eax
   14d3a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14d41:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14d48:	83 e0 fb             	and    $0xfffffffb,%eax
   14d4b:	09 d0                	or     %edx,%eax
   14d4d:	a2 00 02 06 00       	mov    %al,0x60200
        break;
   14d52:	e9 2c 01 00 00       	jmp    14e83 <do_normal_key+0x1bf>
    case KEY_CAPS:
        if(make_code)
   14d57:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14d5b:	0f 84 1e 01 00 00    	je     14e7f <do_normal_key+0x1bb>
        kbd_state.caps_loc = ~kbd_state.caps_loc;
   14d61:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14d68:	c1 e0 07             	shl    $0x7,%eax
   14d6b:	c0 f8 07             	sar    $0x7,%al
   14d6e:	f7 d0                	not    %eax
   14d70:	c1 e0 07             	shl    $0x7,%eax
   14d73:	c0 f8 07             	sar    $0x7,%al
   14d76:	83 e0 01             	and    $0x1,%eax
   14d79:	89 c2                	mov    %eax,%edx
   14d7b:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14d82:	83 e0 fe             	and    $0xfffffffe,%eax
   14d85:	09 d0                	or     %edx,%eax
   14d87:	a2 00 02 06 00       	mov    %al,0x60200
        break;
   14d8c:	e9 ee 00 00 00       	jmp    14e7f <do_normal_key+0x1bb>
    case KEY_ALT:
        kbd_state.lalt_press = make_code;  
   14d91:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14d94:	c1 e0 07             	shl    $0x7,%eax
   14d97:	c0 f8 07             	sar    $0x7,%al
   14d9a:	83 e0 01             	and    $0x1,%eax
   14d9d:	c1 e0 04             	shl    $0x4,%eax
   14da0:	89 c2                	mov    %eax,%edx
   14da2:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14da9:	83 e0 ef             	and    $0xffffffef,%eax
   14dac:	09 d0                	or     %edx,%eax
   14dae:	a2 00 02 06 00       	mov    %al,0x60200
        break;
   14db3:	e9 cb 00 00 00       	jmp    14e83 <do_normal_key+0x1bf>
    case KEY_CTRL:
        kbd_state.lctrl_press = make_code;  
   14db8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14dbb:	c1 e0 07             	shl    $0x7,%eax
   14dbe:	c0 f8 07             	sar    $0x7,%al
   14dc1:	83 e0 01             	and    $0x1,%eax
   14dc4:	c1 e0 05             	shl    $0x5,%eax
   14dc7:	89 c2                	mov    %eax,%edx
   14dc9:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14dd0:	83 e0 df             	and    $0xffffffdf,%eax
   14dd3:	09 d0                	or     %edx,%eax
   14dd5:	a2 00 02 06 00       	mov    %al,0x60200
        break;
   14dda:	e9 a4 00 00 00       	jmp    14e83 <do_normal_key+0x1bf>
    case KEY_F4:
    case KEY_F5:
    case KEY_F6:
    case KEY_F7:
    case KEY_F8:
        do_fx_key(key);
   14ddf:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14de3:	83 ec 0c             	sub    $0xc,%esp
   14de6:	50                   	push   %eax
   14de7:	e8 9c fe ff ff       	call   14c88 <do_fx_key>
   14dec:	83 c4 10             	add    $0x10,%esp
        break;
   14def:	e9 8f 00 00 00       	jmp    14e83 <do_normal_key+0x1bf>
    case KEY_F10:
    case KEY_F11:
    case KEY_F12:
    case KEY_SCROLL_LOCK:
    default:
        if(make_code)
   14df4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14df8:	0f 84 84 00 00 00    	je     14e82 <do_normal_key+0x1be>
        {   
            if(kbd_state.lshift_press || kbd_state.rshift_press)
   14dfe:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14e05:	83 e0 02             	and    $0x2,%eax
   14e08:	84 c0                	test   %al,%al
   14e0a:	75 0e                	jne    14e1a <do_normal_key+0x156>
   14e0c:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14e13:	83 e0 04             	and    $0x4,%eax
   14e16:	84 c0                	test   %al,%al
   14e18:	74 11                	je     14e2b <do_normal_key+0x167>
            {
                key = map_table[key].func;
   14e1a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14e1e:	0f b6 84 00 c1 9b 01 	movzbl 0x19bc1(%eax,%eax,1),%eax
   14e25:	00 
   14e26:	88 45 f7             	mov    %al,-0x9(%ebp)
   14e29:	eb 0f                	jmp    14e3a <do_normal_key+0x176>
             
            }
            else 
                key = map_table[key].normal;
   14e2b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14e2f:	0f b6 84 00 c0 9b 01 	movzbl 0x19bc0(%eax,%eax,1),%eax
   14e36:	00 
   14e37:	88 45 f7             	mov    %al,-0x9(%ebp)
            
            if(kbd_state.caps_loc)
   14e3a:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14e41:	83 e0 01             	and    $0x1,%eax
   14e44:	84 c0                	test   %al,%al
   14e46:	74 22                	je     14e6a <do_normal_key+0x1a6>
            {
                if(key >= 'A' && key <= 'Z')
   14e48:	80 7d f7 40          	cmpb   $0x40,-0x9(%ebp)
   14e4c:	76 0c                	jbe    14e5a <do_normal_key+0x196>
   14e4e:	80 7d f7 5a          	cmpb   $0x5a,-0x9(%ebp)
   14e52:	77 06                	ja     14e5a <do_normal_key+0x196>
                {
                    key = key - 'A' + 'a';
   14e54:	80 45 f7 20          	addb   $0x20,-0x9(%ebp)
   14e58:	eb 10                	jmp    14e6a <do_normal_key+0x1a6>
                }
                else if(key >= 'a' && key <='z')
   14e5a:	80 7d f7 60          	cmpb   $0x60,-0x9(%ebp)
   14e5e:	76 0a                	jbe    14e6a <do_normal_key+0x1a6>
   14e60:	80 7d f7 7a          	cmpb   $0x7a,-0x9(%ebp)
   14e64:	77 04                	ja     14e6a <do_normal_key+0x1a6>
                {
                    key = key - 'a' + 'A';
   14e66:	80 6d f7 20          	subb   $0x20,-0x9(%ebp)
                }
            }
            tty_in(key);
   14e6a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14e6e:	0f be c0             	movsbl %al,%eax
   14e71:	83 ec 0c             	sub    $0xc,%esp
   14e74:	50                   	push   %eax
   14e75:	e8 00 07 00 00       	call   1557a <tty_in>
   14e7a:	83 c4 10             	add    $0x10,%esp
        }
       
        break;
   14e7d:	eb 03                	jmp    14e82 <do_normal_key+0x1be>
        break;
   14e7f:	90                   	nop
   14e80:	eb 01                	jmp    14e83 <do_normal_key+0x1bf>
        break;
   14e82:	90                   	nop
    }
}
   14e83:	90                   	nop
   14e84:	c9                   	leave  
   14e85:	c3                   	ret    

00014e86 <do_handler_kbd>:
void do_handler_kbd(exception_frame_t *frame) {
   14e86:	55                   	push   %ebp
   14e87:	89 e5                	mov    %esp,%ebp
   14e89:	83 ec 18             	sub    $0x18,%esp
    	NORMAL,				
		BEGIN_E0,			
		BEGIN_E1,			
    }recv_state = NORMAL;
	// 检查是否有数据，无数据则退出
	uint8_t status = inb(KBD_PORT_STAT);
   14e8c:	6a 64                	push   $0x64
   14e8e:	e8 a9 fd ff ff       	call   14c3c <inb>
   14e93:	83 c4 04             	add    $0x4,%esp
   14e96:	88 45 f7             	mov    %al,-0x9(%ebp)
	if (!(status & KBD_STAT_RECV_READY)) {
   14e99:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
   14e9d:	83 e0 01             	and    $0x1,%eax
   14ea0:	85 c0                	test   %eax,%eax
   14ea2:	75 12                	jne    14eb6 <do_handler_kbd+0x30>
        pic_send_eoi(IRQ1_KEYBOARD);
   14ea4:	83 ec 0c             	sub    $0xc,%esp
   14ea7:	6a 21                	push   $0x21
   14ea9:	e8 4d e5 ff ff       	call   133fb <pic_send_eoi>
   14eae:	83 c4 10             	add    $0x10,%esp
		return;
   14eb1:	e9 90 00 00 00       	jmp    14f46 <do_handler_kbd+0xc0>
	}

	// 读取键值
    uint8_t raw_code = inb(KBD_PORT_DATA);
   14eb6:	83 ec 0c             	sub    $0xc,%esp
   14eb9:	6a 60                	push   $0x60
   14ebb:	e8 7c fd ff ff       	call   14c3c <inb>
   14ec0:	83 c4 10             	add    $0x10,%esp
   14ec3:	88 45 f6             	mov    %al,-0xa(%ebp)
    
    
    
    pic_send_eoi(IRQ1_KEYBOARD);
   14ec6:	83 ec 0c             	sub    $0xc,%esp
   14ec9:	6a 21                	push   $0x21
   14ecb:	e8 2b e5 ff ff       	call   133fb <pic_send_eoi>
   14ed0:	83 c4 10             	add    $0x10,%esp
    if (raw_code == KEY_E0) {
   14ed3:	80 7d f6 e0          	cmpb   $0xe0,-0xa(%ebp)
   14ed7:	75 0c                	jne    14ee5 <do_handler_kbd+0x5f>
		recv_state = BEGIN_E0;
   14ed9:	c7 05 18 70 03 00 01 	movl   $0x1,0x37018
   14ee0:	00 00 00 
   14ee3:	eb 61                	jmp    14f46 <do_handler_kbd+0xc0>
	} else if (raw_code == KEY_E1) {
   14ee5:	80 7d f6 e1          	cmpb   $0xe1,-0xa(%ebp)
   14ee9:	75 0c                	jne    14ef7 <do_handler_kbd+0x71>
		recv_state = BEGIN_E1;
   14eeb:	c7 05 18 70 03 00 02 	movl   $0x2,0x37018
   14ef2:	00 00 00 
   14ef5:	eb 4f                	jmp    14f46 <do_handler_kbd+0xc0>
	} else {
		switch (recv_state) {
   14ef7:	a1 18 70 03 00       	mov    0x37018,%eax
   14efc:	83 f8 01             	cmp    $0x1,%eax
   14eff:	74 1e                	je     14f1f <do_handler_kbd+0x99>
   14f01:	83 f8 01             	cmp    $0x1,%eax
   14f04:	72 07                	jb     14f0d <do_handler_kbd+0x87>
   14f06:	83 f8 02             	cmp    $0x2,%eax
   14f09:	74 30                	je     14f3b <do_handler_kbd+0xb5>
   14f0b:	eb 39                	jmp    14f46 <do_handler_kbd+0xc0>
		case NORMAL:
			do_normal_key(raw_code);
   14f0d:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   14f11:	83 ec 0c             	sub    $0xc,%esp
   14f14:	50                   	push   %eax
   14f15:	e8 aa fd ff ff       	call   14cc4 <do_normal_key>
   14f1a:	83 c4 10             	add    $0x10,%esp
			break;
   14f1d:	eb 27                	jmp    14f46 <do_handler_kbd+0xc0>
		case BEGIN_E0: // 涓嶅鐞唒rint scr
			do_e0_key(raw_code);
   14f1f:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
   14f23:	83 ec 0c             	sub    $0xc,%esp
   14f26:	50                   	push   %eax
   14f27:	e8 1c 00 00 00       	call   14f48 <do_e0_key>
   14f2c:	83 c4 10             	add    $0x10,%esp
			recv_state = NORMAL;
   14f2f:	c7 05 18 70 03 00 00 	movl   $0x0,0x37018
   14f36:	00 00 00 
			break;
   14f39:	eb 0b                	jmp    14f46 <do_handler_kbd+0xc0>
		case BEGIN_E1:  // 涓嶅鐞唒ause
			recv_state = NORMAL;
   14f3b:	c7 05 18 70 03 00 00 	movl   $0x0,0x37018
   14f42:	00 00 00 
			break;
   14f45:	90                   	nop
		}
	}
}
   14f46:	c9                   	leave  
   14f47:	c3                   	ret    

00014f48 <do_e0_key>:

void do_e0_key (uint8_t raw_code) {
   14f48:	55                   	push   %ebp
   14f49:	89 e5                	mov    %esp,%ebp
   14f4b:	83 ec 14             	sub    $0x14,%esp
   14f4e:	8b 45 08             	mov    0x8(%ebp),%eax
   14f51:	88 45 ec             	mov    %al,-0x14(%ebp)
    int key = get_key(raw_code);			
   14f54:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   14f58:	50                   	push   %eax
   14f59:	e8 15 fd ff ff       	call   14c73 <get_key>
   14f5e:	83 c4 04             	add    $0x4,%esp
   14f61:	0f b6 c0             	movzbl %al,%eax
   14f64:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int make_code = is_makecode(raw_code);	
   14f67:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
   14f6b:	50                   	push   %eax
   14f6c:	e8 e8 fc ff ff       	call   14c59 <is_makecode>
   14f71:	83 c4 04             	add    $0x4,%esp
   14f74:	89 45 f8             	mov    %eax,-0x8(%ebp)

    
    switch (key) {
   14f77:	8b 45 fc             	mov    -0x4(%ebp),%eax
   14f7a:	83 f8 1d             	cmp    $0x1d,%eax
   14f7d:	74 07                	je     14f86 <do_e0_key+0x3e>
   14f7f:	83 f8 38             	cmp    $0x38,%eax
   14f82:	74 26                	je     14faa <do_e0_key+0x62>
            break;
        case KEY_ALT:
            kbd_state.ralt_press = make_code;  
            break;
    }
}
   14f84:	eb 49                	jmp    14fcf <do_e0_key+0x87>
            kbd_state.rctrl_press = make_code; 
   14f86:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14f89:	c1 e0 07             	shl    $0x7,%eax
   14f8c:	c0 f8 07             	sar    $0x7,%al
   14f8f:	83 e0 01             	and    $0x1,%eax
   14f92:	c1 e0 06             	shl    $0x6,%eax
   14f95:	89 c2                	mov    %eax,%edx
   14f97:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14f9e:	83 e0 bf             	and    $0xffffffbf,%eax
   14fa1:	09 d0                	or     %edx,%eax
   14fa3:	a2 00 02 06 00       	mov    %al,0x60200
            break;
   14fa8:	eb 25                	jmp    14fcf <do_e0_key+0x87>
            kbd_state.ralt_press = make_code;  
   14faa:	8b 45 f8             	mov    -0x8(%ebp),%eax
   14fad:	c1 e0 07             	shl    $0x7,%eax
   14fb0:	c0 f8 07             	sar    $0x7,%al
   14fb3:	83 e0 01             	and    $0x1,%eax
   14fb6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14fbd:	0f b6 05 00 02 06 00 	movzbl 0x60200,%eax
   14fc4:	83 e0 f7             	and    $0xfffffff7,%eax
   14fc7:	09 d0                	or     %edx,%eax
   14fc9:	a2 00 02 06 00       	mov    %al,0x60200
            break;
   14fce:	90                   	nop
}
   14fcf:	90                   	nop
   14fd0:	c9                   	leave  
   14fd1:	c3                   	ret    

00014fd2 <kbd_init>:

/**
 * 键盘硬件初始化
 */
void kbd_init(void) {
   14fd2:	55                   	push   %ebp
   14fd3:	89 e5                	mov    %esp,%ebp
   14fd5:	83 ec 08             	sub    $0x8,%esp
    static int init = 0;
    if(!init)
   14fd8:	a1 1c 70 03 00       	mov    0x3701c,%eax
   14fdd:	85 c0                	test   %eax,%eax
   14fdf:	75 3d                	jne    1501e <kbd_init+0x4c>
    {
        kernel_memset((void*)&kbd_state, 0, sizeof(kbd_state));
   14fe1:	83 ec 04             	sub    $0x4,%esp
   14fe4:	6a 04                	push   $0x4
   14fe6:	6a 00                	push   $0x0
   14fe8:	68 00 02 06 00       	push   $0x60200
   14fed:	e8 b0 39 00 00       	call   189a2 <kernel_memset>
   14ff2:	83 c4 10             	add    $0x10,%esp
        irq_install(IRQ1_KEYBOARD, (irq_handler_t)exception_handler_kbd);
   14ff5:	83 ec 08             	sub    $0x8,%esp
   14ff8:	68 7b 02 01 00       	push   $0x1027b
   14ffd:	6a 21                	push   $0x21
   14fff:	e8 8d dc ff ff       	call   12c91 <irq_install>
   15004:	83 c4 10             	add    $0x10,%esp
        irq_enable(IRQ1_KEYBOARD);
   15007:	83 ec 0c             	sub    $0xc,%esp
   1500a:	6a 21                	push   $0x21
   1500c:	e8 2a e1 ff ff       	call   1313b <irq_enable>
   15011:	83 c4 10             	add    $0x10,%esp
        init = 1;
   15014:	c7 05 1c 70 03 00 01 	movl   $0x1,0x3701c
   1501b:	00 00 00 
    }
}
   1501e:	90                   	nop
   1501f:	c9                   	leave  
   15020:	c3                   	ret    

00015021 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   15021:	55                   	push   %ebp
   15022:	89 e5                	mov    %esp,%ebp
   15024:	83 ec 08             	sub    $0x8,%esp
   15027:	8b 55 08             	mov    0x8(%ebp),%edx
   1502a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1502d:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   15031:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   15034:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   15038:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   1503c:	ee                   	out    %al,(%dx)
}
   1503d:	90                   	nop
   1503e:	c9                   	leave  
   1503f:	c3                   	ret    

00015040 <init_pit>:
#include "core/task.h"
static uint32_t sys_tick;
/**
 * 初始化硬件定时器
 */
static void init_pit(){
   15040:	55                   	push   %ebp
   15041:	89 e5                	mov    %esp,%ebp
   15043:	83 ec 18             	sub    $0x18,%esp
    uint32_t reload_count = OS_TICK_MS * PIT_OSC_FREQ / 1000;
   15046:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNEL | PIT_LOAD_LOHI| PIT_MODE3);
   1504d:	6a 36                	push   $0x36
   1504f:	6a 43                	push   $0x43
   15051:	e8 cb ff ff ff       	call   15021 <outb>
   15056:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);
   15059:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1505c:	0f b6 c0             	movzbl %al,%eax
   1505f:	50                   	push   %eax
   15060:	6a 40                	push   $0x40
   15062:	e8 ba ff ff ff       	call   15021 <outb>
   15067:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF);
   1506a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1506d:	c1 e8 08             	shr    $0x8,%eax
   15070:	0f b6 c0             	movzbl %al,%eax
   15073:	50                   	push   %eax
   15074:	6a 40                	push   $0x40
   15076:	e8 a6 ff ff ff       	call   15021 <outb>
   1507b:	83 c4 08             	add    $0x8,%esp
    irq_install(IRQ0_TIME , exception_handler_time);
   1507e:	83 ec 08             	sub    $0x8,%esp
   15081:	68 5e 02 01 00       	push   $0x1025e
   15086:	6a 20                	push   $0x20
   15088:	e8 04 dc ff ff       	call   12c91 <irq_install>
   1508d:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIME);
   15090:	83 ec 0c             	sub    $0xc,%esp
   15093:	6a 20                	push   $0x20
   15095:	e8 a1 e0 ff ff       	call   1313b <irq_enable>
   1509a:	83 c4 10             	add    $0x10,%esp
}
   1509d:	90                   	nop
   1509e:	c9                   	leave  
   1509f:	c3                   	ret    

000150a0 <do_handler_time>:
void do_handler_time(exception_frame_t* frame){
   150a0:	55                   	push   %ebp
   150a1:	89 e5                	mov    %esp,%ebp
   150a3:	83 ec 08             	sub    $0x8,%esp
    ++sys_tick;
   150a6:	a1 20 70 03 00       	mov    0x37020,%eax
   150ab:	83 c0 01             	add    $0x1,%eax
   150ae:	a3 20 70 03 00       	mov    %eax,0x37020
    pic_send_eoi(IRQ0_TIME); //通知芯片，中断已经处理完成了，
   150b3:	83 ec 0c             	sub    $0xc,%esp
   150b6:	6a 20                	push   $0x20
   150b8:	e8 3e e3 ff ff       	call   133fb <pic_send_eoi>
   150bd:	83 c4 10             	add    $0x10,%esp
    //芯片会继续准备接收下一个中断信号

    task_time_tick();
   150c0:	e8 65 c9 ff ff       	call   11a2a <task_time_tick>
}
   150c5:	90                   	nop
   150c6:	c9                   	leave  
   150c7:	c3                   	ret    

000150c8 <timer_init>:
/**
 * 定时器初始化
 */
void timer_init(void)
{
   150c8:	55                   	push   %ebp
   150c9:	89 e5                	mov    %esp,%ebp
   150cb:	83 ec 08             	sub    $0x8,%esp
    sys_tick = 0;
   150ce:	c7 05 20 70 03 00 00 	movl   $0x0,0x37020
   150d5:	00 00 00 
    init_pit();
   150d8:	e8 63 ff ff ff       	call   15040 <init_pit>
   150dd:	90                   	nop
   150de:	c9                   	leave  
   150df:	c3                   	ret    

000150e0 <fifo_init>:
static tty_t tty_devs[TTY_NUM];
static int curr_tty = 0;
/**
 * @brief 打开tty设备
 */
void fifo_init(tty_fifo_t* fifo, char* buf, int size){
   150e0:	55                   	push   %ebp
   150e1:	89 e5                	mov    %esp,%ebp
	fifo-> buf = buf;
   150e3:	8b 45 08             	mov    0x8(%ebp),%eax
   150e6:	8b 55 0c             	mov    0xc(%ebp),%edx
   150e9:	89 10                	mov    %edx,(%eax)
	fifo->size = size;
   150eb:	8b 45 08             	mov    0x8(%ebp),%eax
   150ee:	8b 55 10             	mov    0x10(%ebp),%edx
   150f1:	89 50 04             	mov    %edx,0x4(%eax)
	fifo->count = 0;
   150f4:	8b 45 08             	mov    0x8(%ebp),%eax
   150f7:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	fifo->read	= fifo->write = 0;
   150fe:	8b 45 08             	mov    0x8(%ebp),%eax
   15101:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
   15108:	8b 45 08             	mov    0x8(%ebp),%eax
   1510b:	8b 50 0c             	mov    0xc(%eax),%edx
   1510e:	8b 45 08             	mov    0x8(%ebp),%eax
   15111:	89 50 08             	mov    %edx,0x8(%eax)
}
   15114:	90                   	nop
   15115:	5d                   	pop    %ebp
   15116:	c3                   	ret    

00015117 <tty_open>:
int tty_open (device_t * dev)  {
   15117:	55                   	push   %ebp
   15118:	89 e5                	mov    %esp,%ebp
   1511a:	83 ec 18             	sub    $0x18,%esp
	
	int idx = dev -> minor;
   1511d:	8b 45 08             	mov    0x8(%ebp),%eax
   15120:	8b 40 04             	mov    0x4(%eax),%eax
   15123:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(idx < 0 || idx >= TTY_NUM)
   15126:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1512a:	78 06                	js     15132 <tty_open+0x1b>
   1512c:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   15130:	7e 0a                	jle    1513c <tty_open+0x25>
		return -1;
   15132:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15137:	e9 bf 00 00 00       	jmp    151fb <tty_open+0xe4>
	tty_t* tty = tty_devs + idx;
   1513c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1513f:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15145:	05 40 70 03 00       	add    $0x37040,%eax
   1514a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	sem_init(&tty->osem, TTY_OBUF_SIZE);
   1514d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15150:	05 28 04 00 00       	add    $0x428,%eax
   15155:	83 ec 08             	sub    $0x8,%esp
   15158:	68 00 02 00 00       	push   $0x200
   1515d:	50                   	push   %eax
   1515e:	e8 82 32 00 00       	call   183e5 <sem_init>
   15163:	83 c4 10             	add    $0x10,%esp
	sem_init(&tty->isem, 0);
   15166:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15169:	05 38 04 00 00       	add    $0x438,%eax
   1516e:	83 ec 08             	sub    $0x8,%esp
   15171:	6a 00                	push   $0x0
   15173:	50                   	push   %eax
   15174:	e8 6c 32 00 00       	call   183e5 <sem_init>
   15179:	83 c4 10             	add    $0x10,%esp
	fifo_init(&tty->ififo, tty->ibuf, TTY_IBUF_SIZE);
   1517c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1517f:	8d 90 14 02 00 00    	lea    0x214(%eax),%edx
   15185:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15188:	05 14 04 00 00       	add    $0x414,%eax
   1518d:	83 ec 04             	sub    $0x4,%esp
   15190:	68 00 02 00 00       	push   $0x200
   15195:	52                   	push   %edx
   15196:	50                   	push   %eax
   15197:	e8 44 ff ff ff       	call   150e0 <fifo_init>
   1519c:	83 c4 10             	add    $0x10,%esp
	fifo_init(&tty->ofifo, tty->obuf, TTY_OBUF_SIZE);
   1519f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
   151a5:	81 c2 00 02 00 00    	add    $0x200,%edx
   151ab:	83 ec 04             	sub    $0x4,%esp
   151ae:	68 00 02 00 00       	push   $0x200
   151b3:	50                   	push   %eax
   151b4:	52                   	push   %edx
   151b5:	e8 26 ff ff ff       	call   150e0 <fifo_init>
   151ba:	83 c4 10             	add    $0x10,%esp
	tty->oflags = TTY_OCRLF;
   151bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151c0:	c7 80 4c 04 00 00 01 	movl   $0x1,0x44c(%eax)
   151c7:	00 00 00 
	tty->iflags = TTY_INCLR | TTY_IECHO;
   151ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151cd:	c7 80 48 04 00 00 03 	movl   $0x3,0x448(%eax)
   151d4:	00 00 00 
	tty->console_idx = idx;
   151d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151da:	8b 55 f4             	mov    -0xc(%ebp),%edx
   151dd:	89 90 50 04 00 00    	mov    %edx,0x450(%eax)
	console_init(idx);
   151e3:	83 ec 0c             	sub    $0xc,%esp
   151e6:	ff 75 f4             	pushl  -0xc(%ebp)
   151e9:	e8 2b e4 ff ff       	call   13619 <console_init>
   151ee:	83 c4 10             	add    $0x10,%esp
	kbd_init();
   151f1:	e8 dc fd ff ff       	call   14fd2 <kbd_init>
	return 0;
   151f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   151fb:	c9                   	leave  
   151fc:	c3                   	ret    

000151fd <tty_fifo_get>:
int tty_fifo_get (tty_fifo_t * fifo, char * c) {
   151fd:	55                   	push   %ebp
   151fe:	89 e5                	mov    %esp,%ebp
   15200:	53                   	push   %ebx
   15201:	83 ec 14             	sub    $0x14,%esp
	
	if (fifo->count <= 0) {
   15204:	8b 45 08             	mov    0x8(%ebp),%eax
   15207:	8b 40 10             	mov    0x10(%eax),%eax
   1520a:	85 c0                	test   %eax,%eax
   1520c:	7f 07                	jg     15215 <tty_fifo_get+0x18>
		return -1;
   1520e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15213:	eb 62                	jmp    15277 <tty_fifo_get+0x7a>
	}
	irq_state_t state = enter_protection();
   15215:	e8 0c e2 ff ff       	call   13426 <enter_protection>
   1521a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	*c = fifo->buf[fifo->read++];
   1521d:	8b 45 08             	mov    0x8(%ebp),%eax
   15220:	8b 18                	mov    (%eax),%ebx
   15222:	8b 45 08             	mov    0x8(%ebp),%eax
   15225:	8b 40 08             	mov    0x8(%eax),%eax
   15228:	8d 48 01             	lea    0x1(%eax),%ecx
   1522b:	8b 55 08             	mov    0x8(%ebp),%edx
   1522e:	89 4a 08             	mov    %ecx,0x8(%edx)
   15231:	01 d8                	add    %ebx,%eax
   15233:	0f b6 10             	movzbl (%eax),%edx
   15236:	8b 45 0c             	mov    0xc(%ebp),%eax
   15239:	88 10                	mov    %dl,(%eax)
	if (fifo->read >= fifo->size) {
   1523b:	8b 45 08             	mov    0x8(%ebp),%eax
   1523e:	8b 50 08             	mov    0x8(%eax),%edx
   15241:	8b 45 08             	mov    0x8(%ebp),%eax
   15244:	8b 40 04             	mov    0x4(%eax),%eax
   15247:	39 c2                	cmp    %eax,%edx
   15249:	7c 0a                	jl     15255 <tty_fifo_get+0x58>
		fifo->read = 0;
   1524b:	8b 45 08             	mov    0x8(%ebp),%eax
   1524e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	}
	fifo->count--;
   15255:	8b 45 08             	mov    0x8(%ebp),%eax
   15258:	8b 40 10             	mov    0x10(%eax),%eax
   1525b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1525e:	8b 45 08             	mov    0x8(%ebp),%eax
   15261:	89 50 10             	mov    %edx,0x10(%eax)
	leave_protection(state);
   15264:	83 ec 0c             	sub    $0xc,%esp
   15267:	ff 75 f4             	pushl  -0xc(%ebp)
   1526a:	e8 cf e1 ff ff       	call   1343e <leave_protection>
   1526f:	83 c4 10             	add    $0x10,%esp

	return 0;
   15272:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15277:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1527a:	c9                   	leave  
   1527b:	c3                   	ret    

0001527c <tty_fifo_put>:
int tty_fifo_put (tty_fifo_t * fifo, char c) {
   1527c:	55                   	push   %ebp
   1527d:	89 e5                	mov    %esp,%ebp
   1527f:	53                   	push   %ebx
   15280:	83 ec 24             	sub    $0x24,%esp
   15283:	8b 45 0c             	mov    0xc(%ebp),%eax
   15286:	88 45 e4             	mov    %al,-0x1c(%ebp)
	irq_state_t state = enter_protection();
   15289:	e8 98 e1 ff ff       	call   13426 <enter_protection>
   1528e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (fifo->count >= fifo->size) {
   15291:	8b 45 08             	mov    0x8(%ebp),%eax
   15294:	8b 50 10             	mov    0x10(%eax),%edx
   15297:	8b 45 08             	mov    0x8(%ebp),%eax
   1529a:	8b 40 04             	mov    0x4(%eax),%eax
   1529d:	39 c2                	cmp    %eax,%edx
   1529f:	7c 15                	jl     152b6 <tty_fifo_put+0x3a>
		leave_protection(state);
   152a1:	83 ec 0c             	sub    $0xc,%esp
   152a4:	ff 75 f4             	pushl  -0xc(%ebp)
   152a7:	e8 92 e1 ff ff       	call   1343e <leave_protection>
   152ac:	83 c4 10             	add    $0x10,%esp
		return -1;
   152af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   152b4:	eb 59                	jmp    1530f <tty_fifo_put+0x93>
	}

	fifo->buf[fifo->write++] = c;
   152b6:	8b 45 08             	mov    0x8(%ebp),%eax
   152b9:	8b 18                	mov    (%eax),%ebx
   152bb:	8b 45 08             	mov    0x8(%ebp),%eax
   152be:	8b 40 0c             	mov    0xc(%eax),%eax
   152c1:	8d 48 01             	lea    0x1(%eax),%ecx
   152c4:	8b 55 08             	mov    0x8(%ebp),%edx
   152c7:	89 4a 0c             	mov    %ecx,0xc(%edx)
   152ca:	8d 14 03             	lea    (%ebx,%eax,1),%edx
   152cd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   152d1:	88 02                	mov    %al,(%edx)
	if (fifo->write >= fifo->size) {
   152d3:	8b 45 08             	mov    0x8(%ebp),%eax
   152d6:	8b 50 0c             	mov    0xc(%eax),%edx
   152d9:	8b 45 08             	mov    0x8(%ebp),%eax
   152dc:	8b 40 04             	mov    0x4(%eax),%eax
   152df:	39 c2                	cmp    %eax,%edx
   152e1:	7c 0a                	jl     152ed <tty_fifo_put+0x71>
		fifo->write = 0;
   152e3:	8b 45 08             	mov    0x8(%ebp),%eax
   152e6:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
	fifo->count++;
   152ed:	8b 45 08             	mov    0x8(%ebp),%eax
   152f0:	8b 40 10             	mov    0x10(%eax),%eax
   152f3:	8d 50 01             	lea    0x1(%eax),%edx
   152f6:	8b 45 08             	mov    0x8(%ebp),%eax
   152f9:	89 50 10             	mov    %edx,0x10(%eax)
	leave_protection(state);
   152fc:	83 ec 0c             	sub    $0xc,%esp
   152ff:	ff 75 f4             	pushl  -0xc(%ebp)
   15302:	e8 37 e1 ff ff       	call   1343e <leave_protection>
   15307:	83 c4 10             	add    $0x10,%esp
	return 0;
   1530a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1530f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15312:	c9                   	leave  
   15313:	c3                   	ret    

00015314 <get_tty>:
static inline tty_t * get_tty (device_t * dev) {
   15314:	55                   	push   %ebp
   15315:	89 e5                	mov    %esp,%ebp
   15317:	83 ec 18             	sub    $0x18,%esp
	int tty = dev->minor;
   1531a:	8b 45 08             	mov    0x8(%ebp),%eax
   1531d:	8b 40 04             	mov    0x4(%eax),%eax
   15320:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if ((tty < 0) || (tty >= TTY_NR) || (!dev->open_count)) {
   15323:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15327:	78 10                	js     15339 <get_tty+0x25>
   15329:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   1532d:	7f 0a                	jg     15339 <get_tty+0x25>
   1532f:	8b 45 08             	mov    0x8(%ebp),%eax
   15332:	8b 40 10             	mov    0x10(%eax),%eax
   15335:	85 c0                	test   %eax,%eax
   15337:	75 1a                	jne    15353 <get_tty+0x3f>
		log_printf("tty is not opened. tty = %d", tty);
   15339:	83 ec 08             	sub    $0x8,%esp
   1533c:	ff 75 f4             	pushl  -0xc(%ebp)
   1533f:	68 58 9e 01 00       	push   $0x19e58
   15344:	e8 03 3c 00 00       	call   18f4c <log_printf>
   15349:	83 c4 10             	add    $0x10,%esp
		return (tty_t *)0;
   1534c:	b8 00 00 00 00       	mov    $0x0,%eax
   15351:	eb 0e                	jmp    15361 <get_tty+0x4d>
	}

	return tty_devs + tty;
   15353:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15356:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1535c:	05 40 70 03 00       	add    $0x37040,%eax
}
   15361:	c9                   	leave  
   15362:	c3                   	ret    

00015363 <tty_read>:
/**
 * @brief 从tty读取数据
 */
int tty_read (device_t * dev, int addr, char * buf, int size) {
   15363:	55                   	push   %ebp
   15364:	89 e5                	mov    %esp,%ebp
   15366:	83 ec 18             	sub    $0x18,%esp
	tty_t* tty = get_tty(dev);
   15369:	83 ec 0c             	sub    $0xc,%esp
   1536c:	ff 75 08             	pushl  0x8(%ebp)
   1536f:	e8 a0 ff ff ff       	call   15314 <get_tty>
   15374:	83 c4 10             	add    $0x10,%esp
   15377:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if(tty == (tty_t *)0)
   1537a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1537e:	75 0a                	jne    1538a <tty_read+0x27>
		return -1;
   15380:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15385:	e9 f9 00 00 00       	jmp    15483 <tty_read+0x120>
	int len = 0;
   1538a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	char* pbuf = buf;
   15391:	8b 45 10             	mov    0x10(%ebp),%eax
   15394:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while(len < size)
   15397:	e9 d8 00 00 00       	jmp    15474 <tty_read+0x111>
	{
		char c ;
		sem_wait(&tty->isem);
   1539c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1539f:	05 38 04 00 00       	add    $0x438,%eax
   153a4:	83 ec 0c             	sub    $0xc,%esp
   153a7:	50                   	push   %eax
   153a8:	e8 5b 30 00 00       	call   18408 <sem_wait>
   153ad:	83 c4 10             	add    $0x10,%esp
		tty_fifo_get(&tty->ififo, &c);
   153b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   153b3:	8d 90 14 04 00 00    	lea    0x414(%eax),%edx
   153b9:	83 ec 08             	sub    $0x8,%esp
   153bc:	8d 45 eb             	lea    -0x15(%ebp),%eax
   153bf:	50                   	push   %eax
   153c0:	52                   	push   %edx
   153c1:	e8 37 fe ff ff       	call   151fd <tty_fifo_get>
   153c6:	83 c4 10             	add    $0x10,%esp
		switch(c)
   153c9:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   153cd:	0f be c0             	movsbl %al,%eax
   153d0:	83 f8 0a             	cmp    $0xa,%eax
   153d3:	74 1a                	je     153ef <tty_read+0x8c>
   153d5:	83 f8 7f             	cmp    $0x7f,%eax
   153d8:	75 52                	jne    1542c <tty_read+0xc9>
		{
			case 0x7F:
			if (len == 0) {
   153da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   153de:	75 05                	jne    153e5 <tty_read+0x82>
   153e0:	e9 8f 00 00 00       	jmp    15474 <tty_read+0x111>
				continue;
			}
			len--;
   153e5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
			pbuf--;
   153e9:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
			break;
   153ed:	eb 51                	jmp    15440 <tty_read+0xdd>
			case '\n':
			if((tty->iflags & TTY_INCLR) && len < size - 1)
   153ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
   153f2:	8b 80 48 04 00 00    	mov    0x448(%eax),%eax
   153f8:	83 e0 01             	and    $0x1,%eax
   153fb:	85 c0                	test   %eax,%eax
   153fd:	74 1b                	je     1541a <tty_read+0xb7>
   153ff:	8b 45 14             	mov    0x14(%ebp),%eax
   15402:	83 e8 01             	sub    $0x1,%eax
   15405:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   15408:	7d 10                	jge    1541a <tty_read+0xb7>
			{
				*pbuf++ = '\r';
   1540a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1540d:	8d 50 01             	lea    0x1(%eax),%edx
   15410:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15413:	c6 00 0d             	movb   $0xd,(%eax)
				len++;
   15416:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
			}
			*pbuf++ = '\n';
   1541a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1541d:	8d 50 01             	lea    0x1(%eax),%edx
   15420:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15423:	c6 00 0a             	movb   $0xa,(%eax)
			len++;
   15426:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
			break;
   1542a:	eb 14                	jmp    15440 <tty_read+0xdd>
			default:
				*pbuf++ = c;
   1542c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1542f:	8d 50 01             	lea    0x1(%eax),%edx
   15432:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15435:	0f b6 55 eb          	movzbl -0x15(%ebp),%edx
   15439:	88 10                	mov    %dl,(%eax)
				len++;
   1543b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
				break;
   1543f:	90                   	nop
		}
		if(tty->iflags & TTY_IECHO)
   15440:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15443:	8b 80 48 04 00 00    	mov    0x448(%eax),%eax
   15449:	83 e0 02             	and    $0x2,%eax
   1544c:	85 c0                	test   %eax,%eax
   1544e:	74 14                	je     15464 <tty_read+0x101>
			tty_write(dev, addr, &c, 1);
   15450:	6a 01                	push   $0x1
   15452:	8d 45 eb             	lea    -0x15(%ebp),%eax
   15455:	50                   	push   %eax
   15456:	ff 75 0c             	pushl  0xc(%ebp)
   15459:	ff 75 08             	pushl  0x8(%ebp)
   1545c:	e8 24 00 00 00       	call   15485 <tty_write>
   15461:	83 c4 10             	add    $0x10,%esp
		if(c =='\n' || c =='\r')
   15464:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   15468:	3c 0a                	cmp    $0xa,%al
   1546a:	74 14                	je     15480 <tty_read+0x11d>
   1546c:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
   15470:	3c 0d                	cmp    $0xd,%al
   15472:	74 0c                	je     15480 <tty_read+0x11d>
	while(len < size)
   15474:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15477:	3b 45 14             	cmp    0x14(%ebp),%eax
   1547a:	0f 8c 1c ff ff ff    	jl     1539c <tty_read+0x39>
			break;
	}
	return len;
   15480:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   15483:	c9                   	leave  
   15484:	c3                   	ret    

00015485 <tty_write>:

/**
 * @brief 向tty写入数据
 */
int tty_write (device_t * dev, int addr, char * buf, int size) {
   15485:	55                   	push   %ebp
   15486:	89 e5                	mov    %esp,%ebp
   15488:	83 ec 28             	sub    $0x28,%esp
	tty_t* tty = get_tty(dev);
   1548b:	83 ec 0c             	sub    $0xc,%esp
   1548e:	ff 75 08             	pushl  0x8(%ebp)
   15491:	e8 7e fe ff ff       	call   15314 <get_tty>
   15496:	83 c4 10             	add    $0x10,%esp
   15499:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if(tty == (tty_t *)0)
   1549c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   154a0:	75 0a                	jne    154ac <tty_write+0x27>
		return -1;
   154a2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   154a7:	e9 cc 00 00 00       	jmp    15578 <tty_write+0xf3>
	int len = 0;
   154ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	while (size > 0)
   154b3:	e9 b3 00 00 00       	jmp    1556b <tty_write+0xe6>
	{
		char c = *buf++;
   154b8:	8b 45 10             	mov    0x10(%ebp),%eax
   154bb:	8d 50 01             	lea    0x1(%eax),%edx
   154be:	89 55 10             	mov    %edx,0x10(%ebp)
   154c1:	0f b6 00             	movzbl (%eax),%eax
   154c4:	88 45 ef             	mov    %al,-0x11(%ebp)
		if(c == '\n' && (tty->oflags & TTY_OCRLF))
   154c7:	80 7d ef 0a          	cmpb   $0xa,-0x11(%ebp)
   154cb:	75 4a                	jne    15517 <tty_write+0x92>
   154cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154d0:	8b 80 4c 04 00 00    	mov    0x44c(%eax),%eax
   154d6:	83 e0 01             	and    $0x1,%eax
   154d9:	85 c0                	test   %eax,%eax
   154db:	74 3a                	je     15517 <tty_write+0x92>
		{
			sem_wait(&tty->osem);
   154dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154e0:	05 28 04 00 00       	add    $0x428,%eax
   154e5:	83 ec 0c             	sub    $0xc,%esp
   154e8:	50                   	push   %eax
   154e9:	e8 1a 2f 00 00       	call   18408 <sem_wait>
   154ee:	83 c4 10             	add    $0x10,%esp
			int err = tty_fifo_put(&tty->ofifo, '\r');
   154f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154f4:	05 00 02 00 00       	add    $0x200,%eax
   154f9:	83 ec 08             	sub    $0x8,%esp
   154fc:	6a 0d                	push   $0xd
   154fe:	50                   	push   %eax
   154ff:	e8 78 fd ff ff       	call   1527c <tty_fifo_put>
   15504:	83 c4 10             	add    $0x10,%esp
   15507:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if(err < 0)
   1550a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1550e:	79 07                	jns    15517 <tty_write+0x92>
				return -1;
   15510:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15515:	eb 61                	jmp    15578 <tty_write+0xf3>
		}
		sem_wait(&tty->osem);
   15517:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1551a:	05 28 04 00 00       	add    $0x428,%eax
   1551f:	83 ec 0c             	sub    $0xc,%esp
   15522:	50                   	push   %eax
   15523:	e8 e0 2e 00 00       	call   18408 <sem_wait>
   15528:	83 c4 10             	add    $0x10,%esp
		int err = tty_fifo_put(&tty->ofifo, c);
   1552b:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
   1552f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15532:	81 c2 00 02 00 00    	add    $0x200,%edx
   15538:	83 ec 08             	sub    $0x8,%esp
   1553b:	50                   	push   %eax
   1553c:	52                   	push   %edx
   1553d:	e8 3a fd ff ff       	call   1527c <tty_fifo_put>
   15542:	83 c4 10             	add    $0x10,%esp
   15545:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(err < 0)
   15548:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1554c:	79 07                	jns    15555 <tty_write+0xd0>
			return -1;
   1554e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15553:	eb 23                	jmp    15578 <tty_write+0xf3>
		++len;
   15555:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
		--size;
   15559:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
		console_write(tty);
   1555d:	83 ec 0c             	sub    $0xc,%esp
   15560:	ff 75 f0             	pushl  -0x10(%ebp)
   15563:	e8 e2 e7 ff ff       	call   13d4a <console_write>
   15568:	83 c4 10             	add    $0x10,%esp
	while (size > 0)
   1556b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1556f:	0f 8f 43 ff ff ff    	jg     154b8 <tty_write+0x33>
	} 
	
	return len;
   15575:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   15578:	c9                   	leave  
   15579:	c3                   	ret    

0001557a <tty_in>:

void tty_in(char c)
{
   1557a:	55                   	push   %ebp
   1557b:	89 e5                	mov    %esp,%ebp
   1557d:	83 ec 28             	sub    $0x28,%esp
   15580:	8b 45 08             	mov    0x8(%ebp),%eax
   15583:	88 45 e4             	mov    %al,-0x1c(%ebp)
	tty_t* tty = tty_devs + curr_tty;
   15586:	a1 e0 92 03 00       	mov    0x392e0,%eax
   1558b:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15591:	05 40 70 03 00       	add    $0x37040,%eax
   15596:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(sem_count(&tty->isem) >= TTY_IBUF_SIZE ){
   15599:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1559c:	05 38 04 00 00       	add    $0x438,%eax
   155a1:	83 ec 0c             	sub    $0xc,%esp
   155a4:	50                   	push   %eax
   155a5:	e8 4b 2f 00 00       	call   184f5 <sem_count>
   155aa:	83 c4 10             	add    $0x10,%esp
   155ad:	3d ff 01 00 00       	cmp    $0x1ff,%eax
   155b2:	7f 30                	jg     155e4 <tty_in+0x6a>
		return;
	}
	tty_fifo_put(&tty->ififo, c);
   155b4:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
   155b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   155bb:	81 c2 14 04 00 00    	add    $0x414,%edx
   155c1:	83 ec 08             	sub    $0x8,%esp
   155c4:	50                   	push   %eax
   155c5:	52                   	push   %edx
   155c6:	e8 b1 fc ff ff       	call   1527c <tty_fifo_put>
   155cb:	83 c4 10             	add    $0x10,%esp
	sem_notify(&tty->isem);
   155ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
   155d1:	05 38 04 00 00       	add    $0x438,%eax
   155d6:	83 ec 0c             	sub    $0xc,%esp
   155d9:	50                   	push   %eax
   155da:	e8 94 2e 00 00       	call   18473 <sem_notify>
   155df:	83 c4 10             	add    $0x10,%esp
   155e2:	eb 01                	jmp    155e5 <tty_in+0x6b>
		return;
   155e4:	90                   	nop
}
   155e5:	c9                   	leave  
   155e6:	c3                   	ret    

000155e7 <tty_control>:
/**
 * @brief 向tty设备发送命令
 */
int tty_control (device_t * dev, int cmd, int arg0, int arg1) {
   155e7:	55                   	push   %ebp
   155e8:	89 e5                	mov    %esp,%ebp
   155ea:	83 ec 18             	sub    $0x18,%esp
	tty_t* tty = get_tty(dev);
   155ed:	83 ec 0c             	sub    $0xc,%esp
   155f0:	ff 75 08             	pushl  0x8(%ebp)
   155f3:	e8 1c fd ff ff       	call   15314 <get_tty>
   155f8:	83 c4 10             	add    $0x10,%esp
   155fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (cmd)
   155fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   15601:	83 f8 01             	cmp    $0x1,%eax
   15604:	74 02                	je     15608 <tty_control+0x21>
		else	
			tty->iflags &= ~TTY_IECHO;
		break;
	
	default:
		break;
   15606:	eb 37                	jmp    1563f <tty_control+0x58>
		if(arg0)
   15608:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1560c:	74 19                	je     15627 <tty_control+0x40>
			tty->iflags |= TTY_IECHO;
   1560e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15611:	8b 80 48 04 00 00    	mov    0x448(%eax),%eax
   15617:	83 c8 02             	or     $0x2,%eax
   1561a:	89 c2                	mov    %eax,%edx
   1561c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1561f:	89 90 48 04 00 00    	mov    %edx,0x448(%eax)
		break;
   15625:	eb 17                	jmp    1563e <tty_control+0x57>
			tty->iflags &= ~TTY_IECHO;
   15627:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1562a:	8b 80 48 04 00 00    	mov    0x448(%eax),%eax
   15630:	83 e0 fd             	and    $0xfffffffd,%eax
   15633:	89 c2                	mov    %eax,%edx
   15635:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15638:	89 90 48 04 00 00    	mov    %edx,0x448(%eax)
		break;
   1563e:	90                   	nop
	}
}
   1563f:	90                   	nop
   15640:	c9                   	leave  
   15641:	c3                   	ret    

00015642 <tty_close>:

/**
 * @brief 关闭tty设备
 */
void tty_close (device_t * dev) {
   15642:	55                   	push   %ebp
   15643:	89 e5                	mov    %esp,%ebp

}
   15645:	90                   	nop
   15646:	5d                   	pop    %ebp
   15647:	c3                   	ret    

00015648 <tty_select>:

void tty_select (int tty) {
   15648:	55                   	push   %ebp
   15649:	89 e5                	mov    %esp,%ebp
   1564b:	83 ec 08             	sub    $0x8,%esp
	if (tty != curr_tty) {
   1564e:	a1 e0 92 03 00       	mov    0x392e0,%eax
   15653:	39 45 08             	cmp    %eax,0x8(%ebp)
   15656:	74 16                	je     1566e <tty_select+0x26>
		console_select(tty);
   15658:	83 ec 0c             	sub    $0xc,%esp
   1565b:	ff 75 08             	pushl  0x8(%ebp)
   1565e:	e8 b6 e1 ff ff       	call   13819 <console_select>
   15663:	83 c4 10             	add    $0x10,%esp
		curr_tty = tty;
   15666:	8b 45 08             	mov    0x8(%ebp),%eax
   15669:	a3 e0 92 03 00       	mov    %eax,0x392e0
	}
}
   1566e:	90                   	nop
   1566f:	c9                   	leave  
   15670:	c3                   	ret    

00015671 <inb>:
static inline uint8_t inb(uint16_t  port) {
   15671:	55                   	push   %ebp
   15672:	89 e5                	mov    %esp,%ebp
   15674:	83 ec 14             	sub    $0x14,%esp
   15677:	8b 45 08             	mov    0x8(%ebp),%eax
   1567a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   1567e:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   15682:	89 c2                	mov    %eax,%edx
   15684:	ec                   	in     (%dx),%al
   15685:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   15688:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1568c:	c9                   	leave  
   1568d:	c3                   	ret    

0001568e <inw>:
static inline uint16_t inw(uint16_t  port) {
   1568e:	55                   	push   %ebp
   1568f:	89 e5                	mov    %esp,%ebp
   15691:	83 ec 14             	sub    $0x14,%esp
   15694:	8b 45 08             	mov    0x8(%ebp),%eax
   15697:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   1569b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   1569f:	89 c2                	mov    %eax,%edx
   156a1:	66 ed                	in     (%dx),%ax
   156a3:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   156a7:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   156ab:	c9                   	leave  
   156ac:	c3                   	ret    

000156ad <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   156ad:	55                   	push   %ebp
   156ae:	89 e5                	mov    %esp,%ebp
   156b0:	83 ec 08             	sub    $0x8,%esp
   156b3:	8b 55 08             	mov    0x8(%ebp),%edx
   156b6:	8b 45 0c             	mov    0xc(%ebp),%eax
   156b9:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   156bd:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   156c0:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   156c4:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   156c8:	ee                   	out    %al,(%dx)
}
   156c9:	90                   	nop
   156ca:	c9                   	leave  
   156cb:	c3                   	ret    

000156cc <read_disk>:
static void read_disk(int sector, int sector_count, uint8_t * buf) {
   156cc:	55                   	push   %ebp
   156cd:	89 e5                	mov    %esp,%ebp
   156cf:	53                   	push   %ebx
   156d0:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   156d3:	68 e0 00 00 00       	push   $0xe0
   156d8:	68 f6 01 00 00       	push   $0x1f6
   156dd:	e8 cb ff ff ff       	call   156ad <outb>
   156e2:	83 c4 08             	add    $0x8,%esp
	outb(0x1F2, (uint8_t) (sector_count >> 8));
   156e5:	8b 45 0c             	mov    0xc(%ebp),%eax
   156e8:	c1 f8 08             	sar    $0x8,%eax
   156eb:	0f b6 c0             	movzbl %al,%eax
   156ee:	50                   	push   %eax
   156ef:	68 f2 01 00 00       	push   $0x1f2
   156f4:	e8 b4 ff ff ff       	call   156ad <outb>
   156f9:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		// LBA参数的24~31位
   156fc:	8b 45 08             	mov    0x8(%ebp),%eax
   156ff:	c1 f8 18             	sar    $0x18,%eax
   15702:	0f b6 c0             	movzbl %al,%eax
   15705:	50                   	push   %eax
   15706:	68 f3 01 00 00       	push   $0x1f3
   1570b:	e8 9d ff ff ff       	call   156ad <outb>
   15710:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					// LBA参数的32~39位
   15713:	6a 00                	push   $0x0
   15715:	68 f4 01 00 00       	push   $0x1f4
   1571a:	e8 8e ff ff ff       	call   156ad <outb>
   1571f:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					// LBA参数的40~47位
   15722:	6a 00                	push   $0x0
   15724:	68 f5 01 00 00       	push   $0x1f5
   15729:	e8 7f ff ff ff       	call   156ad <outb>
   1572e:	83 c4 08             	add    $0x8,%esp
    outb(0x1F2, (uint8_t) (sector_count));
   15731:	8b 45 0c             	mov    0xc(%ebp),%eax
   15734:	0f b6 c0             	movzbl %al,%eax
   15737:	50                   	push   %eax
   15738:	68 f2 01 00 00       	push   $0x1f2
   1573d:	e8 6b ff ff ff       	call   156ad <outb>
   15742:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			// LBA参数的0~7位
   15745:	8b 45 08             	mov    0x8(%ebp),%eax
   15748:	0f b6 c0             	movzbl %al,%eax
   1574b:	50                   	push   %eax
   1574c:	68 f3 01 00 00       	push   $0x1f3
   15751:	e8 57 ff ff ff       	call   156ad <outb>
   15756:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		// LBA参数的8~15位
   15759:	8b 45 08             	mov    0x8(%ebp),%eax
   1575c:	c1 f8 08             	sar    $0x8,%eax
   1575f:	0f b6 c0             	movzbl %al,%eax
   15762:	50                   	push   %eax
   15763:	68 f4 01 00 00       	push   $0x1f4
   15768:	e8 40 ff ff ff       	call   156ad <outb>
   1576d:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		// LBA参数的16~23位
   15770:	8b 45 08             	mov    0x8(%ebp),%eax
   15773:	c1 f8 10             	sar    $0x10,%eax
   15776:	0f b6 c0             	movzbl %al,%eax
   15779:	50                   	push   %eax
   1577a:	68 f5 01 00 00       	push   $0x1f5
   1577f:	e8 29 ff ff ff       	call   156ad <outb>
   15784:	83 c4 08             	add    $0x8,%esp
	outb(0x1F7, (uint8_t) 0x24);
   15787:	6a 24                	push   $0x24
   15789:	68 f7 01 00 00       	push   $0x1f7
   1578e:	e8 1a ff ff ff       	call   156ad <outb>
   15793:	83 c4 08             	add    $0x8,%esp
	uint16_t *data_buf = (uint16_t*) buf;
   15796:	8b 45 10             	mov    0x10(%ebp),%eax
   15799:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (sector_count-- > 0) {
   1579c:	eb 4a                	jmp    157e8 <read_disk+0x11c>
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   1579e:	90                   	nop
   1579f:	68 f7 01 00 00       	push   $0x1f7
   157a4:	e8 c8 fe ff ff       	call   15671 <inb>
   157a9:	83 c4 04             	add    $0x4,%esp
   157ac:	0f b6 c0             	movzbl %al,%eax
   157af:	25 88 00 00 00       	and    $0x88,%eax
   157b4:	83 f8 08             	cmp    $0x8,%eax
   157b7:	75 e6                	jne    1579f <read_disk+0xd3>
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   157b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   157c0:	eb 1d                	jmp    157df <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   157c2:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   157c5:	8d 43 02             	lea    0x2(%ebx),%eax
   157c8:	89 45 f8             	mov    %eax,-0x8(%ebp)
   157cb:	68 f0 01 00 00       	push   $0x1f0
   157d0:	e8 b9 fe ff ff       	call   1568e <inw>
   157d5:	83 c4 04             	add    $0x4,%esp
   157d8:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   157db:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   157df:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   157e6:	7e da                	jle    157c2 <read_disk+0xf6>
	while (sector_count-- > 0) {
   157e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   157eb:	8d 50 ff             	lea    -0x1(%eax),%edx
   157ee:	89 55 0c             	mov    %edx,0xc(%ebp)
   157f1:	85 c0                	test   %eax,%eax
   157f3:	7f a9                	jg     1579e <read_disk+0xd2>
}
   157f5:	90                   	nop
   157f6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   157f9:	c9                   	leave  
   157fa:	c3                   	ret    

000157fb <devfs_mount>:
        .dev_type = DEV_TTY,
        .file_type = FILE_TTY,
    },
};

int devfs_mount (struct _fs_t * fs, int major, int minor) {
   157fb:	55                   	push   %ebp
   157fc:	89 e5                	mov    %esp,%ebp
    fs->type = FS_DEVFS;
   157fe:	8b 45 08             	mov    0x8(%ebp),%eax
   15801:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
   15808:	00 00 00 
    return 0;
   1580b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15810:	5d                   	pop    %ebp
   15811:	c3                   	ret    

00015812 <devfs_unmount>:


void devfs_unmount (struct _fs_t * fs) {
   15812:	55                   	push   %ebp
   15813:	89 e5                	mov    %esp,%ebp
}
   15815:	90                   	nop
   15816:	5d                   	pop    %ebp
   15817:	c3                   	ret    

00015818 <devfs_open>:


int devfs_open (struct _fs_t * fs, const char * path, file_t * file) {   
   15818:	55                   	push   %ebp
   15819:	89 e5                	mov    %esp,%ebp
   1581b:	83 ec 28             	sub    $0x28,%esp
    for(int i = 0; i < sizeof(dev_type_table)/sizeof(dev_type_table[0]); ++i)
   1581e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15825:	e9 f0 00 00 00       	jmp    1591a <devfs_open+0x102>
    {
        devfs_type_t* type = dev_type_table + i;
   1582a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1582d:	89 d0                	mov    %edx,%eax
   1582f:	01 c0                	add    %eax,%eax
   15831:	01 d0                	add    %edx,%eax
   15833:	c1 e0 02             	shl    $0x2,%eax
   15836:	05 e0 b0 01 00       	add    $0x1b0e0,%eax
   1583b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        int len = kernel_strlen(type->name);
   1583e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15841:	8b 00                	mov    (%eax),%eax
   15843:	83 ec 0c             	sub    $0xc,%esp
   15846:	50                   	push   %eax
   15847:	e8 52 30 00 00       	call   1889e <kernel_strlen>
   1584c:	83 c4 10             	add    $0x10,%esp
   1584f:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(kernel_strncmp(path, type->name, len) == 0)
   15852:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15855:	8b 00                	mov    (%eax),%eax
   15857:	83 ec 04             	sub    $0x4,%esp
   1585a:	ff 75 ec             	pushl  -0x14(%ebp)
   1585d:	50                   	push   %eax
   1585e:	ff 75 0c             	pushl  0xc(%ebp)
   15861:	e8 73 30 00 00       	call   188d9 <kernel_strncmp>
   15866:	83 c4 10             	add    $0x10,%esp
   15869:	85 c0                	test   %eax,%eax
   1586b:	0f 85 a5 00 00 00    	jne    15916 <devfs_open+0xfe>
        {
            int minor;
            if(kernel_strlen(path) > len && path_to_num(path + len, &minor) == 0)
   15871:	83 ec 0c             	sub    $0xc,%esp
   15874:	ff 75 0c             	pushl  0xc(%ebp)
   15877:	e8 22 30 00 00       	call   1889e <kernel_strlen>
   1587c:	83 c4 10             	add    $0x10,%esp
   1587f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   15882:	0f 8d 8e 00 00 00    	jge    15916 <devfs_open+0xfe>
   15888:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1588b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1588e:	01 c2                	add    %eax,%edx
   15890:	83 ec 08             	sub    $0x8,%esp
   15893:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   15896:	50                   	push   %eax
   15897:	52                   	push   %edx
   15898:	e8 f5 1a 00 00       	call   17392 <path_to_num>
   1589d:	83 c4 10             	add    $0x10,%esp
   158a0:	85 c0                	test   %eax,%eax
   158a2:	75 72                	jne    15916 <devfs_open+0xfe>
            {
                int dev_id = dev_open(type->dev_type, minor, (void *)0);
   158a4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   158a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158aa:	8b 40 04             	mov    0x4(%eax),%eax
   158ad:	83 ec 04             	sub    $0x4,%esp
   158b0:	6a 00                	push   $0x0
   158b2:	52                   	push   %edx
   158b3:	50                   	push   %eax
   158b4:	e8 20 e7 ff ff       	call   13fd9 <dev_open>
   158b9:	83 c4 10             	add    $0x10,%esp
   158bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
                if (dev_id < 0) {
   158bf:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   158c3:	79 16                	jns    158db <devfs_open+0xc3>
                    log_printf("Open device failed:%s", path);
   158c5:	83 ec 08             	sub    $0x8,%esp
   158c8:	ff 75 0c             	pushl  0xc(%ebp)
   158cb:	68 78 9e 01 00       	push   $0x19e78
   158d0:	e8 77 36 00 00       	call   18f4c <log_printf>
   158d5:	83 c4 10             	add    $0x10,%esp
                    break;
   158d8:	90                   	nop
   158d9:	eb 49                	jmp    15924 <devfs_open+0x10c>
                }
                file->dev_id = dev_id;
   158db:	8b 45 10             	mov    0x10(%ebp),%eax
   158de:	8b 55 e8             	mov    -0x18(%ebp),%edx
   158e1:	89 50 2c             	mov    %edx,0x2c(%eax)
                file->type = type->file_type;
   158e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158e7:	8b 40 08             	mov    0x8(%eax),%eax
   158ea:	89 c2                	mov    %eax,%edx
   158ec:	8b 45 10             	mov    0x10(%ebp),%eax
   158ef:	89 50 20             	mov    %edx,0x20(%eax)
                file->fs = fs;
   158f2:	8b 45 10             	mov    0x10(%ebp),%eax
   158f5:	8b 55 08             	mov    0x8(%ebp),%edx
   158f8:	89 50 44             	mov    %edx,0x44(%eax)
                file->pos = 0;
   158fb:	8b 45 10             	mov    0x10(%ebp),%eax
   158fe:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
                file->size = 0; 
   15905:	8b 45 10             	mov    0x10(%ebp),%eax
   15908:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
                return 0;
   1590f:	b8 00 00 00 00       	mov    $0x0,%eax
   15914:	eb 13                	jmp    15929 <devfs_open+0x111>
    for(int i = 0; i < sizeof(dev_type_table)/sizeof(dev_type_table[0]); ++i)
   15916:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1591a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1591e:	0f 84 06 ff ff ff    	je     1582a <devfs_open+0x12>
            }
        }
    }
    return -1;
   15924:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   15929:	c9                   	leave  
   1592a:	c3                   	ret    

0001592b <devfs_read>:


int devfs_read (char * buf, int size, file_t * file) {
   1592b:	55                   	push   %ebp
   1592c:	89 e5                	mov    %esp,%ebp
   1592e:	83 ec 08             	sub    $0x8,%esp
    return dev_read(file->dev_id, file->pos, buf, size);
   15931:	8b 45 10             	mov    0x10(%ebp),%eax
   15934:	8b 50 3c             	mov    0x3c(%eax),%edx
   15937:	8b 45 10             	mov    0x10(%ebp),%eax
   1593a:	8b 40 2c             	mov    0x2c(%eax),%eax
   1593d:	ff 75 0c             	pushl  0xc(%ebp)
   15940:	ff 75 08             	pushl  0x8(%ebp)
   15943:	52                   	push   %edx
   15944:	50                   	push   %eax
   15945:	e8 d9 e7 ff ff       	call   14123 <dev_read>
   1594a:	83 c4 10             	add    $0x10,%esp
}
   1594d:	c9                   	leave  
   1594e:	c3                   	ret    

0001594f <devfs_write>:


int devfs_write (char * buf, int size, file_t * file) {
   1594f:	55                   	push   %ebp
   15950:	89 e5                	mov    %esp,%ebp
   15952:	83 ec 08             	sub    $0x8,%esp
    return dev_write(file->dev_id, file->pos, buf, size);
   15955:	8b 45 10             	mov    0x10(%ebp),%eax
   15958:	8b 50 3c             	mov    0x3c(%eax),%edx
   1595b:	8b 45 10             	mov    0x10(%ebp),%eax
   1595e:	8b 40 2c             	mov    0x2c(%eax),%eax
   15961:	ff 75 0c             	pushl  0xc(%ebp)
   15964:	ff 75 08             	pushl  0x8(%ebp)
   15967:	52                   	push   %edx
   15968:	50                   	push   %eax
   15969:	e8 01 e8 ff ff       	call   1416f <dev_write>
   1596e:	83 c4 10             	add    $0x10,%esp
}
   15971:	c9                   	leave  
   15972:	c3                   	ret    

00015973 <devfs_close>:


void devfs_close (file_t * file) {
   15973:	55                   	push   %ebp
   15974:	89 e5                	mov    %esp,%ebp
   15976:	83 ec 08             	sub    $0x8,%esp
    dev_close(file->dev_id);
   15979:	8b 45 08             	mov    0x8(%ebp),%eax
   1597c:	8b 40 2c             	mov    0x2c(%eax),%eax
   1597f:	83 ec 0c             	sub    $0xc,%esp
   15982:	50                   	push   %eax
   15983:	e8 7f e8 ff ff       	call   14207 <dev_close>
   15988:	83 c4 10             	add    $0x10,%esp
}
   1598b:	90                   	nop
   1598c:	c9                   	leave  
   1598d:	c3                   	ret    

0001598e <devfs_seek>:


int devfs_seek (file_t * file, uint32_t offset, int dir) {
   1598e:	55                   	push   %ebp
   1598f:	89 e5                	mov    %esp,%ebp
    return -1;  
   15991:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   15996:	5d                   	pop    %ebp
   15997:	c3                   	ret    

00015998 <devfs_stat>:


int devfs_stat(file_t * file, struct stat *st) {
   15998:	55                   	push   %ebp
   15999:	89 e5                	mov    %esp,%ebp
    return -1;
   1599b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   159a0:	5d                   	pop    %ebp
   159a1:	c3                   	ret    

000159a2 <devfs_ioctl>:
int devfs_ioctl(file_t * file, int cmd, int arg0, int arg1) {
   159a2:	55                   	push   %ebp
   159a3:	89 e5                	mov    %esp,%ebp
   159a5:	83 ec 08             	sub    $0x8,%esp
    
    return dev_control(file->dev_id, cmd, arg0, arg1);
   159a8:	8b 45 08             	mov    0x8(%ebp),%eax
   159ab:	8b 40 2c             	mov    0x2c(%eax),%eax
   159ae:	ff 75 14             	pushl  0x14(%ebp)
   159b1:	ff 75 10             	pushl  0x10(%ebp)
   159b4:	ff 75 0c             	pushl  0xc(%ebp)
   159b7:	50                   	push   %eax
   159b8:	e8 fe e7 ff ff       	call   141bb <dev_control>
   159bd:	83 c4 10             	add    $0x10,%esp
}
   159c0:	c9                   	leave  
   159c1:	c3                   	ret    

000159c2 <inb>:
static inline uint8_t inb(uint16_t  port) {
   159c2:	55                   	push   %ebp
   159c3:	89 e5                	mov    %esp,%ebp
   159c5:	83 ec 14             	sub    $0x14,%esp
   159c8:	8b 45 08             	mov    0x8(%ebp),%eax
   159cb:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   159cf:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   159d3:	89 c2                	mov    %eax,%edx
   159d5:	ec                   	in     (%dx),%al
   159d6:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   159d9:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   159dd:	c9                   	leave  
   159de:	c3                   	ret    

000159df <inw>:
static inline uint16_t inw(uint16_t  port) {
   159df:	55                   	push   %ebp
   159e0:	89 e5                	mov    %esp,%ebp
   159e2:	83 ec 14             	sub    $0x14,%esp
   159e5:	8b 45 08             	mov    0x8(%ebp),%eax
   159e8:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   159ec:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   159f0:	89 c2                	mov    %eax,%edx
   159f2:	66 ed                	in     (%dx),%ax
   159f4:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   159f8:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   159fc:	c9                   	leave  
   159fd:	c3                   	ret    

000159fe <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   159fe:	55                   	push   %ebp
   159ff:	89 e5                	mov    %esp,%ebp
   15a01:	83 ec 08             	sub    $0x8,%esp
   15a04:	8b 55 08             	mov    0x8(%ebp),%edx
   15a07:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a0a:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   15a0e:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   15a11:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   15a15:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   15a19:	ee                   	out    %al,(%dx)
}
   15a1a:	90                   	nop
   15a1b:	c9                   	leave  
   15a1c:	c3                   	ret    

00015a1d <read_disk>:
static void read_disk(int sector, int sector_count, uint8_t * buf) {
   15a1d:	55                   	push   %ebp
   15a1e:	89 e5                	mov    %esp,%ebp
   15a20:	53                   	push   %ebx
   15a21:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   15a24:	68 e0 00 00 00       	push   $0xe0
   15a29:	68 f6 01 00 00       	push   $0x1f6
   15a2e:	e8 cb ff ff ff       	call   159fe <outb>
   15a33:	83 c4 08             	add    $0x8,%esp
	outb(0x1F2, (uint8_t) (sector_count >> 8));
   15a36:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a39:	c1 f8 08             	sar    $0x8,%eax
   15a3c:	0f b6 c0             	movzbl %al,%eax
   15a3f:	50                   	push   %eax
   15a40:	68 f2 01 00 00       	push   $0x1f2
   15a45:	e8 b4 ff ff ff       	call   159fe <outb>
   15a4a:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		// LBA参数的24~31位
   15a4d:	8b 45 08             	mov    0x8(%ebp),%eax
   15a50:	c1 f8 18             	sar    $0x18,%eax
   15a53:	0f b6 c0             	movzbl %al,%eax
   15a56:	50                   	push   %eax
   15a57:	68 f3 01 00 00       	push   $0x1f3
   15a5c:	e8 9d ff ff ff       	call   159fe <outb>
   15a61:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					// LBA参数的32~39位
   15a64:	6a 00                	push   $0x0
   15a66:	68 f4 01 00 00       	push   $0x1f4
   15a6b:	e8 8e ff ff ff       	call   159fe <outb>
   15a70:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					// LBA参数的40~47位
   15a73:	6a 00                	push   $0x0
   15a75:	68 f5 01 00 00       	push   $0x1f5
   15a7a:	e8 7f ff ff ff       	call   159fe <outb>
   15a7f:	83 c4 08             	add    $0x8,%esp
    outb(0x1F2, (uint8_t) (sector_count));
   15a82:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a85:	0f b6 c0             	movzbl %al,%eax
   15a88:	50                   	push   %eax
   15a89:	68 f2 01 00 00       	push   $0x1f2
   15a8e:	e8 6b ff ff ff       	call   159fe <outb>
   15a93:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			// LBA参数的0~7位
   15a96:	8b 45 08             	mov    0x8(%ebp),%eax
   15a99:	0f b6 c0             	movzbl %al,%eax
   15a9c:	50                   	push   %eax
   15a9d:	68 f3 01 00 00       	push   $0x1f3
   15aa2:	e8 57 ff ff ff       	call   159fe <outb>
   15aa7:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		// LBA参数的8~15位
   15aaa:	8b 45 08             	mov    0x8(%ebp),%eax
   15aad:	c1 f8 08             	sar    $0x8,%eax
   15ab0:	0f b6 c0             	movzbl %al,%eax
   15ab3:	50                   	push   %eax
   15ab4:	68 f4 01 00 00       	push   $0x1f4
   15ab9:	e8 40 ff ff ff       	call   159fe <outb>
   15abe:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		// LBA参数的16~23位
   15ac1:	8b 45 08             	mov    0x8(%ebp),%eax
   15ac4:	c1 f8 10             	sar    $0x10,%eax
   15ac7:	0f b6 c0             	movzbl %al,%eax
   15aca:	50                   	push   %eax
   15acb:	68 f5 01 00 00       	push   $0x1f5
   15ad0:	e8 29 ff ff ff       	call   159fe <outb>
   15ad5:	83 c4 08             	add    $0x8,%esp
	outb(0x1F7, (uint8_t) 0x24);
   15ad8:	6a 24                	push   $0x24
   15ada:	68 f7 01 00 00       	push   $0x1f7
   15adf:	e8 1a ff ff ff       	call   159fe <outb>
   15ae4:	83 c4 08             	add    $0x8,%esp
	uint16_t *data_buf = (uint16_t*) buf;
   15ae7:	8b 45 10             	mov    0x10(%ebp),%eax
   15aea:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (sector_count-- > 0) {
   15aed:	eb 4a                	jmp    15b39 <read_disk+0x11c>
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   15aef:	90                   	nop
   15af0:	68 f7 01 00 00       	push   $0x1f7
   15af5:	e8 c8 fe ff ff       	call   159c2 <inb>
   15afa:	83 c4 04             	add    $0x4,%esp
   15afd:	0f b6 c0             	movzbl %al,%eax
   15b00:	25 88 00 00 00       	and    $0x88,%eax
   15b05:	83 f8 08             	cmp    $0x8,%eax
   15b08:	75 e6                	jne    15af0 <read_disk+0xd3>
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   15b0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   15b11:	eb 1d                	jmp    15b30 <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   15b13:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   15b16:	8d 43 02             	lea    0x2(%ebx),%eax
   15b19:	89 45 f8             	mov    %eax,-0x8(%ebp)
   15b1c:	68 f0 01 00 00       	push   $0x1f0
   15b21:	e8 b9 fe ff ff       	call   159df <inw>
   15b26:	83 c4 04             	add    $0x4,%esp
   15b29:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   15b2c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   15b30:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   15b37:	7e da                	jle    15b13 <read_disk+0xf6>
	while (sector_count-- > 0) {
   15b39:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b3c:	8d 50 ff             	lea    -0x1(%eax),%edx
   15b3f:	89 55 0c             	mov    %edx,0xc(%ebp)
   15b42:	85 c0                	test   %eax,%eax
   15b44:	7f a9                	jg     15aef <read_disk+0xd2>
}
   15b46:	90                   	nop
   15b47:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15b4a:	c9                   	leave  
   15b4b:	c3                   	ret    

00015b4c <up2>:
static inline uint32_t up2 (uint32_t size, uint32_t bound) {
   15b4c:	55                   	push   %ebp
   15b4d:	89 e5                	mov    %esp,%ebp
    return (size + bound - 1) & ~(bound - 1);
   15b4f:	8b 55 08             	mov    0x8(%ebp),%edx
   15b52:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b55:	01 d0                	add    %edx,%eax
   15b57:	8d 50 ff             	lea    -0x1(%eax),%edx
   15b5a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b5d:	f7 d8                	neg    %eax
   15b5f:	21 d0                	and    %edx,%eax
}
   15b61:	5d                   	pop    %ebp
   15b62:	c3                   	ret    

00015b63 <get_item_type>:
#include "dev/dev.h"
#include "tools/log.h"
#include "tools/klib.h"
#include "sys/fcntl.h"
file_type_t get_item_type(diritem_t* item)
{
   15b63:	55                   	push   %ebp
   15b64:	89 e5                	mov    %esp,%ebp
   15b66:	83 ec 10             	sub    $0x10,%esp
    file_type_t type = FILE_UNKNOWN;
   15b69:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if((item->DIR_Attr & DIRITEM_ATTR_HIDDEN )|| (item->DIR_Attr & DIRITEM_ATTR_VOLUME_ID))
   15b70:	8b 45 08             	mov    0x8(%ebp),%eax
   15b73:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   15b77:	0f b6 c0             	movzbl %al,%eax
   15b7a:	83 e0 02             	and    $0x2,%eax
   15b7d:	85 c0                	test   %eax,%eax
   15b7f:	75 11                	jne    15b92 <get_item_type+0x2f>
   15b81:	8b 45 08             	mov    0x8(%ebp),%eax
   15b84:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   15b88:	0f b6 c0             	movzbl %al,%eax
   15b8b:	83 e0 08             	and    $0x8,%eax
   15b8e:	85 c0                	test   %eax,%eax
   15b90:	74 07                	je     15b99 <get_item_type+0x36>
        return FILE_UNKNOWN;
   15b92:	b8 00 00 00 00       	mov    $0x0,%eax
   15b97:	eb 35                	jmp    15bce <get_item_type+0x6b>
    if(item->DIR_Attr & DIRITEM_ATTR_LONG_NAME == DIRITEM_ATTR_LONG_NAME)
   15b99:	8b 45 08             	mov    0x8(%ebp),%eax
   15b9c:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   15ba0:	0f b6 c0             	movzbl %al,%eax
   15ba3:	83 e0 01             	and    $0x1,%eax
   15ba6:	85 c0                	test   %eax,%eax
   15ba8:	74 07                	je     15bb1 <get_item_type+0x4e>
        return FILE_UNKNOWN;
   15baa:	b8 00 00 00 00       	mov    $0x0,%eax
   15baf:	eb 1d                	jmp    15bce <get_item_type+0x6b>
    return item->DIR_Attr & DIRITEM_ATTR_DIRECTORY ? FILE_DIR : FILE_NORMAL;
   15bb1:	8b 45 08             	mov    0x8(%ebp),%eax
   15bb4:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
   15bb8:	0f b6 c0             	movzbl %al,%eax
   15bbb:	83 e0 10             	and    $0x10,%eax
   15bbe:	85 c0                	test   %eax,%eax
   15bc0:	74 07                	je     15bc9 <get_item_type+0x66>
   15bc2:	b8 02 00 00 00       	mov    $0x2,%eax
   15bc7:	eb 05                	jmp    15bce <get_item_type+0x6b>
   15bc9:	b8 03 00 00 00       	mov    $0x3,%eax
}
   15bce:	c9                   	leave  
   15bcf:	c3                   	ret    

00015bd0 <cluster_alloc_free>:
cluster_t cluster_alloc_free(fat_t* fat, int cnt)
{
   15bd0:	55                   	push   %ebp
   15bd1:	89 e5                	mov    %esp,%ebp
   15bd3:	83 ec 28             	sub    $0x28,%esp
    cluster_t curr, start, pre;
    int c_cluster = fat->tbl_sectors * fat->bytes_per_sec /  sizeof(cluster_t);
   15bd6:	8b 45 08             	mov    0x8(%ebp),%eax
   15bd9:	8b 50 08             	mov    0x8(%eax),%edx
   15bdc:	8b 45 08             	mov    0x8(%ebp),%eax
   15bdf:	8b 40 0c             	mov    0xc(%eax),%eax
   15be2:	0f af c2             	imul   %edx,%eax
   15be5:	d1 e8                	shr    %eax
   15be7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    start = FAT_CLUSTER_INVALID;
   15bea:	66 c7 45 f4 f8 ff    	movw   $0xfff8,-0xc(%ebp)
    pre = FAT_CLUSTER_INVALID;
   15bf0:	66 c7 45 f2 f8 ff    	movw   $0xfff8,-0xe(%ebp)
    for(curr = 2; cnt && (curr < c_cluster); curr++)
   15bf6:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
   15bfc:	e9 a0 00 00 00       	jmp    15ca1 <cluster_alloc_free+0xd1>
    {
        cluster_t free = cluster_get_next(fat, curr);
   15c01:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   15c05:	83 ec 08             	sub    $0x8,%esp
   15c08:	50                   	push   %eax
   15c09:	ff 75 08             	pushl  0x8(%ebp)
   15c0c:	e8 96 08 00 00       	call   164a7 <cluster_get_next>
   15c11:	83 c4 10             	add    $0x10,%esp
   15c14:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
        if(free == CLUSTER_FAT_FREE)
   15c18:	66 83 7d ea 00       	cmpw   $0x0,-0x16(%ebp)
   15c1d:	75 77                	jne    15c96 <cluster_alloc_free+0xc6>
        {
            if(!clust_is_valid(start))
   15c1f:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   15c23:	83 ec 0c             	sub    $0xc,%esp
   15c26:	50                   	push   %eax
   15c27:	e8 bb 07 00 00       	call   163e7 <clust_is_valid>
   15c2c:	83 c4 10             	add    $0x10,%esp
   15c2f:	85 c0                	test   %eax,%eax
   15c31:	75 08                	jne    15c3b <cluster_alloc_free+0x6b>
            {
                start = curr;
   15c33:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   15c37:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
            }
            if(clust_is_valid(pre))
   15c3b:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   15c3f:	83 ec 0c             	sub    $0xc,%esp
   15c42:	50                   	push   %eax
   15c43:	e8 9f 07 00 00       	call   163e7 <clust_is_valid>
   15c48:	83 c4 10             	add    $0x10,%esp
   15c4b:	85 c0                	test   %eax,%eax
   15c4d:	74 3b                	je     15c8a <cluster_alloc_free+0xba>
            {
                int err = cluster_set_next(fat, pre, curr);
   15c4f:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
   15c53:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   15c57:	83 ec 04             	sub    $0x4,%esp
   15c5a:	52                   	push   %edx
   15c5b:	50                   	push   %eax
   15c5c:	ff 75 08             	pushl  0x8(%ebp)
   15c5f:	e8 b8 11 00 00       	call   16e1c <cluster_set_next>
   15c64:	83 c4 10             	add    $0x10,%esp
   15c67:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if(err < 0)
   15c6a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   15c6e:	79 1a                	jns    15c8a <cluster_alloc_free+0xba>
                {
                    cluster_free_chain(fat, start);
   15c70:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   15c74:	83 ec 08             	sub    $0x8,%esp
   15c77:	50                   	push   %eax
   15c78:	ff 75 08             	pushl  0x8(%ebp)
   15c7b:	e8 b4 12 00 00       	call   16f34 <cluster_free_chain>
   15c80:	83 c4 10             	add    $0x10,%esp
                    return FAT_CLUSTER_INVALID;
   15c83:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   15c88:	eb 6f                	jmp    15cf9 <cluster_alloc_free+0x129>
                }
            }
            pre = curr;
   15c8a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   15c8e:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
            cnt --;
   15c92:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    for(curr = 2; cnt && (curr < c_cluster); curr++)
   15c96:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   15c9a:	83 c0 01             	add    $0x1,%eax
   15c9d:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
   15ca1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15ca5:	74 0d                	je     15cb4 <cluster_alloc_free+0xe4>
   15ca7:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   15cab:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   15cae:	0f 8f 4d ff ff ff    	jg     15c01 <cluster_alloc_free+0x31>
        }
        
    }
    if(cnt == 0)
   15cb4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   15cb8:	75 27                	jne    15ce1 <cluster_alloc_free+0x111>
    {
        int err = cluster_set_next(fat, pre, FAT_CLUSTER_INVALID);
   15cba:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
   15cbe:	83 ec 04             	sub    $0x4,%esp
   15cc1:	68 f8 ff 00 00       	push   $0xfff8
   15cc6:	50                   	push   %eax
   15cc7:	ff 75 08             	pushl  0x8(%ebp)
   15cca:	e8 4d 11 00 00       	call   16e1c <cluster_set_next>
   15ccf:	83 c4 10             	add    $0x10,%esp
   15cd2:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if (err == 0) {
   15cd5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15cd9:	75 06                	jne    15ce1 <cluster_alloc_free+0x111>
            return start;
   15cdb:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   15cdf:	eb 18                	jmp    15cf9 <cluster_alloc_free+0x129>
        }
    }
    cluster_free_chain(fat, start);
   15ce1:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
   15ce5:	83 ec 08             	sub    $0x8,%esp
   15ce8:	50                   	push   %eax
   15ce9:	ff 75 08             	pushl  0x8(%ebp)
   15cec:	e8 43 12 00 00       	call   16f34 <cluster_free_chain>
   15cf1:	83 c4 10             	add    $0x10,%esp
    return FAT_CLUSTER_INVALID;
   15cf4:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax

}
   15cf9:	c9                   	leave  
   15cfa:	c3                   	ret    

00015cfb <expand_filesz>:
int expand_filesz(file_t* file, int  inc_bytes)
{
   15cfb:	55                   	push   %ebp
   15cfc:	89 e5                	mov    %esp,%ebp
   15cfe:	53                   	push   %ebx
   15cff:	83 ec 24             	sub    $0x24,%esp
        fat_t * fat = (fat_t *)file->fs->data;
   15d02:	8b 45 08             	mov    0x8(%ebp),%eax
   15d05:	8b 40 44             	mov    0x44(%eax),%eax
   15d08:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   15d0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    int cluster_cnt;
    if ((file->size == 0) || (file->size % fat->cluster_byte_size == 0)) {
   15d11:	8b 45 08             	mov    0x8(%ebp),%eax
   15d14:	8b 40 24             	mov    0x24(%eax),%eax
   15d17:	85 c0                	test   %eax,%eax
   15d19:	74 19                	je     15d34 <expand_filesz+0x39>
   15d1b:	8b 45 08             	mov    0x8(%ebp),%eax
   15d1e:	8b 40 24             	mov    0x24(%eax),%eax
   15d21:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15d24:	8b 4a 20             	mov    0x20(%edx),%ecx
   15d27:	ba 00 00 00 00       	mov    $0x0,%edx
   15d2c:	f7 f1                	div    %ecx
   15d2e:	89 d0                	mov    %edx,%eax
   15d30:	85 c0                	test   %eax,%eax
   15d32:	75 29                	jne    15d5d <expand_filesz+0x62>
        cluster_cnt = up2(inc_bytes, fat->cluster_byte_size) / fat->cluster_byte_size; 
   15d34:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d37:	8b 50 20             	mov    0x20(%eax),%edx
   15d3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d3d:	52                   	push   %edx
   15d3e:	50                   	push   %eax
   15d3f:	e8 08 fe ff ff       	call   15b4c <up2>
   15d44:	83 c4 08             	add    $0x8,%esp
   15d47:	89 c1                	mov    %eax,%ecx
   15d49:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d4c:	8b 58 20             	mov    0x20(%eax),%ebx
   15d4f:	89 c8                	mov    %ecx,%eax
   15d51:	ba 00 00 00 00       	mov    $0x0,%edx
   15d56:	f7 f3                	div    %ebx
   15d58:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15d5b:	eb 6b                	jmp    15dc8 <expand_filesz+0xcd>
    } else {
        int cfree = fat->cluster_byte_size - (file->size % fat->cluster_byte_size);
   15d5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d60:	8b 48 20             	mov    0x20(%eax),%ecx
   15d63:	8b 45 08             	mov    0x8(%ebp),%eax
   15d66:	8b 40 24             	mov    0x24(%eax),%eax
   15d69:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15d6c:	8b 5a 20             	mov    0x20(%edx),%ebx
   15d6f:	ba 00 00 00 00       	mov    $0x0,%edx
   15d74:	f7 f3                	div    %ebx
   15d76:	89 d0                	mov    %edx,%eax
   15d78:	29 c1                	sub    %eax,%ecx
   15d7a:	89 c8                	mov    %ecx,%eax
   15d7c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (cfree > inc_bytes) {
   15d7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d82:	3b 45 0c             	cmp    0xc(%ebp),%eax
   15d85:	7e 0a                	jle    15d91 <expand_filesz+0x96>
            return 0;
   15d87:	b8 00 00 00 00       	mov    $0x0,%eax
   15d8c:	e9 da 00 00 00       	jmp    15e6b <expand_filesz+0x170>
        }

        cluster_cnt = up2(inc_bytes - cfree, fat->cluster_byte_size) / fat->cluster_byte_size;
   15d91:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d94:	8b 40 20             	mov    0x20(%eax),%eax
   15d97:	8b 55 0c             	mov    0xc(%ebp),%edx
   15d9a:	2b 55 ec             	sub    -0x14(%ebp),%edx
   15d9d:	50                   	push   %eax
   15d9e:	52                   	push   %edx
   15d9f:	e8 a8 fd ff ff       	call   15b4c <up2>
   15da4:	83 c4 08             	add    $0x8,%esp
   15da7:	89 c1                	mov    %eax,%ecx
   15da9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15dac:	8b 58 20             	mov    0x20(%eax),%ebx
   15daf:	89 c8                	mov    %ecx,%eax
   15db1:	ba 00 00 00 00       	mov    $0x0,%edx
   15db6:	f7 f3                	div    %ebx
   15db8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (cluster_cnt == 0) {
   15dbb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15dbf:	75 07                	jne    15dc8 <expand_filesz+0xcd>
            cluster_cnt = 1;
   15dc1:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
        }
    }
    cluster_t start = cluster_alloc_free(fat, cluster_cnt);
   15dc8:	83 ec 08             	sub    $0x8,%esp
   15dcb:	ff 75 f4             	pushl  -0xc(%ebp)
   15dce:	ff 75 f0             	pushl  -0x10(%ebp)
   15dd1:	e8 fa fd ff ff       	call   15bd0 <cluster_alloc_free>
   15dd6:	83 c4 10             	add    $0x10,%esp
   15dd9:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
    if (!clust_is_valid(start)) {
   15ddd:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
   15de1:	83 ec 0c             	sub    $0xc,%esp
   15de4:	50                   	push   %eax
   15de5:	e8 fd 05 00 00       	call   163e7 <clust_is_valid>
   15dea:	83 c4 10             	add    $0x10,%esp
   15ded:	85 c0                	test   %eax,%eax
   15def:	75 17                	jne    15e08 <expand_filesz+0x10d>
        log_printf("no cluster for file write");
   15df1:	83 ec 0c             	sub    $0xc,%esp
   15df4:	68 90 9e 01 00       	push   $0x19e90
   15df9:	e8 4e 31 00 00       	call   18f4c <log_printf>
   15dfe:	83 c4 10             	add    $0x10,%esp
        return -1;
   15e01:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15e06:	eb 63                	jmp    15e6b <expand_filesz+0x170>
    }
    if (!clust_is_valid(file->sblk)) {
   15e08:	8b 45 08             	mov    0x8(%ebp),%eax
   15e0b:	8b 40 30             	mov    0x30(%eax),%eax
   15e0e:	0f b7 c0             	movzwl %ax,%eax
   15e11:	83 ec 0c             	sub    $0xc,%esp
   15e14:	50                   	push   %eax
   15e15:	e8 cd 05 00 00       	call   163e7 <clust_is_valid>
   15e1a:	83 c4 10             	add    $0x10,%esp
   15e1d:	85 c0                	test   %eax,%eax
   15e1f:	75 18                	jne    15e39 <expand_filesz+0x13e>
        file->cblk = file->sblk = start;
   15e21:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
   15e25:	8b 45 08             	mov    0x8(%ebp),%eax
   15e28:	89 50 30             	mov    %edx,0x30(%eax)
   15e2b:	8b 45 08             	mov    0x8(%ebp),%eax
   15e2e:	8b 50 30             	mov    0x30(%eax),%edx
   15e31:	8b 45 08             	mov    0x8(%ebp),%eax
   15e34:	89 50 34             	mov    %edx,0x34(%eax)
   15e37:	eb 2d                	jmp    15e66 <expand_filesz+0x16b>
    } else {
        int err = cluster_set_next(fat, file->cblk, start);
   15e39:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
   15e3d:	8b 45 08             	mov    0x8(%ebp),%eax
   15e40:	8b 40 34             	mov    0x34(%eax),%eax
   15e43:	0f b7 c0             	movzwl %ax,%eax
   15e46:	83 ec 04             	sub    $0x4,%esp
   15e49:	52                   	push   %edx
   15e4a:	50                   	push   %eax
   15e4b:	ff 75 f0             	pushl  -0x10(%ebp)
   15e4e:	e8 c9 0f 00 00       	call   16e1c <cluster_set_next>
   15e53:	83 c4 10             	add    $0x10,%esp
   15e56:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0) {
   15e59:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   15e5d:	79 07                	jns    15e66 <expand_filesz+0x16b>
            return -1;
   15e5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15e64:	eb 05                	jmp    15e6b <expand_filesz+0x170>
        }
    }

    return 0;
   15e66:	b8 00 00 00 00       	mov    $0x0,%eax
}
   15e6b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15e6e:	c9                   	leave  
   15e6f:	c3                   	ret    

00015e70 <fatfs_mount>:

int fatfs_mount (struct _fs_t * fs, int dev_major, int dev_minor) {
   15e70:	55                   	push   %ebp
   15e71:	89 e5                	mov    %esp,%ebp
   15e73:	83 ec 18             	sub    $0x18,%esp
    int dev_id = dev_open(dev_major, dev_minor, (void*)0);
   15e76:	83 ec 04             	sub    $0x4,%esp
   15e79:	6a 00                	push   $0x0
   15e7b:	ff 75 10             	pushl  0x10(%ebp)
   15e7e:	ff 75 0c             	pushl  0xc(%ebp)
   15e81:	e8 53 e1 ff ff       	call   13fd9 <dev_open>
   15e86:	83 c4 10             	add    $0x10,%esp
   15e89:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (dev_id < 0) {
   15e8c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   15e90:	79 20                	jns    15eb2 <fatfs_mount+0x42>
        log_printf("open disk failed. major: %x, minor: %x", dev_major, dev_minor);
   15e92:	83 ec 04             	sub    $0x4,%esp
   15e95:	ff 75 10             	pushl  0x10(%ebp)
   15e98:	ff 75 0c             	pushl  0xc(%ebp)
   15e9b:	68 ac 9e 01 00       	push   $0x19eac
   15ea0:	e8 a7 30 00 00       	call   18f4c <log_printf>
   15ea5:	83 c4 10             	add    $0x10,%esp
        return -1;
   15ea8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   15ead:	e9 fe 01 00 00       	jmp    160b0 <fatfs_mount+0x240>
    }
    dbr_t* dbr = (dbr_t*)memory_alloc_page();
   15eb2:	e8 cf aa ff ff       	call   10986 <memory_alloc_page>
   15eb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (!dbr) {
   15eba:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   15ebe:	75 15                	jne    15ed5 <fatfs_mount+0x65>
        log_printf("mount fat failed: can't alloc buf.");
   15ec0:	83 ec 0c             	sub    $0xc,%esp
   15ec3:	68 d4 9e 01 00       	push   $0x19ed4
   15ec8:	e8 7f 30 00 00       	call   18f4c <log_printf>
   15ecd:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   15ed0:	e9 b3 01 00 00       	jmp    16088 <fatfs_mount+0x218>
    }
    int cnt = dev_read(dev_id, 0, (char*)dbr, 1);
   15ed5:	6a 01                	push   $0x1
   15ed7:	ff 75 f0             	pushl  -0x10(%ebp)
   15eda:	6a 00                	push   $0x0
   15edc:	ff 75 f4             	pushl  -0xc(%ebp)
   15edf:	e8 3f e2 ff ff       	call   14123 <dev_read>
   15ee4:	83 c4 10             	add    $0x10,%esp
   15ee7:	89 45 ec             	mov    %eax,-0x14(%ebp)
     if (cnt < 1) {
   15eea:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   15eee:	7f 15                	jg     15f05 <fatfs_mount+0x95>
        log_printf("read dbr failed.");
   15ef0:	83 ec 0c             	sub    $0xc,%esp
   15ef3:	68 f7 9e 01 00       	push   $0x19ef7
   15ef8:	e8 4f 30 00 00       	call   18f4c <log_printf>
   15efd:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   15f00:	e9 83 01 00 00       	jmp    16088 <fatfs_mount+0x218>
    }
    fat_t* fat = &fs->fat_data;
   15f05:	8b 45 08             	mov    0x8(%ebp),%eax
   15f08:	05 9c 00 00 00       	add    $0x9c,%eax
   15f0d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    fat->fat_buffer = (uint8_t *)dbr;
   15f10:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f13:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15f16:	89 50 28             	mov    %edx,0x28(%eax)
    fat->curr_sector = -1;
   15f19:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f1c:	c7 40 24 ff ff ff ff 	movl   $0xffffffff,0x24(%eax)
    fat->bytes_per_sec = dbr->BPB_BytsPerSec;
   15f23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f26:	0f b7 40 0b          	movzwl 0xb(%eax),%eax
   15f2a:	0f b7 d0             	movzwl %ax,%edx
   15f2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f30:	89 50 0c             	mov    %edx,0xc(%eax)
    fat->tbl_start = dbr->BPB_RsvdSecCnt;
   15f33:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f36:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
   15f3a:	0f b7 d0             	movzwl %ax,%edx
   15f3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f40:	89 10                	mov    %edx,(%eax)
    fat->tbl_sectors = dbr->BPB_FATSz16;
   15f42:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f45:	0f b7 40 16          	movzwl 0x16(%eax),%eax
   15f49:	0f b7 d0             	movzwl %ax,%edx
   15f4c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f4f:	89 50 08             	mov    %edx,0x8(%eax)
    fat->tbl_cnt = dbr->BPB_NumFATs;
   15f52:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f55:	0f b6 40 10          	movzbl 0x10(%eax),%eax
   15f59:	0f b6 d0             	movzbl %al,%edx
   15f5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f5f:	89 50 04             	mov    %edx,0x4(%eax)
    fat->root_ent_cnt = dbr->BPB_RootEntCnt;
   15f62:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f65:	0f b7 40 11          	movzwl 0x11(%eax),%eax
   15f69:	0f b7 d0             	movzwl %ax,%edx
   15f6c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f6f:	89 50 14             	mov    %edx,0x14(%eax)
    fat->sec_per_cluster = dbr->BPB_SecPerClus;
   15f72:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f75:	0f b6 40 0d          	movzbl 0xd(%eax),%eax
   15f79:	0f b6 d0             	movzbl %al,%edx
   15f7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f7f:	89 50 10             	mov    %edx,0x10(%eax)
    fat->cluster_byte_size = fat->sec_per_cluster * dbr->BPB_BytsPerSec;
   15f82:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f85:	8b 50 10             	mov    0x10(%eax),%edx
   15f88:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f8b:	0f b7 40 0b          	movzwl 0xb(%eax),%eax
   15f8f:	0f b7 c0             	movzwl %ax,%eax
   15f92:	0f af d0             	imul   %eax,%edx
   15f95:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f98:	89 50 20             	mov    %edx,0x20(%eax)
	fat->root_start = fat->tbl_start + fat->tbl_sectors * fat->tbl_cnt;
   15f9b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15f9e:	8b 10                	mov    (%eax),%edx
   15fa0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fa3:	8b 48 08             	mov    0x8(%eax),%ecx
   15fa6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fa9:	8b 40 04             	mov    0x4(%eax),%eax
   15fac:	0f af c1             	imul   %ecx,%eax
   15faf:	01 c2                	add    %eax,%edx
   15fb1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fb4:	89 50 18             	mov    %edx,0x18(%eax)
    fat->data_start = fat->root_start + fat->root_ent_cnt * 32 / SECTOR_SIZE;
   15fb7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fba:	8b 50 18             	mov    0x18(%eax),%edx
   15fbd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fc0:	8b 40 14             	mov    0x14(%eax),%eax
   15fc3:	c1 e0 05             	shl    $0x5,%eax
   15fc6:	c1 e8 09             	shr    $0x9,%eax
   15fc9:	01 c2                	add    %eax,%edx
   15fcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fce:	89 50 1c             	mov    %edx,0x1c(%eax)
    fat->fs = fs;
   15fd1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fd4:	8b 55 08             	mov    0x8(%ebp),%edx
   15fd7:	89 50 2c             	mov    %edx,0x2c(%eax)
    mutex_init(&fat->mutex);
   15fda:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fdd:	83 c0 30             	add    $0x30,%eax
   15fe0:	83 ec 0c             	sub    $0xc,%esp
   15fe3:	50                   	push   %eax
   15fe4:	e8 6d 22 00 00       	call   18256 <mutex_init>
   15fe9:	83 c4 10             	add    $0x10,%esp
    fat->fs->mutex = &fat->mutex;
   15fec:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15fef:	8b 40 2c             	mov    0x2c(%eax),%eax
   15ff2:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15ff5:	83 c2 30             	add    $0x30,%edx
   15ff8:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
    if (fat->tbl_cnt != 2) {
   15ffe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16001:	8b 40 04             	mov    0x4(%eax),%eax
   16004:	83 f8 02             	cmp    $0x2,%eax
   16007:	74 18                	je     16021 <fatfs_mount+0x1b1>
        log_printf("fat table num error, major: %x, minor: %x", dev_major, dev_minor);
   16009:	83 ec 04             	sub    $0x4,%esp
   1600c:	ff 75 10             	pushl  0x10(%ebp)
   1600f:	ff 75 0c             	pushl  0xc(%ebp)
   16012:	68 08 9f 01 00       	push   $0x19f08
   16017:	e8 30 2f 00 00       	call   18f4c <log_printf>
   1601c:	83 c4 10             	add    $0x10,%esp
		goto mount_failed;
   1601f:	eb 67                	jmp    16088 <fatfs_mount+0x218>
	}

    if (kernel_memcmp(dbr->BS_FileSysType, "FAT16", 5) != 0) {
   16021:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16024:	83 c0 36             	add    $0x36,%eax
   16027:	83 ec 04             	sub    $0x4,%esp
   1602a:	6a 05                	push   $0x5
   1602c:	68 32 9f 01 00       	push   $0x19f32
   16031:	50                   	push   %eax
   16032:	e8 ac 29 00 00       	call   189e3 <kernel_memcmp>
   16037:	83 c4 10             	add    $0x10,%esp
   1603a:	85 c0                	test   %eax,%eax
   1603c:	74 18                	je     16056 <fatfs_mount+0x1e6>
        log_printf("not a fat16 file system, major: %x, minor: %x", dev_major, dev_minor);
   1603e:	83 ec 04             	sub    $0x4,%esp
   16041:	ff 75 10             	pushl  0x10(%ebp)
   16044:	ff 75 0c             	pushl  0xc(%ebp)
   16047:	68 38 9f 01 00       	push   $0x19f38
   1604c:	e8 fb 2e 00 00       	call   18f4c <log_printf>
   16051:	83 c4 10             	add    $0x10,%esp
        goto mount_failed;
   16054:	eb 32                	jmp    16088 <fatfs_mount+0x218>
    }
    fs->type = FS_FAT16;
   16056:	8b 45 08             	mov    0x8(%ebp),%eax
   16059:	c7 80 80 00 00 00 01 	movl   $0x1,0x80(%eax)
   16060:	00 00 00 
    fs->data = &fs->fat_data;  
   16063:	8b 45 08             	mov    0x8(%ebp),%eax
   16066:	8d 90 9c 00 00 00    	lea    0x9c(%eax),%edx
   1606c:	8b 45 08             	mov    0x8(%ebp),%eax
   1606f:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
    fs->dev_id = dev_id;
   16075:	8b 45 08             	mov    0x8(%ebp),%eax
   16078:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1607b:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
    return 0;
   16081:	b8 00 00 00 00       	mov    $0x0,%eax
   16086:	eb 28                	jmp    160b0 <fatfs_mount+0x240>
mount_failed:
    if (dbr) {
   16088:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1608c:	74 0f                	je     1609d <fatfs_mount+0x22d>
        memory_free_page((uint32_t)dbr);
   1608e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16091:	83 ec 0c             	sub    $0xc,%esp
   16094:	50                   	push   %eax
   16095:	e8 06 a9 ff ff       	call   109a0 <memory_free_page>
   1609a:	83 c4 10             	add    $0x10,%esp
    }
    dev_close(dev_id);
   1609d:	83 ec 0c             	sub    $0xc,%esp
   160a0:	ff 75 f4             	pushl  -0xc(%ebp)
   160a3:	e8 5f e1 ff ff       	call   14207 <dev_close>
   160a8:	83 c4 10             	add    $0x10,%esp
    return -1;
   160ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   160b0:	c9                   	leave  
   160b1:	c3                   	ret    

000160b2 <fatfs_unmount>:


void fatfs_unmount (struct _fs_t * fs) {
   160b2:	55                   	push   %ebp
   160b3:	89 e5                	mov    %esp,%ebp
   160b5:	83 ec 18             	sub    $0x18,%esp
    fat_t* fat = fs->data;
   160b8:	8b 45 08             	mov    0x8(%ebp),%eax
   160bb:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   160c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dev_close(fs->dev_id);
   160c4:	8b 45 08             	mov    0x8(%ebp),%eax
   160c7:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   160cd:	83 ec 0c             	sub    $0xc,%esp
   160d0:	50                   	push   %eax
   160d1:	e8 31 e1 ff ff       	call   14207 <dev_close>
   160d6:	83 c4 10             	add    $0x10,%esp
    memory_free_page((uint32_t)fat->fat_buffer);
   160d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   160dc:	8b 40 28             	mov    0x28(%eax),%eax
   160df:	83 ec 0c             	sub    $0xc,%esp
   160e2:	50                   	push   %eax
   160e3:	e8 b8 a8 ff ff       	call   109a0 <memory_free_page>
   160e8:	83 c4 10             	add    $0x10,%esp
}
   160eb:	90                   	nop
   160ec:	c9                   	leave  
   160ed:	c3                   	ret    

000160ee <read_from_diritem>:
void read_from_diritem(fat_t* fat, file_t* file, diritem_t* item, int index)
{
   160ee:	55                   	push   %ebp
   160ef:	89 e5                	mov    %esp,%ebp
    file->type = get_item_type(item);
   160f1:	ff 75 10             	pushl  0x10(%ebp)
   160f4:	e8 6a fa ff ff       	call   15b63 <get_item_type>
   160f9:	83 c4 04             	add    $0x4,%esp
   160fc:	89 c2                	mov    %eax,%edx
   160fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   16101:	89 50 20             	mov    %edx,0x20(%eax)
    file->size = (int)item->DIR_FileSize;
   16104:	8b 45 10             	mov    0x10(%ebp),%eax
   16107:	8b 50 1c             	mov    0x1c(%eax),%edx
   1610a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1610d:	89 50 24             	mov    %edx,0x24(%eax)
    file->pos = 0;
   16110:	8b 45 0c             	mov    0xc(%ebp),%eax
   16113:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
    file->sblk = (item->DIR_FstClusHI << 16) | item->DIR_FstClusL0;
   1611a:	8b 45 10             	mov    0x10(%ebp),%eax
   1611d:	0f b7 40 14          	movzwl 0x14(%eax),%eax
   16121:	0f b7 c0             	movzwl %ax,%eax
   16124:	c1 e0 10             	shl    $0x10,%eax
   16127:	89 c2                	mov    %eax,%edx
   16129:	8b 45 10             	mov    0x10(%ebp),%eax
   1612c:	0f b7 40 1a          	movzwl 0x1a(%eax),%eax
   16130:	0f b7 c0             	movzwl %ax,%eax
   16133:	09 d0                	or     %edx,%eax
   16135:	89 c2                	mov    %eax,%edx
   16137:	8b 45 0c             	mov    0xc(%ebp),%eax
   1613a:	89 50 30             	mov    %edx,0x30(%eax)
    file->cblk = file->sblk;
   1613d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16140:	8b 50 30             	mov    0x30(%eax),%edx
   16143:	8b 45 0c             	mov    0xc(%ebp),%eax
   16146:	89 50 34             	mov    %edx,0x34(%eax)
    file->p_index = index;
   16149:	8b 45 0c             	mov    0xc(%ebp),%eax
   1614c:	8b 55 14             	mov    0x14(%ebp),%edx
   1614f:	89 50 38             	mov    %edx,0x38(%eax)
}
   16152:	90                   	nop
   16153:	c9                   	leave  
   16154:	c3                   	ret    

00016155 <to_snf>:
void  to_snf(char* path, char* buf)
{
   16155:	55                   	push   %ebp
   16156:	89 e5                	mov    %esp,%ebp
   16158:	83 ec 18             	sub    $0x18,%esp
    kernel_memset(buf, ' ', 11);
   1615b:	83 ec 04             	sub    $0x4,%esp
   1615e:	6a 0b                	push   $0xb
   16160:	6a 20                	push   $0x20
   16162:	ff 75 0c             	pushl  0xc(%ebp)
   16165:	e8 38 28 00 00       	call   189a2 <kernel_memset>
   1616a:	83 c4 10             	add    $0x10,%esp
    int index = 0;
   1616d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(*path && index < 11)
   16174:	eb 57                	jmp    161cd <to_snf+0x78>
    {
        char c = *path;
   16176:	8b 45 08             	mov    0x8(%ebp),%eax
   16179:	0f b6 00             	movzbl (%eax),%eax
   1617c:	88 45 f3             	mov    %al,-0xd(%ebp)
        switch (c)
   1617f:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
   16183:	83 f8 2e             	cmp    $0x2e,%eax
   16186:	75 0d                	jne    16195 <to_snf+0x40>
        {
        case '.':
            index = 8;
   16188:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
            path++;
   1618f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
            break;
   16193:	eb 38                	jmp    161cd <to_snf+0x78>
        
        default:
            if(c >='a' && c <= 'z')
   16195:	80 7d f3 60          	cmpb   $0x60,-0xd(%ebp)
   16199:	7e 1b                	jle    161b6 <to_snf+0x61>
   1619b:	80 7d f3 7a          	cmpb   $0x7a,-0xd(%ebp)
   1619f:	7f 15                	jg     161b6 <to_snf+0x61>
                buf[index] = c - 'a' + 'A';
   161a1:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   161a5:	8d 48 e0             	lea    -0x20(%eax),%ecx
   161a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   161ab:	8b 45 0c             	mov    0xc(%ebp),%eax
   161ae:	01 d0                	add    %edx,%eax
   161b0:	89 ca                	mov    %ecx,%edx
   161b2:	88 10                	mov    %dl,(%eax)
   161b4:	eb 0e                	jmp    161c4 <to_snf+0x6f>
            else 
                buf[index] = c;
   161b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   161b9:	8b 45 0c             	mov    0xc(%ebp),%eax
   161bc:	01 c2                	add    %eax,%edx
   161be:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   161c2:	88 02                	mov    %al,(%edx)
            path++;
   161c4:	83 45 08 01          	addl   $0x1,0x8(%ebp)
            index++;
   161c8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
            break;
   161cc:	90                   	nop
    while(*path && index < 11)
   161cd:	8b 45 08             	mov    0x8(%ebp),%eax
   161d0:	0f b6 00             	movzbl (%eax),%eax
   161d3:	84 c0                	test   %al,%al
   161d5:	74 06                	je     161dd <to_snf+0x88>
   161d7:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
   161db:	7e 99                	jle    16176 <to_snf+0x21>
        }
    }
}
   161dd:	90                   	nop
   161de:	c9                   	leave  
   161df:	c3                   	ret    

000161e0 <item_name_match>:
int item_name_match(diritem_t* item, char* path)
{
   161e0:	55                   	push   %ebp
   161e1:	89 e5                	mov    %esp,%ebp
   161e3:	83 ec 18             	sub    $0x18,%esp
    char buf[11];
    to_snf(path, buf);
   161e6:	83 ec 08             	sub    $0x8,%esp
   161e9:	8d 45 ed             	lea    -0x13(%ebp),%eax
   161ec:	50                   	push   %eax
   161ed:	ff 75 0c             	pushl  0xc(%ebp)
   161f0:	e8 60 ff ff ff       	call   16155 <to_snf>
   161f5:	83 c4 10             	add    $0x10,%esp
    return (kernel_memcmp(item->DIR_Name, buf, 11) == 0);
   161f8:	8b 45 08             	mov    0x8(%ebp),%eax
   161fb:	83 ec 04             	sub    $0x4,%esp
   161fe:	6a 0b                	push   $0xb
   16200:	8d 55 ed             	lea    -0x13(%ebp),%edx
   16203:	52                   	push   %edx
   16204:	50                   	push   %eax
   16205:	e8 d9 27 00 00       	call   189e3 <kernel_memcmp>
   1620a:	83 c4 10             	add    $0x10,%esp
   1620d:	85 c0                	test   %eax,%eax
   1620f:	0f 94 c0             	sete   %al
   16212:	0f b6 c0             	movzbl %al,%eax
}
   16215:	c9                   	leave  
   16216:	c3                   	ret    

00016217 <diritem_init>:
void diritem_init(diritem_t* item, int attr, char* path)
{
   16217:	55                   	push   %ebp
   16218:	89 e5                	mov    %esp,%ebp
   1621a:	83 ec 08             	sub    $0x8,%esp
    to_snf(path, item->DIR_Name);
   1621d:	8b 45 08             	mov    0x8(%ebp),%eax
   16220:	83 ec 08             	sub    $0x8,%esp
   16223:	50                   	push   %eax
   16224:	ff 75 10             	pushl  0x10(%ebp)
   16227:	e8 29 ff ff ff       	call   16155 <to_snf>
   1622c:	83 c4 10             	add    $0x10,%esp
    item->DIR_Attr = attr;
   1622f:	8b 45 0c             	mov    0xc(%ebp),%eax
   16232:	89 c2                	mov    %eax,%edx
   16234:	8b 45 08             	mov    0x8(%ebp),%eax
   16237:	88 50 0b             	mov    %dl,0xb(%eax)
    item->DIR_FileSize = 0;
   1623a:	8b 45 08             	mov    0x8(%ebp),%eax
   1623d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    item->DIR_CrtDate = 0;
   16244:	8b 45 08             	mov    0x8(%ebp),%eax
   16247:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
    item->DIR_NTRes = 0;
   1624d:	8b 45 08             	mov    0x8(%ebp),%eax
   16250:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
    item ->DIR_FstClusHI = (uint16_t)(FAT_CLUSTER_INVALID >> 16);
   16254:	8b 45 08             	mov    0x8(%ebp),%eax
   16257:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
    item -> DIR_FstClusL0 = (uint16_t)(FAT_CLUSTER_INVALID & 0xFFFF);
   1625d:	8b 45 08             	mov    0x8(%ebp),%eax
   16260:	66 c7 40 1a f8 ff    	movw   $0xfff8,0x1a(%eax)
}
   16266:	90                   	nop
   16267:	c9                   	leave  
   16268:	c3                   	ret    

00016269 <fatfs_open>:
int fatfs_open (struct _fs_t * fs, const char * path, file_t * file) {
   16269:	55                   	push   %ebp
   1626a:	89 e5                	mov    %esp,%ebp
   1626c:	83 ec 48             	sub    $0x48,%esp
    fat_t * fat = (fat_t *)fs->data;
   1626f:	8b 45 08             	mov    0x8(%ebp),%eax
   16272:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   16278:	89 45 e8             	mov    %eax,-0x18(%ebp)
    diritem_t * file_item = (diritem_t *)0;
   1627b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    int p_index = -1;
   16282:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%ebp)

    // 遍历根目录的数据区，找到已经存在的匹配项
    for (int i = 0; i < fat->root_ent_cnt; i++) {
   16289:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   16290:	eb 6f                	jmp    16301 <fatfs_open+0x98>
        diritem_t * item = read_dir_ent(fat, i);
   16292:	83 ec 08             	sub    $0x8,%esp
   16295:	ff 75 ec             	pushl  -0x14(%ebp)
   16298:	ff 75 e8             	pushl  -0x18(%ebp)
   1629b:	e8 5c 09 00 00       	call   16bfc <read_dir_ent>
   162a0:	83 c4 10             	add    $0x10,%esp
   162a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (item == (diritem_t *)0) {
   162a6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   162aa:	75 0a                	jne    162b6 <fatfs_open+0x4d>
            return -1;
   162ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   162b1:	e9 2f 01 00 00       	jmp    163e5 <fatfs_open+0x17c>
        }

         // 结束项，不需要再扫描了，同时index也不能往前走
        if (item->DIR_Name[0] == DIRITEM_NAME_END) {
   162b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   162b9:	0f b6 00             	movzbl (%eax),%eax
   162bc:	84 c0                	test   %al,%al
   162be:	75 08                	jne    162c8 <fatfs_open+0x5f>
            p_index = i;
   162c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   162c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
            break;
   162c6:	eb 46                	jmp    1630e <fatfs_open+0xa5>
        }

        // 只显示普通文件和目录，其它的不显示
        if (item->DIR_Name[0] == DIRITEM_NAME_FREE) {
   162c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   162cb:	0f b6 00             	movzbl (%eax),%eax
   162ce:	3c e5                	cmp    $0xe5,%al
   162d0:	75 08                	jne    162da <fatfs_open+0x71>
            p_index = i;
   162d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   162d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
            continue;
   162d8:	eb 23                	jmp    162fd <fatfs_open+0x94>
        }

        // 找到要打开的目录
        if (item_name_match(item, path)) {
   162da:	83 ec 08             	sub    $0x8,%esp
   162dd:	ff 75 0c             	pushl  0xc(%ebp)
   162e0:	ff 75 e4             	pushl  -0x1c(%ebp)
   162e3:	e8 f8 fe ff ff       	call   161e0 <item_name_match>
   162e8:	83 c4 10             	add    $0x10,%esp
   162eb:	85 c0                	test   %eax,%eax
   162ed:	74 0e                	je     162fd <fatfs_open+0x94>
            file_item = item;
   162ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   162f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
            p_index = i;
   162f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   162f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
            break;
   162fb:	eb 11                	jmp    1630e <fatfs_open+0xa5>
    for (int i = 0; i < fat->root_ent_cnt; i++) {
   162fd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   16301:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16304:	8b 50 14             	mov    0x14(%eax),%edx
   16307:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1630a:	39 c2                	cmp    %eax,%edx
   1630c:	77 84                	ja     16292 <fatfs_open+0x29>
        } 
    }

    if (file_item) {
   1630e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   16312:	74 62                	je     16376 <fatfs_open+0x10d>
        read_from_diritem(fat, file, file_item, p_index);
   16314:	ff 75 f0             	pushl  -0x10(%ebp)
   16317:	ff 75 f4             	pushl  -0xc(%ebp)
   1631a:	ff 75 10             	pushl  0x10(%ebp)
   1631d:	ff 75 e8             	pushl  -0x18(%ebp)
   16320:	e8 c9 fd ff ff       	call   160ee <read_from_diritem>
   16325:	83 c4 10             	add    $0x10,%esp
        if (file->mode & O_TRUNC) {
   16328:	8b 45 10             	mov    0x10(%ebp),%eax
   1632b:	8b 40 40             	mov    0x40(%eax),%eax
   1632e:	25 00 04 00 00       	and    $0x400,%eax
   16333:	85 c0                	test   %eax,%eax
   16335:	74 38                	je     1636f <fatfs_open+0x106>
            cluster_free_chain(fat, file->sblk);
   16337:	8b 45 10             	mov    0x10(%ebp),%eax
   1633a:	8b 40 30             	mov    0x30(%eax),%eax
   1633d:	0f b7 c0             	movzwl %ax,%eax
   16340:	83 ec 08             	sub    $0x8,%esp
   16343:	50                   	push   %eax
   16344:	ff 75 e8             	pushl  -0x18(%ebp)
   16347:	e8 e8 0b 00 00       	call   16f34 <cluster_free_chain>
   1634c:	83 c4 10             	add    $0x10,%esp
            file->cblk = file->sblk = FAT_CLUSTER_INVALID;
   1634f:	8b 45 10             	mov    0x10(%ebp),%eax
   16352:	c7 40 30 f8 ff 00 00 	movl   $0xfff8,0x30(%eax)
   16359:	8b 45 10             	mov    0x10(%ebp),%eax
   1635c:	8b 50 30             	mov    0x30(%eax),%edx
   1635f:	8b 45 10             	mov    0x10(%ebp),%eax
   16362:	89 50 34             	mov    %edx,0x34(%eax)
            file->size = 0;
   16365:	8b 45 10             	mov    0x10(%ebp),%eax
   16368:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
        }
        return 0;
   1636f:	b8 00 00 00 00       	mov    $0x0,%eax
   16374:	eb 6f                	jmp    163e5 <fatfs_open+0x17c>
    }else if ((file->mode & O_CREAT) && p_index >= 0)
   16376:	8b 45 10             	mov    0x10(%ebp),%eax
   16379:	8b 40 40             	mov    0x40(%eax),%eax
   1637c:	25 00 02 00 00       	and    $0x200,%eax
   16381:	85 c0                	test   %eax,%eax
   16383:	74 5b                	je     163e0 <fatfs_open+0x177>
   16385:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16389:	78 55                	js     163e0 <fatfs_open+0x177>
        {
            diritem_t diritem;
            diritem_init(&diritem, 0, path);
   1638b:	83 ec 04             	sub    $0x4,%esp
   1638e:	ff 75 0c             	pushl  0xc(%ebp)
   16391:	6a 00                	push   $0x0
   16393:	8d 45 c0             	lea    -0x40(%ebp),%eax
   16396:	50                   	push   %eax
   16397:	e8 7b fe ff ff       	call   16217 <diritem_init>
   1639c:	83 c4 10             	add    $0x10,%esp
            int err = write_dir_ent(fat, &diritem, p_index);
   1639f:	83 ec 04             	sub    $0x4,%esp
   163a2:	ff 75 f0             	pushl  -0x10(%ebp)
   163a5:	8d 45 c0             	lea    -0x40(%ebp),%eax
   163a8:	50                   	push   %eax
   163a9:	ff 75 e8             	pushl  -0x18(%ebp)
   163ac:	e8 d0 08 00 00       	call   16c81 <write_dir_ent>
   163b1:	83 c4 10             	add    $0x10,%esp
   163b4:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(err < 0)
   163b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   163bb:	79 07                	jns    163c4 <fatfs_open+0x15b>
                return -1;
   163bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   163c2:	eb 21                	jmp    163e5 <fatfs_open+0x17c>
            read_from_diritem(fat, file, &diritem, p_index);
   163c4:	ff 75 f0             	pushl  -0x10(%ebp)
   163c7:	8d 45 c0             	lea    -0x40(%ebp),%eax
   163ca:	50                   	push   %eax
   163cb:	ff 75 10             	pushl  0x10(%ebp)
   163ce:	ff 75 e8             	pushl  -0x18(%ebp)
   163d1:	e8 18 fd ff ff       	call   160ee <read_from_diritem>
   163d6:	83 c4 10             	add    $0x10,%esp
            return 0;
   163d9:	b8 00 00 00 00       	mov    $0x0,%eax
   163de:	eb 05                	jmp    163e5 <fatfs_open+0x17c>
        }

    return -1;
   163e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   163e5:	c9                   	leave  
   163e6:	c3                   	ret    

000163e7 <clust_is_valid>:
int clust_is_valid(cluster_t cluster)
{
   163e7:	55                   	push   %ebp
   163e8:	89 e5                	mov    %esp,%ebp
   163ea:	83 ec 04             	sub    $0x4,%esp
   163ed:	8b 45 08             	mov    0x8(%ebp),%eax
   163f0:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    return (cluster < 0xFFF8) && (cluster >= 0x2);
   163f4:	66 83 7d fc f7       	cmpw   $0xfff7,-0x4(%ebp)
   163f9:	77 0e                	ja     16409 <clust_is_valid+0x22>
   163fb:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%ebp)
   16400:	76 07                	jbe    16409 <clust_is_valid+0x22>
   16402:	b8 01 00 00 00       	mov    $0x1,%eax
   16407:	eb 05                	jmp    1640e <clust_is_valid+0x27>
   16409:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1640e:	c9                   	leave  
   1640f:	c3                   	ret    

00016410 <bread_sector>:
int bread_sector(fat_t* fat, int sector) // 带缓冲的读取
{
   16410:	55                   	push   %ebp
   16411:	89 e5                	mov    %esp,%ebp
   16413:	83 ec 18             	sub    $0x18,%esp
    if(sector == fat-> curr_sector)
   16416:	8b 45 08             	mov    0x8(%ebp),%eax
   16419:	8b 40 24             	mov    0x24(%eax),%eax
   1641c:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1641f:	75 07                	jne    16428 <bread_sector+0x18>
        return 0;
   16421:	b8 00 00 00 00       	mov    $0x0,%eax
   16426:	eb 3f                	jmp    16467 <bread_sector+0x57>
    
    int cnt = dev_read(fat->fs->dev_id, sector, fat->fat_buffer, 1);
   16428:	8b 45 08             	mov    0x8(%ebp),%eax
   1642b:	8b 50 28             	mov    0x28(%eax),%edx
   1642e:	8b 45 08             	mov    0x8(%ebp),%eax
   16431:	8b 40 2c             	mov    0x2c(%eax),%eax
   16434:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   1643a:	6a 01                	push   $0x1
   1643c:	52                   	push   %edx
   1643d:	ff 75 0c             	pushl  0xc(%ebp)
   16440:	50                   	push   %eax
   16441:	e8 dd dc ff ff       	call   14123 <dev_read>
   16446:	83 c4 10             	add    $0x10,%esp
   16449:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(cnt != 1)
   1644c:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   16450:	74 07                	je     16459 <bread_sector+0x49>
        return -1;
   16452:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16457:	eb 0e                	jmp    16467 <bread_sector+0x57>
    fat->curr_sector = sector;
   16459:	8b 45 08             	mov    0x8(%ebp),%eax
   1645c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1645f:	89 50 24             	mov    %edx,0x24(%eax)
    return 0;
   16462:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16467:	c9                   	leave  
   16468:	c3                   	ret    

00016469 <bwrite_sector>:

int bwrite_sector(fat_t* fat, int sector) // 带缓冲的读取
{
   16469:	55                   	push   %ebp
   1646a:	89 e5                	mov    %esp,%ebp
   1646c:	83 ec 18             	sub    $0x18,%esp

    int cnt = dev_write(fat->fs->dev_id, sector, fat->fat_buffer, 1);
   1646f:	8b 45 08             	mov    0x8(%ebp),%eax
   16472:	8b 50 28             	mov    0x28(%eax),%edx
   16475:	8b 45 08             	mov    0x8(%ebp),%eax
   16478:	8b 40 2c             	mov    0x2c(%eax),%eax
   1647b:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   16481:	6a 01                	push   $0x1
   16483:	52                   	push   %edx
   16484:	ff 75 0c             	pushl  0xc(%ebp)
   16487:	50                   	push   %eax
   16488:	e8 e2 dc ff ff       	call   1416f <dev_write>
   1648d:	83 c4 10             	add    $0x10,%esp
   16490:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return (cnt == 1) ? 0 : -1;
   16493:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
   16497:	75 07                	jne    164a0 <bwrite_sector+0x37>
   16499:	b8 00 00 00 00       	mov    $0x0,%eax
   1649e:	eb 05                	jmp    164a5 <bwrite_sector+0x3c>
   164a0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   164a5:	c9                   	leave  
   164a6:	c3                   	ret    

000164a7 <cluster_get_next>:
cluster_t cluster_get_next(fat_t* fat, cluster_t curr)
{
   164a7:	55                   	push   %ebp
   164a8:	89 e5                	mov    %esp,%ebp
   164aa:	83 ec 28             	sub    $0x28,%esp
   164ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   164b0:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
     if (!clust_is_valid(curr)) {
   164b4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   164b8:	50                   	push   %eax
   164b9:	e8 29 ff ff ff       	call   163e7 <clust_is_valid>
   164be:	83 c4 04             	add    $0x4,%esp
   164c1:	85 c0                	test   %eax,%eax
   164c3:	75 0a                	jne    164cf <cluster_get_next+0x28>
        return FAT_CLUSTER_INVALID;
   164c5:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   164ca:	e9 91 00 00 00       	jmp    16560 <cluster_get_next+0xb9>
    }

    int offset = curr * sizeof(cluster_t);
   164cf:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   164d3:	01 c0                	add    %eax,%eax
   164d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int sector = offset / fat->bytes_per_sec;
   164d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   164db:	8b 55 08             	mov    0x8(%ebp),%edx
   164de:	8b 4a 0c             	mov    0xc(%edx),%ecx
   164e1:	ba 00 00 00 00       	mov    $0x0,%edx
   164e6:	f7 f1                	div    %ecx
   164e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int off_sector = offset % fat->bytes_per_sec;
   164eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   164ee:	8b 55 08             	mov    0x8(%ebp),%edx
   164f1:	8b 4a 0c             	mov    0xc(%edx),%ecx
   164f4:	ba 00 00 00 00       	mov    $0x0,%edx
   164f9:	f7 f1                	div    %ecx
   164fb:	89 d0                	mov    %edx,%eax
   164fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (sector >= fat->tbl_sectors) {
   16500:	8b 45 08             	mov    0x8(%ebp),%eax
   16503:	8b 50 08             	mov    0x8(%eax),%edx
   16506:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16509:	39 c2                	cmp    %eax,%edx
   1650b:	77 1c                	ja     16529 <cluster_get_next+0x82>
        log_printf("cluster too big. %d", curr);
   1650d:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   16511:	83 ec 08             	sub    $0x8,%esp
   16514:	50                   	push   %eax
   16515:	68 66 9f 01 00       	push   $0x19f66
   1651a:	e8 2d 2a 00 00       	call   18f4c <log_printf>
   1651f:	83 c4 10             	add    $0x10,%esp
        return FAT_CLUSTER_INVALID;
   16522:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   16527:	eb 37                	jmp    16560 <cluster_get_next+0xb9>
    }

    int err = bread_sector(fat, fat->tbl_start + sector);
   16529:	8b 45 08             	mov    0x8(%ebp),%eax
   1652c:	8b 10                	mov    (%eax),%edx
   1652e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16531:	01 d0                	add    %edx,%eax
   16533:	83 ec 08             	sub    $0x8,%esp
   16536:	50                   	push   %eax
   16537:	ff 75 08             	pushl  0x8(%ebp)
   1653a:	e8 d1 fe ff ff       	call   16410 <bread_sector>
   1653f:	83 c4 10             	add    $0x10,%esp
   16542:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (err < 0) {
   16545:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   16549:	79 07                	jns    16552 <cluster_get_next+0xab>
        return FAT_CLUSTER_INVALID;
   1654b:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   16550:	eb 0e                	jmp    16560 <cluster_get_next+0xb9>
    }

    return *(cluster_t*)(fat->fat_buffer + off_sector);
   16552:	8b 45 08             	mov    0x8(%ebp),%eax
   16555:	8b 50 28             	mov    0x28(%eax),%edx
   16558:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1655b:	01 d0                	add    %edx,%eax
   1655d:	0f b7 00             	movzwl (%eax),%eax

}
   16560:	c9                   	leave  
   16561:	c3                   	ret    

00016562 <move_pos>:
int move_pos(file_t* file, fat_t * fat, uint32_t move_bytes, int expand)
{
   16562:	55                   	push   %ebp
   16563:	89 e5                	mov    %esp,%ebp
   16565:	83 ec 18             	sub    $0x18,%esp
    	uint32_t c_offset = file->pos % fat->cluster_byte_size;
   16568:	8b 45 08             	mov    0x8(%ebp),%eax
   1656b:	8b 40 3c             	mov    0x3c(%eax),%eax
   1656e:	89 c2                	mov    %eax,%edx
   16570:	8b 45 0c             	mov    0xc(%ebp),%eax
   16573:	8b 48 20             	mov    0x20(%eax),%ecx
   16576:	89 d0                	mov    %edx,%eax
   16578:	ba 00 00 00 00       	mov    $0x0,%edx
   1657d:	f7 f1                	div    %ecx
   1657f:	89 55 f0             	mov    %edx,-0x10(%ebp)

	if (c_offset + move_bytes >= fat->cluster_byte_size) {
   16582:	8b 55 f0             	mov    -0x10(%ebp),%edx
   16585:	8b 45 10             	mov    0x10(%ebp),%eax
   16588:	01 c2                	add    %eax,%edx
   1658a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1658d:	8b 40 20             	mov    0x20(%eax),%eax
   16590:	39 c2                	cmp    %eax,%edx
   16592:	72 74                	jb     16608 <move_pos+0xa6>
        cluster_t next = cluster_get_next(fat, file->cblk);
   16594:	8b 45 08             	mov    0x8(%ebp),%eax
   16597:	8b 40 34             	mov    0x34(%eax),%eax
   1659a:	0f b7 c0             	movzwl %ax,%eax
   1659d:	83 ec 08             	sub    $0x8,%esp
   165a0:	50                   	push   %eax
   165a1:	ff 75 0c             	pushl  0xc(%ebp)
   165a4:	e8 fe fe ff ff       	call   164a7 <cluster_get_next>
   165a9:	83 c4 10             	add    $0x10,%esp
   165ac:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
			if ((next == FAT_CLUSTER_INVALID) && expand) {
   165b0:	66 83 7d f6 f8       	cmpw   $0xfff8,-0xa(%ebp)
   165b5:	75 47                	jne    165fe <move_pos+0x9c>
   165b7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   165bb:	74 41                	je     165fe <move_pos+0x9c>
            int err = expand_filesz(file, fat->cluster_byte_size);
   165bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   165c0:	8b 40 20             	mov    0x20(%eax),%eax
   165c3:	83 ec 08             	sub    $0x8,%esp
   165c6:	50                   	push   %eax
   165c7:	ff 75 08             	pushl  0x8(%ebp)
   165ca:	e8 2c f7 ff ff       	call   15cfb <expand_filesz>
   165cf:	83 c4 10             	add    $0x10,%esp
   165d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (err < 0) {
   165d5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   165d9:	79 07                	jns    165e2 <move_pos+0x80>
                return -1;
   165db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   165e0:	eb 40                	jmp    16622 <move_pos+0xc0>
            }

            next = cluster_get_next(fat, file->cblk);
   165e2:	8b 45 08             	mov    0x8(%ebp),%eax
   165e5:	8b 40 34             	mov    0x34(%eax),%eax
   165e8:	0f b7 c0             	movzwl %ax,%eax
   165eb:	83 ec 08             	sub    $0x8,%esp
   165ee:	50                   	push   %eax
   165ef:	ff 75 0c             	pushl  0xc(%ebp)
   165f2:	e8 b0 fe ff ff       	call   164a7 <cluster_get_next>
   165f7:	83 c4 10             	add    $0x10,%esp
   165fa:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
        }

        file->cblk = next;
   165fe:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
   16602:	8b 45 08             	mov    0x8(%ebp),%eax
   16605:	89 50 34             	mov    %edx,0x34(%eax)
	}

	file->pos += move_bytes;
   16608:	8b 45 08             	mov    0x8(%ebp),%eax
   1660b:	8b 40 3c             	mov    0x3c(%eax),%eax
   1660e:	89 c2                	mov    %eax,%edx
   16610:	8b 45 10             	mov    0x10(%ebp),%eax
   16613:	01 d0                	add    %edx,%eax
   16615:	89 c2                	mov    %eax,%edx
   16617:	8b 45 08             	mov    0x8(%ebp),%eax
   1661a:	89 50 3c             	mov    %edx,0x3c(%eax)
	return 0;
   1661d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16622:	c9                   	leave  
   16623:	c3                   	ret    

00016624 <fatfs_read>:

int fatfs_read (char * buf, int size, file_t * file) {
   16624:	55                   	push   %ebp
   16625:	89 e5                	mov    %esp,%ebp
   16627:	53                   	push   %ebx
   16628:	83 ec 34             	sub    $0x34,%esp
    fat_t * fat = (fat_t *)file->fs->data;
   1662b:	8b 45 10             	mov    0x10(%ebp),%eax
   1662e:	8b 40 44             	mov    0x44(%eax),%eax
   16631:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   16637:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // 调整读取量，不要超过文件总量
    uint32_t nbytes = size;
   1663a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1663d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (file->pos + nbytes > file->size) {
   16640:	8b 45 10             	mov    0x10(%ebp),%eax
   16643:	8b 40 3c             	mov    0x3c(%eax),%eax
   16646:	89 c2                	mov    %eax,%edx
   16648:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1664b:	01 c2                	add    %eax,%edx
   1664d:	8b 45 10             	mov    0x10(%ebp),%eax
   16650:	8b 40 24             	mov    0x24(%eax),%eax
   16653:	39 c2                	cmp    %eax,%edx
   16655:	76 13                	jbe    1666a <fatfs_read+0x46>
        nbytes = file->size - file->pos;
   16657:	8b 45 10             	mov    0x10(%ebp),%eax
   1665a:	8b 50 24             	mov    0x24(%eax),%edx
   1665d:	8b 45 10             	mov    0x10(%ebp),%eax
   16660:	8b 40 3c             	mov    0x3c(%eax),%eax
   16663:	29 c2                	sub    %eax,%edx
   16665:	89 d0                	mov    %edx,%eax
   16667:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    uint32_t total_read = 0;
   1666a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while (nbytes > 0) {
   16671:	e9 3f 01 00 00       	jmp    167b5 <fatfs_read+0x191>
        uint32_t curr_read = nbytes;
   16676:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16679:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32_t cluster_offset = file->pos % fat->cluster_byte_size;
   1667c:	8b 45 10             	mov    0x10(%ebp),%eax
   1667f:	8b 40 3c             	mov    0x3c(%eax),%eax
   16682:	89 c2                	mov    %eax,%edx
   16684:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16687:	8b 48 20             	mov    0x20(%eax),%ecx
   1668a:	89 d0                	mov    %edx,%eax
   1668c:	ba 00 00 00 00       	mov    $0x0,%edx
   16691:	f7 f1                	div    %ecx
   16693:	89 55 e4             	mov    %edx,-0x1c(%ebp)
        uint32_t start_sector = fat->data_start + (file->cblk - 2)* fat->sec_per_cluster;  // 从2开始
   16696:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16699:	8b 50 1c             	mov    0x1c(%eax),%edx
   1669c:	8b 45 10             	mov    0x10(%ebp),%eax
   1669f:	8b 40 34             	mov    0x34(%eax),%eax
   166a2:	8d 48 fe             	lea    -0x2(%eax),%ecx
   166a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   166a8:	8b 40 10             	mov    0x10(%eax),%eax
   166ab:	0f af c1             	imul   %ecx,%eax
   166ae:	01 d0                	add    %edx,%eax
   166b0:	89 45 e0             	mov    %eax,-0x20(%ebp)

        // 如果是整簇, 只读一簇
        if ((cluster_offset == 0) && (nbytes == fat->cluster_byte_size)) {
   166b3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   166b7:	75 4c                	jne    16705 <fatfs_read+0xe1>
   166b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   166bc:	8b 40 20             	mov    0x20(%eax),%eax
   166bf:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   166c2:	75 41                	jne    16705 <fatfs_read+0xe1>
            int err = dev_read(fat->fs->dev_id, start_sector, buf, fat->sec_per_cluster);
   166c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   166c7:	8b 40 10             	mov    0x10(%eax),%eax
   166ca:	89 c1                	mov    %eax,%ecx
   166cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
   166cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   166d2:	8b 40 2c             	mov    0x2c(%eax),%eax
   166d5:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   166db:	51                   	push   %ecx
   166dc:	ff 75 08             	pushl  0x8(%ebp)
   166df:	52                   	push   %edx
   166e0:	50                   	push   %eax
   166e1:	e8 3d da ff ff       	call   14123 <dev_read>
   166e6:	83 c4 10             	add    $0x10,%esp
   166e9:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if (err < 0) {
   166ec:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   166f0:	79 08                	jns    166fa <fatfs_read+0xd6>
                return total_read;
   166f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   166f5:	e9 c8 00 00 00       	jmp    167c2 <fatfs_read+0x19e>
            }

            curr_read = fat->cluster_byte_size;
   166fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   166fd:	8b 40 20             	mov    0x20(%eax),%eax
   16700:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if ((cluster_offset == 0) && (nbytes == fat->cluster_byte_size)) {
   16703:	eb 7d                	jmp    16782 <fatfs_read+0x15e>
        } else {
            // 如果跨簇，只读第一个簇内的一部分
            if (cluster_offset + curr_read > fat->cluster_byte_size) {
   16705:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16708:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1670b:	01 c2                	add    %eax,%edx
   1670d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16710:	8b 40 20             	mov    0x20(%eax),%eax
   16713:	39 c2                	cmp    %eax,%edx
   16715:	76 0c                	jbe    16723 <fatfs_read+0xff>
                curr_read = fat->cluster_byte_size - cluster_offset;
   16717:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1671a:	8b 40 20             	mov    0x20(%eax),%eax
   1671d:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   16720:	89 45 ec             	mov    %eax,-0x14(%ebp)
            }

            // 读取整个簇，然后从中拷贝
            fat->curr_sector = -1;
   16723:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16726:	c7 40 24 ff ff ff ff 	movl   $0xffffffff,0x24(%eax)
            int err = dev_read(fat->fs->dev_id, start_sector, fat->fat_buffer, fat->sec_per_cluster);
   1672d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16730:	8b 40 10             	mov    0x10(%eax),%eax
   16733:	89 c3                	mov    %eax,%ebx
   16735:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16738:	8b 48 28             	mov    0x28(%eax),%ecx
   1673b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1673e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16741:	8b 40 2c             	mov    0x2c(%eax),%eax
   16744:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   1674a:	53                   	push   %ebx
   1674b:	51                   	push   %ecx
   1674c:	52                   	push   %edx
   1674d:	50                   	push   %eax
   1674e:	e8 d0 d9 ff ff       	call   14123 <dev_read>
   16753:	83 c4 10             	add    $0x10,%esp
   16756:	89 45 d8             	mov    %eax,-0x28(%ebp)
            if (err < 0) {
   16759:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1675d:	79 05                	jns    16764 <fatfs_read+0x140>
                return total_read;
   1675f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16762:	eb 5e                	jmp    167c2 <fatfs_read+0x19e>
            }
            kernel_memcpy(buf, fat->fat_buffer + cluster_offset, curr_read);
   16764:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16767:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1676a:	8b 4a 28             	mov    0x28(%edx),%ecx
   1676d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16770:	01 ca                	add    %ecx,%edx
   16772:	83 ec 04             	sub    $0x4,%esp
   16775:	50                   	push   %eax
   16776:	52                   	push   %edx
   16777:	ff 75 08             	pushl  0x8(%ebp)
   1677a:	e8 d4 21 00 00       	call   18953 <kernel_memcpy>
   1677f:	83 c4 10             	add    $0x10,%esp
        }

        buf += curr_read;
   16782:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16785:	01 45 08             	add    %eax,0x8(%ebp)
        nbytes -= curr_read;
   16788:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1678b:	29 45 f4             	sub    %eax,-0xc(%ebp)
        total_read += curr_read;
   1678e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16791:	01 45 f0             	add    %eax,-0x10(%ebp)

        // 前移文件指针
		int err = move_pos(file, fat, curr_read, 0);
   16794:	6a 00                	push   $0x0
   16796:	ff 75 ec             	pushl  -0x14(%ebp)
   16799:	ff 75 e8             	pushl  -0x18(%ebp)
   1679c:	ff 75 10             	pushl  0x10(%ebp)
   1679f:	e8 be fd ff ff       	call   16562 <move_pos>
   167a4:	83 c4 10             	add    $0x10,%esp
   167a7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if (err < 0) {
   167aa:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   167ae:	79 05                	jns    167b5 <fatfs_read+0x191>
            return total_read;
   167b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   167b3:	eb 0d                	jmp    167c2 <fatfs_read+0x19e>
    while (nbytes > 0) {
   167b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   167b9:	0f 85 b7 fe ff ff    	jne    16676 <fatfs_read+0x52>
        }
	}

    return total_read;
   167bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   167c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   167c5:	c9                   	leave  
   167c6:	c3                   	ret    

000167c7 <fatfs_write>:


int fatfs_write (char * buf, int size, file_t * file) {
   167c7:	55                   	push   %ebp
   167c8:	89 e5                	mov    %esp,%ebp
   167ca:	53                   	push   %ebx
   167cb:	83 ec 34             	sub    $0x34,%esp
    fat_t * fat = (fat_t *)file->fs->data;
   167ce:	8b 45 10             	mov    0x10(%ebp),%eax
   167d1:	8b 40 44             	mov    0x44(%eax),%eax
   167d4:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   167da:	89 45 e8             	mov    %eax,-0x18(%ebp)

    // 调整读取量，不要超过文件总量
    uint32_t nbytes = size;
   167dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   167e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (file->pos + nbytes > file->size) {
   167e3:	8b 45 10             	mov    0x10(%ebp),%eax
   167e6:	8b 40 3c             	mov    0x3c(%eax),%eax
   167e9:	89 c2                	mov    %eax,%edx
   167eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   167ee:	01 c2                	add    %eax,%edx
   167f0:	8b 45 10             	mov    0x10(%ebp),%eax
   167f3:	8b 40 24             	mov    0x24(%eax),%eax
   167f6:	39 c2                	cmp    %eax,%edx
   167f8:	76 3e                	jbe    16838 <fatfs_write+0x71>
        int inc_size = file->pos + size - file->size;
   167fa:	8b 45 10             	mov    0x10(%ebp),%eax
   167fd:	8b 50 3c             	mov    0x3c(%eax),%edx
   16800:	8b 45 0c             	mov    0xc(%ebp),%eax
   16803:	01 d0                	add    %edx,%eax
   16805:	89 c2                	mov    %eax,%edx
   16807:	8b 45 10             	mov    0x10(%ebp),%eax
   1680a:	8b 40 24             	mov    0x24(%eax),%eax
   1680d:	29 c2                	sub    %eax,%edx
   1680f:	89 d0                	mov    %edx,%eax
   16811:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err = expand_filesz(file, inc_size);
   16814:	83 ec 08             	sub    $0x8,%esp
   16817:	ff 75 e4             	pushl  -0x1c(%ebp)
   1681a:	ff 75 10             	pushl  0x10(%ebp)
   1681d:	e8 d9 f4 ff ff       	call   15cfb <expand_filesz>
   16822:	83 c4 10             	add    $0x10,%esp
   16825:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if(err < 0)
   16828:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1682c:	79 0a                	jns    16838 <fatfs_write+0x71>
            return 0;
   1682e:	b8 00 00 00 00       	mov    $0x0,%eax
   16833:	e9 a6 01 00 00       	jmp    169de <fatfs_write+0x217>
    }

    uint32_t total_write = 0;
   16838:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    while (nbytes > 0) {
   1683f:	e9 8d 01 00 00       	jmp    169d1 <fatfs_write+0x20a>
        uint32_t curr_write = nbytes;
   16844:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16847:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32_t cluster_offset = file->pos % fat->cluster_byte_size;
   1684a:	8b 45 10             	mov    0x10(%ebp),%eax
   1684d:	8b 40 3c             	mov    0x3c(%eax),%eax
   16850:	89 c2                	mov    %eax,%edx
   16852:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16855:	8b 48 20             	mov    0x20(%eax),%ecx
   16858:	89 d0                	mov    %edx,%eax
   1685a:	ba 00 00 00 00       	mov    $0x0,%edx
   1685f:	f7 f1                	div    %ecx
   16861:	89 55 dc             	mov    %edx,-0x24(%ebp)
        uint32_t start_sector = fat->data_start + (file->cblk - 2)* fat->sec_per_cluster;  // 从2开始
   16864:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16867:	8b 50 1c             	mov    0x1c(%eax),%edx
   1686a:	8b 45 10             	mov    0x10(%ebp),%eax
   1686d:	8b 40 34             	mov    0x34(%eax),%eax
   16870:	8d 48 fe             	lea    -0x2(%eax),%ecx
   16873:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16876:	8b 40 10             	mov    0x10(%eax),%eax
   16879:	0f af c1             	imul   %ecx,%eax
   1687c:	01 d0                	add    %edx,%eax
   1687e:	89 45 d8             	mov    %eax,-0x28(%ebp)

        // 如果是整簇, 只读一簇
        if ((cluster_offset == 0) && (nbytes == fat->cluster_byte_size)) {
   16881:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   16885:	75 4f                	jne    168d6 <fatfs_write+0x10f>
   16887:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1688a:	8b 40 20             	mov    0x20(%eax),%eax
   1688d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   16890:	75 44                	jne    168d6 <fatfs_write+0x10f>
            int err = dev_write(fat->fs->dev_id, start_sector, buf, fat->sec_per_cluster);
   16892:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16895:	8b 40 10             	mov    0x10(%eax),%eax
   16898:	89 c1                	mov    %eax,%ecx
   1689a:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1689d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   168a0:	8b 40 2c             	mov    0x2c(%eax),%eax
   168a3:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   168a9:	51                   	push   %ecx
   168aa:	ff 75 08             	pushl  0x8(%ebp)
   168ad:	52                   	push   %edx
   168ae:	50                   	push   %eax
   168af:	e8 bb d8 ff ff       	call   1416f <dev_write>
   168b4:	83 c4 10             	add    $0x10,%esp
   168b7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if (err < 0) {
   168ba:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   168be:	79 08                	jns    168c8 <fatfs_write+0x101>
                return total_write;
   168c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   168c3:	e9 16 01 00 00       	jmp    169de <fatfs_write+0x217>
            }

            curr_write = fat->cluster_byte_size;
   168c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   168cb:	8b 40 20             	mov    0x20(%eax),%eax
   168ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if ((cluster_offset == 0) && (nbytes == fat->cluster_byte_size)) {
   168d1:	e9 b7 00 00 00       	jmp    1698d <fatfs_write+0x1c6>
        } else {
            // 如果跨簇，只读第一个簇内的一部分
            if (cluster_offset + curr_write > fat->cluster_byte_size) {
   168d6:	8b 55 dc             	mov    -0x24(%ebp),%edx
   168d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   168dc:	01 c2                	add    %eax,%edx
   168de:	8b 45 e8             	mov    -0x18(%ebp),%eax
   168e1:	8b 40 20             	mov    0x20(%eax),%eax
   168e4:	39 c2                	cmp    %eax,%edx
   168e6:	76 0c                	jbe    168f4 <fatfs_write+0x12d>
                curr_write = fat->cluster_byte_size - cluster_offset;
   168e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   168eb:	8b 40 20             	mov    0x20(%eax),%eax
   168ee:	2b 45 dc             	sub    -0x24(%ebp),%eax
   168f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
            }

            // 读取整个簇，然后从中拷贝
            fat->curr_sector = -1;
   168f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   168f7:	c7 40 24 ff ff ff ff 	movl   $0xffffffff,0x24(%eax)
            int err = dev_read(fat->fs->dev_id, start_sector, fat->fat_buffer, fat->sec_per_cluster);
   168fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16901:	8b 40 10             	mov    0x10(%eax),%eax
   16904:	89 c3                	mov    %eax,%ebx
   16906:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16909:	8b 48 28             	mov    0x28(%eax),%ecx
   1690c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1690f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16912:	8b 40 2c             	mov    0x2c(%eax),%eax
   16915:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   1691b:	53                   	push   %ebx
   1691c:	51                   	push   %ecx
   1691d:	52                   	push   %edx
   1691e:	50                   	push   %eax
   1691f:	e8 ff d7 ff ff       	call   14123 <dev_read>
   16924:	83 c4 10             	add    $0x10,%esp
   16927:	89 45 d0             	mov    %eax,-0x30(%ebp)
            if (err < 0) {
   1692a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   1692e:	79 08                	jns    16938 <fatfs_write+0x171>
                return total_write;
   16930:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16933:	e9 a6 00 00 00       	jmp    169de <fatfs_write+0x217>
            }
            kernel_memcpy(fat->fat_buffer + cluster_offset, buf, curr_write);
   16938:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1693b:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1693e:	8b 4a 28             	mov    0x28(%edx),%ecx
   16941:	8b 55 dc             	mov    -0x24(%ebp),%edx
   16944:	01 ca                	add    %ecx,%edx
   16946:	83 ec 04             	sub    $0x4,%esp
   16949:	50                   	push   %eax
   1694a:	ff 75 08             	pushl  0x8(%ebp)
   1694d:	52                   	push   %edx
   1694e:	e8 00 20 00 00       	call   18953 <kernel_memcpy>
   16953:	83 c4 10             	add    $0x10,%esp
            err = dev_write(fat->fs->dev_id, start_sector, fat->fat_buffer, fat->sec_per_cluster);
   16956:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16959:	8b 40 10             	mov    0x10(%eax),%eax
   1695c:	89 c3                	mov    %eax,%ebx
   1695e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16961:	8b 48 28             	mov    0x28(%eax),%ecx
   16964:	8b 55 d8             	mov    -0x28(%ebp),%edx
   16967:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1696a:	8b 40 2c             	mov    0x2c(%eax),%eax
   1696d:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   16973:	53                   	push   %ebx
   16974:	51                   	push   %ecx
   16975:	52                   	push   %edx
   16976:	50                   	push   %eax
   16977:	e8 f3 d7 ff ff       	call   1416f <dev_write>
   1697c:	83 c4 10             	add    $0x10,%esp
   1697f:	89 45 d0             	mov    %eax,-0x30(%ebp)
            if (err < 0) {
   16982:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   16986:	79 05                	jns    1698d <fatfs_write+0x1c6>
                return total_write;
   16988:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1698b:	eb 51                	jmp    169de <fatfs_write+0x217>
            }
        }

        buf += curr_write;
   1698d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16990:	01 45 08             	add    %eax,0x8(%ebp)
        nbytes -= curr_write;
   16993:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16996:	29 45 f4             	sub    %eax,-0xc(%ebp)
        total_write += curr_write;
   16999:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1699c:	01 45 f0             	add    %eax,-0x10(%ebp)
        file->size += curr_write;
   1699f:	8b 45 10             	mov    0x10(%ebp),%eax
   169a2:	8b 50 24             	mov    0x24(%eax),%edx
   169a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   169a8:	01 c2                	add    %eax,%edx
   169aa:	8b 45 10             	mov    0x10(%ebp),%eax
   169ad:	89 50 24             	mov    %edx,0x24(%eax)
        // 前移文件指针
		int err = move_pos(file, fat, curr_write, 1);
   169b0:	6a 01                	push   $0x1
   169b2:	ff 75 ec             	pushl  -0x14(%ebp)
   169b5:	ff 75 e8             	pushl  -0x18(%ebp)
   169b8:	ff 75 10             	pushl  0x10(%ebp)
   169bb:	e8 a2 fb ff ff       	call   16562 <move_pos>
   169c0:	83 c4 10             	add    $0x10,%esp
   169c3:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (err < 0) {
   169c6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   169ca:	79 05                	jns    169d1 <fatfs_write+0x20a>
            return total_write;
   169cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   169cf:	eb 0d                	jmp    169de <fatfs_write+0x217>
    while (nbytes > 0) {
   169d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   169d5:	0f 85 69 fe ff ff    	jne    16844 <fatfs_write+0x7d>
        }
	}

    return total_write;
   169db:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   169de:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   169e1:	c9                   	leave  
   169e2:	c3                   	ret    

000169e3 <fatfs_close>:

void fatfs_close (file_t * file) {
   169e3:	55                   	push   %ebp
   169e4:	89 e5                	mov    %esp,%ebp
   169e6:	83 ec 18             	sub    $0x18,%esp
        if (file->mode == O_RDONLY) {
   169e9:	8b 45 08             	mov    0x8(%ebp),%eax
   169ec:	8b 40 40             	mov    0x40(%eax),%eax
   169ef:	85 c0                	test   %eax,%eax
   169f1:	74 74                	je     16a67 <fatfs_close+0x84>
        return;
    }

    fat_t * fat = (fat_t *)file->fs->data;
   169f3:	8b 45 08             	mov    0x8(%ebp),%eax
   169f6:	8b 40 44             	mov    0x44(%eax),%eax
   169f9:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   169ff:	89 45 f4             	mov    %eax,-0xc(%ebp)

    diritem_t * item = read_dir_ent(fat, file->p_index);
   16a02:	8b 45 08             	mov    0x8(%ebp),%eax
   16a05:	8b 40 38             	mov    0x38(%eax),%eax
   16a08:	83 ec 08             	sub    $0x8,%esp
   16a0b:	50                   	push   %eax
   16a0c:	ff 75 f4             	pushl  -0xc(%ebp)
   16a0f:	e8 e8 01 00 00       	call   16bfc <read_dir_ent>
   16a14:	83 c4 10             	add    $0x10,%esp
   16a17:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (item == (diritem_t *)0) {
   16a1a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16a1e:	74 4a                	je     16a6a <fatfs_close+0x87>
        return;
    }

    item->DIR_FileSize = file->size;
   16a20:	8b 45 08             	mov    0x8(%ebp),%eax
   16a23:	8b 50 24             	mov    0x24(%eax),%edx
   16a26:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16a29:	89 50 1c             	mov    %edx,0x1c(%eax)
    item->DIR_FstClusHI = (uint16_t )(file->sblk >> 16);
   16a2c:	8b 45 08             	mov    0x8(%ebp),%eax
   16a2f:	8b 40 30             	mov    0x30(%eax),%eax
   16a32:	c1 e8 10             	shr    $0x10,%eax
   16a35:	89 c2                	mov    %eax,%edx
   16a37:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16a3a:	66 89 50 14          	mov    %dx,0x14(%eax)
    item->DIR_FstClusL0 = (uint16_t )(file->sblk & 0xFFFF);
   16a3e:	8b 45 08             	mov    0x8(%ebp),%eax
   16a41:	8b 40 30             	mov    0x30(%eax),%eax
   16a44:	89 c2                	mov    %eax,%edx
   16a46:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16a49:	66 89 50 1a          	mov    %dx,0x1a(%eax)
    write_dir_ent(fat, item, file->p_index);
   16a4d:	8b 45 08             	mov    0x8(%ebp),%eax
   16a50:	8b 40 38             	mov    0x38(%eax),%eax
   16a53:	83 ec 04             	sub    $0x4,%esp
   16a56:	50                   	push   %eax
   16a57:	ff 75 f0             	pushl  -0x10(%ebp)
   16a5a:	ff 75 f4             	pushl  -0xc(%ebp)
   16a5d:	e8 1f 02 00 00       	call   16c81 <write_dir_ent>
   16a62:	83 c4 10             	add    $0x10,%esp
   16a65:	eb 04                	jmp    16a6b <fatfs_close+0x88>
        return;
   16a67:	90                   	nop
   16a68:	eb 01                	jmp    16a6b <fatfs_close+0x88>
        return;
   16a6a:	90                   	nop
}
   16a6b:	c9                   	leave  
   16a6c:	c3                   	ret    

00016a6d <fatfs_seek>:


int fatfs_seek (file_t * file, uint32_t offset, int dir) {
   16a6d:	55                   	push   %ebp
   16a6e:	89 e5                	mov    %esp,%ebp
   16a70:	83 ec 28             	sub    $0x28,%esp
     // 只支持基于文件开头的定位
    if (dir != 0) {
   16a73:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   16a77:	74 0a                	je     16a83 <fatfs_seek+0x16>
        return -1;
   16a79:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16a7e:	e9 c7 00 00 00       	jmp    16b4a <fatfs_seek+0xdd>
    }

    fat_t * fat = (fat_t *)file->fs->data;
   16a83:	8b 45 08             	mov    0x8(%ebp),%eax
   16a86:	8b 40 44             	mov    0x44(%eax),%eax
   16a89:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   16a8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    cluster_t curr_cluster = file->sblk;
   16a92:	8b 45 08             	mov    0x8(%ebp),%eax
   16a95:	8b 40 30             	mov    0x30(%eax),%eax
   16a98:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
    uint32_t curr_pos = 0;
   16a9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    uint32_t offset_to_move = offset;
   16aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
   16aa6:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (offset_to_move > 0) {
   16aa9:	eb 7d                	jmp    16b28 <fatfs_seek+0xbb>
        uint32_t c_off = curr_pos % fat->cluster_byte_size;
   16aab:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16aae:	8b 48 20             	mov    0x20(%eax),%ecx
   16ab1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16ab4:	ba 00 00 00 00       	mov    $0x0,%edx
   16ab9:	f7 f1                	div    %ecx
   16abb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
        uint32_t curr_move = offset_to_move;
   16abe:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16ac1:	89 45 e0             	mov    %eax,-0x20(%ebp)

        // 不超过一簇，直接调整位置，无需跑到下一簇
        if (c_off + curr_move < fat->cluster_byte_size) {
   16ac4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   16ac7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16aca:	01 c2                	add    %eax,%edx
   16acc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16acf:	8b 40 20             	mov    0x20(%eax),%eax
   16ad2:	39 c2                	cmp    %eax,%edx
   16ad4:	73 08                	jae    16ade <fatfs_seek+0x71>
            curr_pos += curr_move;
   16ad6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16ad9:	01 45 f0             	add    %eax,-0x10(%ebp)
            break;
   16adc:	eb 54                	jmp    16b32 <fatfs_seek+0xc5>
        }

        // 超过一簇，只在当前簇内移动
        curr_move = fat->cluster_byte_size - c_off;
   16ade:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16ae1:	8b 40 20             	mov    0x20(%eax),%eax
   16ae4:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   16ae7:	89 45 e0             	mov    %eax,-0x20(%ebp)
        curr_pos += curr_move;
   16aea:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16aed:	01 45 f0             	add    %eax,-0x10(%ebp)
        offset_to_move -= curr_move;
   16af0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   16af3:	29 45 ec             	sub    %eax,-0x14(%ebp)

        // 取下一簇
        curr_cluster = cluster_get_next(fat, curr_cluster);
   16af6:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   16afa:	83 ec 08             	sub    $0x8,%esp
   16afd:	50                   	push   %eax
   16afe:	ff 75 e8             	pushl  -0x18(%ebp)
   16b01:	e8 a1 f9 ff ff       	call   164a7 <cluster_get_next>
   16b06:	83 c4 10             	add    $0x10,%esp
   16b09:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
        if (!clust_is_valid(curr_cluster)) {
   16b0d:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   16b11:	83 ec 0c             	sub    $0xc,%esp
   16b14:	50                   	push   %eax
   16b15:	e8 cd f8 ff ff       	call   163e7 <clust_is_valid>
   16b1a:	83 c4 10             	add    $0x10,%esp
   16b1d:	85 c0                	test   %eax,%eax
   16b1f:	75 07                	jne    16b28 <fatfs_seek+0xbb>
            return -1;
   16b21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16b26:	eb 22                	jmp    16b4a <fatfs_seek+0xdd>
    while (offset_to_move > 0) {
   16b28:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   16b2c:	0f 85 79 ff ff ff    	jne    16aab <fatfs_seek+0x3e>
        }
    }

    // 最后记录一下位置
    file->pos = curr_pos;
   16b32:	8b 55 f0             	mov    -0x10(%ebp),%edx
   16b35:	8b 45 08             	mov    0x8(%ebp),%eax
   16b38:	89 50 3c             	mov    %edx,0x3c(%eax)
    file->cblk = curr_cluster;
   16b3b:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
   16b3f:	8b 45 08             	mov    0x8(%ebp),%eax
   16b42:	89 50 34             	mov    %edx,0x34(%eax)
    return 0;        
   16b45:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16b4a:	c9                   	leave  
   16b4b:	c3                   	ret    

00016b4c <fatfs_stat>:

int fatfs_stat (file_t * file, struct stat *st) {
   16b4c:	55                   	push   %ebp
   16b4d:	89 e5                	mov    %esp,%ebp
    return -1;
   16b4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   16b54:	5d                   	pop    %ebp
   16b55:	c3                   	ret    

00016b56 <fatfs_opendir>:

int fatfs_opendir (fs_t* fs, const char* name, DIR* dir)
{
   16b56:	55                   	push   %ebp
   16b57:	89 e5                	mov    %esp,%ebp
    dir->index = 0;
   16b59:	8b 45 10             	mov    0x10(%ebp),%eax
   16b5c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    return 0;
   16b62:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16b67:	5d                   	pop    %ebp
   16b68:	c3                   	ret    

00016b69 <get_item_name>:
void get_item_name(diritem_t* item, char* dest)
{
   16b69:	55                   	push   %ebp
   16b6a:	89 e5                	mov    %esp,%ebp
   16b6c:	83 ec 18             	sub    $0x18,%esp
    char*c = dest;
   16b6f:	8b 45 0c             	mov    0xc(%ebp),%eax
   16b72:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* ext = NULL;
   16b75:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    kernel_memset(dest, 0, 12);
   16b7c:	83 ec 04             	sub    $0x4,%esp
   16b7f:	6a 0c                	push   $0xc
   16b81:	6a 00                	push   $0x0
   16b83:	ff 75 0c             	pushl  0xc(%ebp)
   16b86:	e8 17 1e 00 00       	call   189a2 <kernel_memset>
   16b8b:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < 11; ++i)
   16b8e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   16b95:	eb 43                	jmp    16bda <get_item_name+0x71>
    {
        if(item->DIR_Name[i] != ' ')
   16b97:	8b 55 08             	mov    0x8(%ebp),%edx
   16b9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16b9d:	01 d0                	add    %edx,%eax
   16b9f:	0f b6 00             	movzbl (%eax),%eax
   16ba2:	3c 20                	cmp    $0x20,%al
   16ba4:	74 18                	je     16bbe <get_item_name+0x55>
        {
            *c++ = item->DIR_Name[i];
   16ba6:	8b 55 08             	mov    0x8(%ebp),%edx
   16ba9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16bac:	01 d0                	add    %edx,%eax
   16bae:	0f b6 08             	movzbl (%eax),%ecx
   16bb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16bb4:	8d 50 01             	lea    0x1(%eax),%edx
   16bb7:	89 55 f4             	mov    %edx,-0xc(%ebp)
   16bba:	89 ca                	mov    %ecx,%edx
   16bbc:	88 10                	mov    %dl,(%eax)
        }

        if(i == 7)
   16bbe:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
   16bc2:	75 12                	jne    16bd6 <get_item_name+0x6d>
        {
            ext = c;
   16bc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16bc7:	89 45 f0             	mov    %eax,-0x10(%ebp)
            *c++ = '.';
   16bca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16bcd:	8d 50 01             	lea    0x1(%eax),%edx
   16bd0:	89 55 f4             	mov    %edx,-0xc(%ebp)
   16bd3:	c6 00 2e             	movb   $0x2e,(%eax)
    for(int i = 0; i < 11; ++i)
   16bd6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   16bda:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
   16bde:	7e b7                	jle    16b97 <get_item_name+0x2e>
        }
    }
    if(ext && ext[1] == '\0')
   16be0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16be4:	74 13                	je     16bf9 <get_item_name+0x90>
   16be6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16be9:	83 c0 01             	add    $0x1,%eax
   16bec:	0f b6 00             	movzbl (%eax),%eax
   16bef:	84 c0                	test   %al,%al
   16bf1:	75 06                	jne    16bf9 <get_item_name+0x90>
    {
        ext[0] = '\0';
   16bf3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16bf6:	c6 00 00             	movb   $0x0,(%eax)
    }
}
   16bf9:	90                   	nop
   16bfa:	c9                   	leave  
   16bfb:	c3                   	ret    

00016bfc <read_dir_ent>:

diritem_t* read_dir_ent(fat_t* fat, int index)
{
   16bfc:	55                   	push   %ebp
   16bfd:	89 e5                	mov    %esp,%ebp
   16bff:	53                   	push   %ebx
   16c00:	83 ec 14             	sub    $0x14,%esp
    if(index < 0 || index >= fat->root_ent_cnt)
   16c03:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   16c07:	78 0d                	js     16c16 <read_dir_ent+0x1a>
   16c09:	8b 45 08             	mov    0x8(%ebp),%eax
   16c0c:	8b 50 14             	mov    0x14(%eax),%edx
   16c0f:	8b 45 0c             	mov    0xc(%ebp),%eax
   16c12:	39 c2                	cmp    %eax,%edx
   16c14:	77 07                	ja     16c1d <read_dir_ent+0x21>
        return (diritem_t*)0;
   16c16:	b8 00 00 00 00       	mov    $0x0,%eax
   16c1b:	eb 5f                	jmp    16c7c <read_dir_ent+0x80>
    int offset = index * sizeof(diritem_t);
   16c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16c20:	c1 e0 05             	shl    $0x5,%eax
   16c23:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int sector = fat->root_start + offset/fat->bytes_per_sec;
   16c26:	8b 45 08             	mov    0x8(%ebp),%eax
   16c29:	8b 48 18             	mov    0x18(%eax),%ecx
   16c2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16c2f:	8b 55 08             	mov    0x8(%ebp),%edx
   16c32:	8b 5a 0c             	mov    0xc(%edx),%ebx
   16c35:	ba 00 00 00 00       	mov    $0x0,%edx
   16c3a:	f7 f3                	div    %ebx
   16c3c:	01 c8                	add    %ecx,%eax
   16c3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int err = bread_sector(fat, sector);
   16c41:	83 ec 08             	sub    $0x8,%esp
   16c44:	ff 75 f0             	pushl  -0x10(%ebp)
   16c47:	ff 75 08             	pushl  0x8(%ebp)
   16c4a:	e8 c1 f7 ff ff       	call   16410 <bread_sector>
   16c4f:	83 c4 10             	add    $0x10,%esp
   16c52:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(err < 0)
   16c55:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   16c59:	79 07                	jns    16c62 <read_dir_ent+0x66>
        return (diritem_t*)0;
   16c5b:	b8 00 00 00 00       	mov    $0x0,%eax
   16c60:	eb 1a                	jmp    16c7c <read_dir_ent+0x80>
    return (diritem_t*)(fat->fat_buffer + offset % fat->bytes_per_sec);
   16c62:	8b 45 08             	mov    0x8(%ebp),%eax
   16c65:	8b 48 28             	mov    0x28(%eax),%ecx
   16c68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16c6b:	8b 55 08             	mov    0x8(%ebp),%edx
   16c6e:	8b 5a 0c             	mov    0xc(%edx),%ebx
   16c71:	ba 00 00 00 00       	mov    $0x0,%edx
   16c76:	f7 f3                	div    %ebx
   16c78:	89 d0                	mov    %edx,%eax
   16c7a:	01 c8                	add    %ecx,%eax
}
   16c7c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   16c7f:	c9                   	leave  
   16c80:	c3                   	ret    

00016c81 <write_dir_ent>:
int write_dir_ent(fat_t* fat, diritem_t* item, int index)
{
   16c81:	55                   	push   %ebp
   16c82:	89 e5                	mov    %esp,%ebp
   16c84:	53                   	push   %ebx
   16c85:	83 ec 14             	sub    $0x14,%esp
    if(index < 0 || index >= fat->root_ent_cnt)
   16c88:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   16c8c:	78 0d                	js     16c9b <write_dir_ent+0x1a>
   16c8e:	8b 45 08             	mov    0x8(%ebp),%eax
   16c91:	8b 50 14             	mov    0x14(%eax),%edx
   16c94:	8b 45 10             	mov    0x10(%ebp),%eax
   16c97:	39 c2                	cmp    %eax,%edx
   16c99:	77 0a                	ja     16ca5 <write_dir_ent+0x24>
        return -1;
   16c9b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16ca0:	e9 81 00 00 00       	jmp    16d26 <write_dir_ent+0xa5>
    int offset = index * sizeof(diritem_t);
   16ca5:	8b 45 10             	mov    0x10(%ebp),%eax
   16ca8:	c1 e0 05             	shl    $0x5,%eax
   16cab:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int sector = fat->root_start + offset/fat->bytes_per_sec;
   16cae:	8b 45 08             	mov    0x8(%ebp),%eax
   16cb1:	8b 48 18             	mov    0x18(%eax),%ecx
   16cb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16cb7:	8b 55 08             	mov    0x8(%ebp),%edx
   16cba:	8b 5a 0c             	mov    0xc(%edx),%ebx
   16cbd:	ba 00 00 00 00       	mov    $0x0,%edx
   16cc2:	f7 f3                	div    %ebx
   16cc4:	01 c8                	add    %ecx,%eax
   16cc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int err = bread_sector(fat, sector);
   16cc9:	83 ec 08             	sub    $0x8,%esp
   16ccc:	ff 75 f0             	pushl  -0x10(%ebp)
   16ccf:	ff 75 08             	pushl  0x8(%ebp)
   16cd2:	e8 39 f7 ff ff       	call   16410 <bread_sector>
   16cd7:	83 c4 10             	add    $0x10,%esp
   16cda:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(err < 0)
   16cdd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   16ce1:	79 07                	jns    16cea <write_dir_ent+0x69>
        return -1;
   16ce3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16ce8:	eb 3c                	jmp    16d26 <write_dir_ent+0xa5>
    kernel_memcpy(fat->fat_buffer + offset%fat->bytes_per_sec, item, sizeof(diritem_t));
   16cea:	8b 45 08             	mov    0x8(%ebp),%eax
   16ced:	8b 48 28             	mov    0x28(%eax),%ecx
   16cf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16cf3:	8b 55 08             	mov    0x8(%ebp),%edx
   16cf6:	8b 5a 0c             	mov    0xc(%edx),%ebx
   16cf9:	ba 00 00 00 00       	mov    $0x0,%edx
   16cfe:	f7 f3                	div    %ebx
   16d00:	89 d0                	mov    %edx,%eax
   16d02:	01 c8                	add    %ecx,%eax
   16d04:	83 ec 04             	sub    $0x4,%esp
   16d07:	6a 20                	push   $0x20
   16d09:	ff 75 0c             	pushl  0xc(%ebp)
   16d0c:	50                   	push   %eax
   16d0d:	e8 41 1c 00 00       	call   18953 <kernel_memcpy>
   16d12:	83 c4 10             	add    $0x10,%esp
    return bwrite_sector(fat, sector);
   16d15:	83 ec 08             	sub    $0x8,%esp
   16d18:	ff 75 f0             	pushl  -0x10(%ebp)
   16d1b:	ff 75 08             	pushl  0x8(%ebp)
   16d1e:	e8 46 f7 ff ff       	call   16469 <bwrite_sector>
   16d23:	83 c4 10             	add    $0x10,%esp
}
   16d26:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   16d29:	c9                   	leave  
   16d2a:	c3                   	ret    

00016d2b <fatfs_readdir>:
int fatfs_readdir (fs_t* fs, DIR* dir, struct dirent* dirent)
{
   16d2b:	55                   	push   %ebp
   16d2c:	89 e5                	mov    %esp,%ebp
   16d2e:	83 ec 18             	sub    $0x18,%esp
    fat_t* fat = fs->data;
   16d31:	8b 45 08             	mov    0x8(%ebp),%eax
   16d34:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   16d3a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(dir->index < fat->root_ent_cnt)
   16d3d:	e9 b1 00 00 00       	jmp    16df3 <fatfs_readdir+0xc8>
    {
        diritem_t* item = read_dir_ent(fat, dir->index);
   16d42:	8b 45 0c             	mov    0xc(%ebp),%eax
   16d45:	8b 00                	mov    (%eax),%eax
   16d47:	83 ec 08             	sub    $0x8,%esp
   16d4a:	50                   	push   %eax
   16d4b:	ff 75 f4             	pushl  -0xc(%ebp)
   16d4e:	e8 a9 fe ff ff       	call   16bfc <read_dir_ent>
   16d53:	83 c4 10             	add    $0x10,%esp
   16d56:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (item == (diritem_t *)0) {
   16d59:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   16d5d:	75 0a                	jne    16d69 <fatfs_readdir+0x3e>
            return -1;
   16d5f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16d64:	e9 a7 00 00 00       	jmp    16e10 <fatfs_readdir+0xe5>
        }
        if (item->DIR_Name[0] == DIRITEM_NAME_END) {
   16d69:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16d6c:	0f b6 00             	movzbl (%eax),%eax
   16d6f:	84 c0                	test   %al,%al
   16d71:	0f 84 93 00 00 00    	je     16e0a <fatfs_readdir+0xdf>
            break;
        }
        if (item ->DIR_Name[0] != DIRITEM_NAME_FREE)
   16d77:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16d7a:	0f b6 00             	movzbl (%eax),%eax
   16d7d:	3c e5                	cmp    $0xe5,%al
   16d7f:	74 65                	je     16de6 <fatfs_readdir+0xbb>
        {
            file_type_t type = get_item_type(item);
   16d81:	83 ec 0c             	sub    $0xc,%esp
   16d84:	ff 75 f0             	pushl  -0x10(%ebp)
   16d87:	e8 d7 ed ff ff       	call   15b63 <get_item_type>
   16d8c:	83 c4 10             	add    $0x10,%esp
   16d8f:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if(type == FILE_DIR || type ==FILE_NORMAL)
   16d92:	83 7d ec 02          	cmpl   $0x2,-0x14(%ebp)
   16d96:	74 06                	je     16d9e <fatfs_readdir+0x73>
   16d98:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
   16d9c:	75 48                	jne    16de6 <fatfs_readdir+0xbb>
            {
                dirent->index = dir->index++;
   16d9e:	8b 45 0c             	mov    0xc(%ebp),%eax
   16da1:	8b 00                	mov    (%eax),%eax
   16da3:	8d 48 01             	lea    0x1(%eax),%ecx
   16da6:	8b 55 0c             	mov    0xc(%ebp),%edx
   16da9:	89 0a                	mov    %ecx,(%edx)
   16dab:	8b 55 10             	mov    0x10(%ebp),%edx
   16dae:	89 02                	mov    %eax,(%edx)
                dirent->type = type;
   16db0:	8b 55 ec             	mov    -0x14(%ebp),%edx
   16db3:	8b 45 10             	mov    0x10(%ebp),%eax
   16db6:	89 50 04             	mov    %edx,0x4(%eax)
                dirent->size = item->DIR_FileSize;
   16db9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16dbc:	8b 40 1c             	mov    0x1c(%eax),%eax
   16dbf:	89 c2                	mov    %eax,%edx
   16dc1:	8b 45 10             	mov    0x10(%ebp),%eax
   16dc4:	89 90 08 01 00 00    	mov    %edx,0x108(%eax)
                get_item_name(item, dirent->name);
   16dca:	8b 45 10             	mov    0x10(%ebp),%eax
   16dcd:	83 c0 08             	add    $0x8,%eax
   16dd0:	83 ec 08             	sub    $0x8,%esp
   16dd3:	50                   	push   %eax
   16dd4:	ff 75 f0             	pushl  -0x10(%ebp)
   16dd7:	e8 8d fd ff ff       	call   16b69 <get_item_name>
   16ddc:	83 c4 10             	add    $0x10,%esp
                return 0;
   16ddf:	b8 00 00 00 00       	mov    $0x0,%eax
   16de4:	eb 2a                	jmp    16e10 <fatfs_readdir+0xe5>
            }
            
        }
        dir->index++;
   16de6:	8b 45 0c             	mov    0xc(%ebp),%eax
   16de9:	8b 00                	mov    (%eax),%eax
   16deb:	8d 50 01             	lea    0x1(%eax),%edx
   16dee:	8b 45 0c             	mov    0xc(%ebp),%eax
   16df1:	89 10                	mov    %edx,(%eax)
    while(dir->index < fat->root_ent_cnt)
   16df3:	8b 45 0c             	mov    0xc(%ebp),%eax
   16df6:	8b 00                	mov    (%eax),%eax
   16df8:	89 c2                	mov    %eax,%edx
   16dfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16dfd:	8b 40 14             	mov    0x14(%eax),%eax
   16e00:	39 c2                	cmp    %eax,%edx
   16e02:	0f 82 3a ff ff ff    	jb     16d42 <fatfs_readdir+0x17>
   16e08:	eb 01                	jmp    16e0b <fatfs_readdir+0xe0>
            break;
   16e0a:	90                   	nop
    }
    return -1;
   16e0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   16e10:	c9                   	leave  
   16e11:	c3                   	ret    

00016e12 <fatfs_closedir>:
int fatfs_closedir (fs_t* fs, DIR* dir)
{
   16e12:	55                   	push   %ebp
   16e13:	89 e5                	mov    %esp,%ebp
    return 0;
   16e15:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16e1a:	5d                   	pop    %ebp
   16e1b:	c3                   	ret    

00016e1c <cluster_set_next>:
int cluster_set_next(fat_t* fat, cluster_t curr, cluster_t next)
{   
   16e1c:	55                   	push   %ebp
   16e1d:	89 e5                	mov    %esp,%ebp
   16e1f:	83 ec 38             	sub    $0x38,%esp
   16e22:	8b 55 0c             	mov    0xc(%ebp),%edx
   16e25:	8b 45 10             	mov    0x10(%ebp),%eax
   16e28:	66 89 55 d4          	mov    %dx,-0x2c(%ebp)
   16e2c:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
     if (!clust_is_valid(curr)) {
   16e30:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
   16e34:	50                   	push   %eax
   16e35:	e8 ad f5 ff ff       	call   163e7 <clust_is_valid>
   16e3a:	83 c4 04             	add    $0x4,%esp
   16e3d:	85 c0                	test   %eax,%eax
   16e3f:	75 0a                	jne    16e4b <cluster_set_next+0x2f>
        return FAT_CLUSTER_INVALID;
   16e41:	b8 f8 ff 00 00       	mov    $0xfff8,%eax
   16e46:	e9 e7 00 00 00       	jmp    16f32 <cluster_set_next+0x116>
    }

    int offset = curr * sizeof(cluster_t);
   16e4b:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
   16e4f:	01 c0                	add    %eax,%eax
   16e51:	89 45 ec             	mov    %eax,-0x14(%ebp)
    int sector = offset / fat->bytes_per_sec;
   16e54:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16e57:	8b 55 08             	mov    0x8(%ebp),%edx
   16e5a:	8b 4a 0c             	mov    0xc(%edx),%ecx
   16e5d:	ba 00 00 00 00       	mov    $0x0,%edx
   16e62:	f7 f1                	div    %ecx
   16e64:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int off_sector = offset % fat->bytes_per_sec;
   16e67:	8b 45 ec             	mov    -0x14(%ebp),%eax
   16e6a:	8b 55 08             	mov    0x8(%ebp),%edx
   16e6d:	8b 4a 0c             	mov    0xc(%edx),%ecx
   16e70:	ba 00 00 00 00       	mov    $0x0,%edx
   16e75:	f7 f1                	div    %ecx
   16e77:	89 d0                	mov    %edx,%eax
   16e79:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (sector >= fat->tbl_sectors) {
   16e7c:	8b 45 08             	mov    0x8(%ebp),%eax
   16e7f:	8b 50 08             	mov    0x8(%eax),%edx
   16e82:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16e85:	39 c2                	cmp    %eax,%edx
   16e87:	77 1f                	ja     16ea8 <cluster_set_next+0x8c>
        log_printf("cluster too big. %d", curr);
   16e89:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
   16e8d:	83 ec 08             	sub    $0x8,%esp
   16e90:	50                   	push   %eax
   16e91:	68 66 9f 01 00       	push   $0x19f66
   16e96:	e8 b1 20 00 00       	call   18f4c <log_printf>
   16e9b:	83 c4 10             	add    $0x10,%esp
        return FAT_CLUSTER_INVALID;
   16e9e:	b8 f8 ff 00 00       	mov    $0xfff8,%eax
   16ea3:	e9 8a 00 00 00       	jmp    16f32 <cluster_set_next+0x116>
    }

    int err = bread_sector(fat, fat->tbl_start + sector);
   16ea8:	8b 45 08             	mov    0x8(%ebp),%eax
   16eab:	8b 10                	mov    (%eax),%edx
   16ead:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16eb0:	01 d0                	add    %edx,%eax
   16eb2:	83 ec 08             	sub    $0x8,%esp
   16eb5:	50                   	push   %eax
   16eb6:	ff 75 08             	pushl  0x8(%ebp)
   16eb9:	e8 52 f5 ff ff       	call   16410 <bread_sector>
   16ebe:	83 c4 10             	add    $0x10,%esp
   16ec1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (err < 0) {
   16ec4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   16ec8:	79 07                	jns    16ed1 <cluster_set_next+0xb5>
        return FAT_CLUSTER_INVALID;
   16eca:	b8 f8 ff 00 00       	mov    $0xfff8,%eax
   16ecf:	eb 61                	jmp    16f32 <cluster_set_next+0x116>
    }
    *(cluster_t*)(fat->fat_buffer + off_sector) = next;
   16ed1:	8b 45 08             	mov    0x8(%ebp),%eax
   16ed4:	8b 50 28             	mov    0x28(%eax),%edx
   16ed7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   16eda:	01 c2                	add    %eax,%edx
   16edc:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
   16ee0:	66 89 02             	mov    %ax,(%edx)
    for(int i = 0; i < 2; ++i)
   16ee3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   16eea:	eb 3b                	jmp    16f27 <cluster_set_next+0x10b>
    {
        err = bwrite_sector(fat, fat->tbl_start + sector);
   16eec:	8b 45 08             	mov    0x8(%ebp),%eax
   16eef:	8b 10                	mov    (%eax),%edx
   16ef1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16ef4:	01 d0                	add    %edx,%eax
   16ef6:	83 ec 08             	sub    $0x8,%esp
   16ef9:	50                   	push   %eax
   16efa:	ff 75 08             	pushl  0x8(%ebp)
   16efd:	e8 67 f5 ff ff       	call   16469 <bwrite_sector>
   16f02:	83 c4 10             	add    $0x10,%esp
   16f05:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if(err < 0)
   16f08:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   16f0c:	79 07                	jns    16f15 <cluster_set_next+0xf9>
            return -1;
   16f0e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16f13:	eb 1d                	jmp    16f32 <cluster_set_next+0x116>
        sector += fat->tbl_sectors;
   16f15:	8b 45 08             	mov    0x8(%ebp),%eax
   16f18:	8b 50 08             	mov    0x8(%eax),%edx
   16f1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   16f1e:	01 d0                	add    %edx,%eax
   16f20:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(int i = 0; i < 2; ++i)
   16f23:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   16f27:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
   16f2b:	7e bf                	jle    16eec <cluster_set_next+0xd0>
    }
    return 0;
   16f2d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   16f32:	c9                   	leave  
   16f33:	c3                   	ret    

00016f34 <cluster_free_chain>:
int cluster_free_chain(fat_t* fat, cluster_t start)
{
   16f34:	55                   	push   %ebp
   16f35:	89 e5                	mov    %esp,%ebp
   16f37:	83 ec 28             	sub    $0x28,%esp
   16f3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   16f3d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    while(clust_is_valid(start))
   16f41:	eb 34                	jmp    16f77 <cluster_free_chain+0x43>
    {
        cluster_t next = cluster_get_next(fat, start);
   16f43:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   16f47:	83 ec 08             	sub    $0x8,%esp
   16f4a:	50                   	push   %eax
   16f4b:	ff 75 08             	pushl  0x8(%ebp)
   16f4e:	e8 54 f5 ff ff       	call   164a7 <cluster_get_next>
   16f53:	83 c4 10             	add    $0x10,%esp
   16f56:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
        cluster_set_next(fat, start, CLUSTER_FAT_FREE);
   16f5a:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   16f5e:	83 ec 04             	sub    $0x4,%esp
   16f61:	6a 00                	push   $0x0
   16f63:	50                   	push   %eax
   16f64:	ff 75 08             	pushl  0x8(%ebp)
   16f67:	e8 b0 fe ff ff       	call   16e1c <cluster_set_next>
   16f6c:	83 c4 10             	add    $0x10,%esp
        start = next;
   16f6f:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
   16f73:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    while(clust_is_valid(start))
   16f77:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
   16f7b:	83 ec 0c             	sub    $0xc,%esp
   16f7e:	50                   	push   %eax
   16f7f:	e8 63 f4 ff ff       	call   163e7 <clust_is_valid>
   16f84:	83 c4 10             	add    $0x10,%esp
   16f87:	85 c0                	test   %eax,%eax
   16f89:	75 b8                	jne    16f43 <cluster_free_chain+0xf>
    }
}
   16f8b:	90                   	nop
   16f8c:	c9                   	leave  
   16f8d:	c3                   	ret    

00016f8e <fatfs_unlink>:
int fatfs_unlink (fs_t* fs, const char* name)
{
   16f8e:	55                   	push   %ebp
   16f8f:	89 e5                	mov    %esp,%ebp
   16f91:	83 ec 28             	sub    $0x28,%esp
    fat_t * fat = (fat_t *)fs->data;
   16f94:	8b 45 08             	mov    0x8(%ebp),%eax
   16f97:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
   16f9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    diritem_t * file_item = (diritem_t *)0;
   16fa0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    int p_index = -1;
   16fa7:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%ebp)

    // 遍历根目录的数据区，找到已经存在的匹配项
    for (int i = 0; i < fat->root_ent_cnt; i++) {
   16fae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   16fb5:	e9 b1 00 00 00       	jmp    1706b <fatfs_unlink+0xdd>
        diritem_t * item = read_dir_ent(fat, i);
   16fba:	83 ec 08             	sub    $0x8,%esp
   16fbd:	ff 75 f4             	pushl  -0xc(%ebp)
   16fc0:	ff 75 f0             	pushl  -0x10(%ebp)
   16fc3:	e8 34 fc ff ff       	call   16bfc <read_dir_ent>
   16fc8:	83 c4 10             	add    $0x10,%esp
   16fcb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (item == (diritem_t *)0) {
   16fce:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   16fd2:	75 0a                	jne    16fde <fatfs_unlink+0x50>
            return -1;
   16fd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   16fd9:	e9 a6 00 00 00       	jmp    17084 <fatfs_unlink+0xf6>
        }

         // 结束项，不需要再扫描了，同时index也不能往前走
        if (item->DIR_Name[0] == DIRITEM_NAME_END) {
   16fde:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16fe1:	0f b6 00             	movzbl (%eax),%eax
   16fe4:	84 c0                	test   %al,%al
   16fe6:	0f 84 92 00 00 00    	je     1707e <fatfs_unlink+0xf0>
            break;
        }

        // 只显示普通文件和目录，其它的不显示
        if (item->DIR_Name[0] == DIRITEM_NAME_FREE) {
   16fec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   16fef:	0f b6 00             	movzbl (%eax),%eax
   16ff2:	3c e5                	cmp    $0xe5,%al
   16ff4:	74 70                	je     17066 <fatfs_unlink+0xd8>
            continue;
        }

        // 找到要打开的目录
        if (item_name_match(item, name)) {
   16ff6:	83 ec 08             	sub    $0x8,%esp
   16ff9:	ff 75 0c             	pushl  0xc(%ebp)
   16ffc:	ff 75 e4             	pushl  -0x1c(%ebp)
   16fff:	e8 dc f1 ff ff       	call   161e0 <item_name_match>
   17004:	83 c4 10             	add    $0x10,%esp
   17007:	85 c0                	test   %eax,%eax
   17009:	74 5c                	je     17067 <fatfs_unlink+0xd9>
            int cluster = (item->DIR_FstClusHI << 16) | item->DIR_FstClusL0;
   1700b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1700e:	0f b7 40 14          	movzwl 0x14(%eax),%eax
   17012:	0f b7 c0             	movzwl %ax,%eax
   17015:	c1 e0 10             	shl    $0x10,%eax
   17018:	89 c2                	mov    %eax,%edx
   1701a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1701d:	0f b7 40 1a          	movzwl 0x1a(%eax),%eax
   17021:	0f b7 c0             	movzwl %ax,%eax
   17024:	09 d0                	or     %edx,%eax
   17026:	89 45 e0             	mov    %eax,-0x20(%ebp)
            cluster_free_chain(fat, cluster);
   17029:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1702c:	0f b7 c0             	movzwl %ax,%eax
   1702f:	83 ec 08             	sub    $0x8,%esp
   17032:	50                   	push   %eax
   17033:	ff 75 f0             	pushl  -0x10(%ebp)
   17036:	e8 f9 fe ff ff       	call   16f34 <cluster_free_chain>
   1703b:	83 c4 10             	add    $0x10,%esp
            kernel_memset(item, 0, sizeof(diritem_t));
   1703e:	83 ec 04             	sub    $0x4,%esp
   17041:	6a 20                	push   $0x20
   17043:	6a 00                	push   $0x0
   17045:	ff 75 e4             	pushl  -0x1c(%ebp)
   17048:	e8 55 19 00 00       	call   189a2 <kernel_memset>
   1704d:	83 c4 10             	add    $0x10,%esp
            return write_dir_ent(fat, item, i);
   17050:	83 ec 04             	sub    $0x4,%esp
   17053:	ff 75 f4             	pushl  -0xc(%ebp)
   17056:	ff 75 e4             	pushl  -0x1c(%ebp)
   17059:	ff 75 f0             	pushl  -0x10(%ebp)
   1705c:	e8 20 fc ff ff       	call   16c81 <write_dir_ent>
   17061:	83 c4 10             	add    $0x10,%esp
   17064:	eb 1e                	jmp    17084 <fatfs_unlink+0xf6>
            continue;
   17066:	90                   	nop
    for (int i = 0; i < fat->root_ent_cnt; i++) {
   17067:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1706b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1706e:	8b 50 14             	mov    0x14(%eax),%edx
   17071:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17074:	39 c2                	cmp    %eax,%edx
   17076:	0f 87 3e ff ff ff    	ja     16fba <fatfs_unlink+0x2c>
   1707c:	eb 01                	jmp    1707f <fatfs_unlink+0xf1>
            break;
   1707e:	90                   	nop
        } 
    }
    return -1; 
   1707f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   17084:	c9                   	leave  
   17085:	c3                   	ret    

00017086 <file_alloc>:
static mutex_t file_alloc_mutex;                // 访问file_table的互斥信号量

/**
 * @brief 分配一个文件描述符
 */
file_t * file_alloc (void) {
   17086:	55                   	push   %ebp
   17087:	89 e5                	mov    %esp,%ebp
   17089:	83 ec 18             	sub    $0x18,%esp
    file_t * file = (file_t *)0;
   1708c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&file_alloc_mutex);
   17093:	83 ec 0c             	sub    $0xc,%esp
   17096:	68 00 d3 05 00       	push   $0x5d300
   1709b:	e8 e4 11 00 00       	call   18284 <mutex_lock>
   170a0:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < FILE_TABLE_SIZE; i++) {
   170a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   170aa:	eb 47                	jmp    170f3 <file_alloc+0x6d>
        file_t * p_file = file_table + i;
   170ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
   170af:	89 d0                	mov    %edx,%eax
   170b1:	c1 e0 03             	shl    $0x3,%eax
   170b4:	01 d0                	add    %edx,%eax
   170b6:	c1 e0 03             	shl    $0x3,%eax
   170b9:	05 00 93 03 00       	add    $0x39300,%eax
   170be:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (p_file->ref == 0) {
   170c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   170c4:	8b 40 28             	mov    0x28(%eax),%eax
   170c7:	85 c0                	test   %eax,%eax
   170c9:	75 24                	jne    170ef <file_alloc+0x69>
			kernel_memset(p_file, 0, sizeof(file_t));
   170cb:	83 ec 04             	sub    $0x4,%esp
   170ce:	6a 48                	push   $0x48
   170d0:	6a 00                	push   $0x0
   170d2:	ff 75 ec             	pushl  -0x14(%ebp)
   170d5:	e8 c8 18 00 00       	call   189a2 <kernel_memset>
   170da:	83 c4 10             	add    $0x10,%esp
            p_file->ref = 1;
   170dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   170e0:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
			file = p_file;
   170e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   170ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   170ed:	eb 0d                	jmp    170fc <file_alloc+0x76>
    for (int i = 0; i < FILE_TABLE_SIZE; i++) {
   170ef:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   170f3:	81 7d f0 ff 07 00 00 	cmpl   $0x7ff,-0x10(%ebp)
   170fa:	7e b0                	jle    170ac <file_alloc+0x26>
        }
    }
    mutex_unlock(&file_alloc_mutex);
   170fc:	83 ec 0c             	sub    $0xc,%esp
   170ff:	68 00 d3 05 00       	push   $0x5d300
   17104:	e8 11 12 00 00       	call   1831a <mutex_unlock>
   17109:	83 c4 10             	add    $0x10,%esp
    return file;
   1710c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1710f:	c9                   	leave  
   17110:	c3                   	ret    

00017111 <file_free>:

/**
 * @brief 释放文件描述符
 */
void file_free (file_t * file) {
   17111:	55                   	push   %ebp
   17112:	89 e5                	mov    %esp,%ebp
   17114:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   17117:	83 ec 0c             	sub    $0xc,%esp
   1711a:	68 00 d3 05 00       	push   $0x5d300
   1711f:	e8 60 11 00 00       	call   18284 <mutex_lock>
   17124:	83 c4 10             	add    $0x10,%esp
    if (file->ref) {
   17127:	8b 45 08             	mov    0x8(%ebp),%eax
   1712a:	8b 40 28             	mov    0x28(%eax),%eax
   1712d:	85 c0                	test   %eax,%eax
   1712f:	74 0f                	je     17140 <file_free+0x2f>
        file->ref--;
   17131:	8b 45 08             	mov    0x8(%ebp),%eax
   17134:	8b 40 28             	mov    0x28(%eax),%eax
   17137:	8d 50 ff             	lea    -0x1(%eax),%edx
   1713a:	8b 45 08             	mov    0x8(%ebp),%eax
   1713d:	89 50 28             	mov    %edx,0x28(%eax)
    }
    mutex_unlock(&file_alloc_mutex);
   17140:	83 ec 0c             	sub    $0xc,%esp
   17143:	68 00 d3 05 00       	push   $0x5d300
   17148:	e8 cd 11 00 00       	call   1831a <mutex_unlock>
   1714d:	83 c4 10             	add    $0x10,%esp
}
   17150:	90                   	nop
   17151:	c9                   	leave  
   17152:	c3                   	ret    

00017153 <file_table_init>:

/**
 * @brief 文件表初始化
 */
void file_table_init (void) {
   17153:	55                   	push   %ebp
   17154:	89 e5                	mov    %esp,%ebp
   17156:	83 ec 08             	sub    $0x8,%esp
	// 文件描述符表初始化
	kernel_memset(&file_table, 0, sizeof(file_table));
   17159:	83 ec 04             	sub    $0x4,%esp
   1715c:	68 00 40 02 00       	push   $0x24000
   17161:	6a 00                	push   $0x0
   17163:	68 00 93 03 00       	push   $0x39300
   17168:	e8 35 18 00 00       	call   189a2 <kernel_memset>
   1716d:	83 c4 10             	add    $0x10,%esp
	mutex_init(&file_alloc_mutex);
   17170:	83 ec 0c             	sub    $0xc,%esp
   17173:	68 00 d3 05 00       	push   $0x5d300
   17178:	e8 d9 10 00 00       	call   18256 <mutex_init>
   1717d:	83 c4 10             	add    $0x10,%esp
}
   17180:	90                   	nop
   17181:	c9                   	leave  
   17182:	c3                   	ret    

00017183 <ref_inc>:

void ref_inc(file_t* file)
{
   17183:	55                   	push   %ebp
   17184:	89 e5                	mov    %esp,%ebp
   17186:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   17189:	83 ec 0c             	sub    $0xc,%esp
   1718c:	68 00 d3 05 00       	push   $0x5d300
   17191:	e8 ee 10 00 00       	call   18284 <mutex_lock>
   17196:	83 c4 10             	add    $0x10,%esp
    file->ref++;
   17199:	8b 45 08             	mov    0x8(%ebp),%eax
   1719c:	8b 40 28             	mov    0x28(%eax),%eax
   1719f:	8d 50 01             	lea    0x1(%eax),%edx
   171a2:	8b 45 08             	mov    0x8(%ebp),%eax
   171a5:	89 50 28             	mov    %edx,0x28(%eax)
    mutex_unlock(&file_alloc_mutex);
   171a8:	83 ec 0c             	sub    $0xc,%esp
   171ab:	68 00 d3 05 00       	push   $0x5d300
   171b0:	e8 65 11 00 00       	call   1831a <mutex_unlock>
   171b5:	83 c4 10             	add    $0x10,%esp
}
   171b8:	90                   	nop
   171b9:	c9                   	leave  
   171ba:	c3                   	ret    

000171bb <ref_dec>:

void ref_dec(file_t* file)
{
   171bb:	55                   	push   %ebp
   171bc:	89 e5                	mov    %esp,%ebp
   171be:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&file_alloc_mutex);
   171c1:	83 ec 0c             	sub    $0xc,%esp
   171c4:	68 00 d3 05 00       	push   $0x5d300
   171c9:	e8 b6 10 00 00       	call   18284 <mutex_lock>
   171ce:	83 c4 10             	add    $0x10,%esp
    file->ref--;
   171d1:	8b 45 08             	mov    0x8(%ebp),%eax
   171d4:	8b 40 28             	mov    0x28(%eax),%eax
   171d7:	8d 50 ff             	lea    -0x1(%eax),%edx
   171da:	8b 45 08             	mov    0x8(%ebp),%eax
   171dd:	89 50 28             	mov    %edx,0x28(%eax)
    mutex_unlock(&file_alloc_mutex);
   171e0:	83 ec 0c             	sub    $0xc,%esp
   171e3:	68 00 d3 05 00       	push   $0x5d300
   171e8:	e8 2d 11 00 00       	call   1831a <mutex_unlock>
   171ed:	83 c4 10             	add    $0x10,%esp
}
   171f0:	90                   	nop
   171f1:	c9                   	leave  
   171f2:	c3                   	ret    

000171f3 <inb>:
static inline uint8_t inb(uint16_t  port) {
   171f3:	55                   	push   %ebp
   171f4:	89 e5                	mov    %esp,%ebp
   171f6:	83 ec 14             	sub    $0x14,%esp
   171f9:	8b 45 08             	mov    0x8(%ebp),%eax
   171fc:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   17200:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   17204:	89 c2                	mov    %eax,%edx
   17206:	ec                   	in     (%dx),%al
   17207:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   1720a:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   1720e:	c9                   	leave  
   1720f:	c3                   	ret    

00017210 <inw>:
static inline uint16_t inw(uint16_t  port) {
   17210:	55                   	push   %ebp
   17211:	89 e5                	mov    %esp,%ebp
   17213:	83 ec 14             	sub    $0x14,%esp
   17216:	8b 45 08             	mov    0x8(%ebp),%eax
   17219:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   1721d:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   17221:	89 c2                	mov    %eax,%edx
   17223:	66 ed                	in     (%dx),%ax
   17225:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   17229:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   1722d:	c9                   	leave  
   1722e:	c3                   	ret    

0001722f <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   1722f:	55                   	push   %ebp
   17230:	89 e5                	mov    %esp,%ebp
   17232:	83 ec 08             	sub    $0x8,%esp
   17235:	8b 55 08             	mov    0x8(%ebp),%edx
   17238:	8b 45 0c             	mov    0xc(%ebp),%eax
   1723b:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   1723f:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   17242:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   17246:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   1724a:	ee                   	out    %al,(%dx)
}
   1724b:	90                   	nop
   1724c:	c9                   	leave  
   1724d:	c3                   	ret    

0001724e <list_node_next>:
static inline list_node_t * list_node_next(list_node_t *node) {
   1724e:	55                   	push   %ebp
   1724f:	89 e5                	mov    %esp,%ebp
    return node->next;
   17251:	8b 45 08             	mov    0x8(%ebp),%eax
   17254:	8b 40 04             	mov    0x4(%eax),%eax
}
   17257:	5d                   	pop    %ebp
   17258:	c3                   	ret    

00017259 <list_first>:
static inline list_node_t* list_first(list_t *list) {
   17259:	55                   	push   %ebp
   1725a:	89 e5                	mov    %esp,%ebp
    return list->first;
   1725c:	8b 45 08             	mov    0x8(%ebp),%eax
   1725f:	8b 00                	mov    (%eax),%eax
}
   17261:	5d                   	pop    %ebp
   17262:	c3                   	ret    

00017263 <read_disk>:
static void read_disk(int sector, int sector_count, uint8_t * buf) {
   17263:	55                   	push   %ebp
   17264:	89 e5                	mov    %esp,%ebp
   17266:	53                   	push   %ebx
   17267:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   1726a:	68 e0 00 00 00       	push   $0xe0
   1726f:	68 f6 01 00 00       	push   $0x1f6
   17274:	e8 b6 ff ff ff       	call   1722f <outb>
   17279:	83 c4 08             	add    $0x8,%esp
	outb(0x1F2, (uint8_t) (sector_count >> 8));
   1727c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1727f:	c1 f8 08             	sar    $0x8,%eax
   17282:	0f b6 c0             	movzbl %al,%eax
   17285:	50                   	push   %eax
   17286:	68 f2 01 00 00       	push   $0x1f2
   1728b:	e8 9f ff ff ff       	call   1722f <outb>
   17290:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		// LBA参数的24~31位
   17293:	8b 45 08             	mov    0x8(%ebp),%eax
   17296:	c1 f8 18             	sar    $0x18,%eax
   17299:	0f b6 c0             	movzbl %al,%eax
   1729c:	50                   	push   %eax
   1729d:	68 f3 01 00 00       	push   $0x1f3
   172a2:	e8 88 ff ff ff       	call   1722f <outb>
   172a7:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					// LBA参数的32~39位
   172aa:	6a 00                	push   $0x0
   172ac:	68 f4 01 00 00       	push   $0x1f4
   172b1:	e8 79 ff ff ff       	call   1722f <outb>
   172b6:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					// LBA参数的40~47位
   172b9:	6a 00                	push   $0x0
   172bb:	68 f5 01 00 00       	push   $0x1f5
   172c0:	e8 6a ff ff ff       	call   1722f <outb>
   172c5:	83 c4 08             	add    $0x8,%esp
    outb(0x1F2, (uint8_t) (sector_count));
   172c8:	8b 45 0c             	mov    0xc(%ebp),%eax
   172cb:	0f b6 c0             	movzbl %al,%eax
   172ce:	50                   	push   %eax
   172cf:	68 f2 01 00 00       	push   $0x1f2
   172d4:	e8 56 ff ff ff       	call   1722f <outb>
   172d9:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			// LBA参数的0~7位
   172dc:	8b 45 08             	mov    0x8(%ebp),%eax
   172df:	0f b6 c0             	movzbl %al,%eax
   172e2:	50                   	push   %eax
   172e3:	68 f3 01 00 00       	push   $0x1f3
   172e8:	e8 42 ff ff ff       	call   1722f <outb>
   172ed:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		// LBA参数的8~15位
   172f0:	8b 45 08             	mov    0x8(%ebp),%eax
   172f3:	c1 f8 08             	sar    $0x8,%eax
   172f6:	0f b6 c0             	movzbl %al,%eax
   172f9:	50                   	push   %eax
   172fa:	68 f4 01 00 00       	push   $0x1f4
   172ff:	e8 2b ff ff ff       	call   1722f <outb>
   17304:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		// LBA参数的16~23位
   17307:	8b 45 08             	mov    0x8(%ebp),%eax
   1730a:	c1 f8 10             	sar    $0x10,%eax
   1730d:	0f b6 c0             	movzbl %al,%eax
   17310:	50                   	push   %eax
   17311:	68 f5 01 00 00       	push   $0x1f5
   17316:	e8 14 ff ff ff       	call   1722f <outb>
   1731b:	83 c4 08             	add    $0x8,%esp
	outb(0x1F7, (uint8_t) 0x24);
   1731e:	6a 24                	push   $0x24
   17320:	68 f7 01 00 00       	push   $0x1f7
   17325:	e8 05 ff ff ff       	call   1722f <outb>
   1732a:	83 c4 08             	add    $0x8,%esp
	uint16_t *data_buf = (uint16_t*) buf;
   1732d:	8b 45 10             	mov    0x10(%ebp),%eax
   17330:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (sector_count-- > 0) {
   17333:	eb 4a                	jmp    1737f <read_disk+0x11c>
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   17335:	90                   	nop
   17336:	68 f7 01 00 00       	push   $0x1f7
   1733b:	e8 b3 fe ff ff       	call   171f3 <inb>
   17340:	83 c4 04             	add    $0x4,%esp
   17343:	0f b6 c0             	movzbl %al,%eax
   17346:	25 88 00 00 00       	and    $0x88,%eax
   1734b:	83 f8 08             	cmp    $0x8,%eax
   1734e:	75 e6                	jne    17336 <read_disk+0xd3>
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   17350:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17357:	eb 1d                	jmp    17376 <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   17359:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   1735c:	8d 43 02             	lea    0x2(%ebx),%eax
   1735f:	89 45 f8             	mov    %eax,-0x8(%ebp)
   17362:	68 f0 01 00 00       	push   $0x1f0
   17367:	e8 a4 fe ff ff       	call   17210 <inw>
   1736c:	83 c4 04             	add    $0x4,%esp
   1736f:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   17372:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17376:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1737d:	7e da                	jle    17359 <read_disk+0xf6>
	while (sector_count-- > 0) {
   1737f:	8b 45 0c             	mov    0xc(%ebp),%eax
   17382:	8d 50 ff             	lea    -0x1(%eax),%edx
   17385:	89 55 0c             	mov    %edx,0xc(%ebp)
   17388:	85 c0                	test   %eax,%eax
   1738a:	7f a9                	jg     17335 <read_disk+0xd2>
}
   1738c:	90                   	nop
   1738d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   17390:	c9                   	leave  
   17391:	c3                   	ret    

00017392 <path_to_num>:
static list_t   free_list;
static fs_t*     root_fs;
extern fs_op_t devfs_op;
extern fs_op_t fatfs_op;

int path_to_num (const char * path, int * num) {
   17392:	55                   	push   %ebp
   17393:	89 e5                	mov    %esp,%ebp
   17395:	83 ec 10             	sub    $0x10,%esp
	int n = 0;
   17398:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

	const char * c = path;
   1739f:	8b 45 08             	mov    0x8(%ebp),%eax
   173a2:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (*c && *c != '/') {
   173a5:	eb 23                	jmp    173ca <path_to_num+0x38>
		n = n * 10 + *c - '0';
   173a7:	8b 55 fc             	mov    -0x4(%ebp),%edx
   173aa:	89 d0                	mov    %edx,%eax
   173ac:	c1 e0 02             	shl    $0x2,%eax
   173af:	01 d0                	add    %edx,%eax
   173b1:	01 c0                	add    %eax,%eax
   173b3:	89 c2                	mov    %eax,%edx
   173b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   173b8:	0f b6 00             	movzbl (%eax),%eax
   173bb:	0f be c0             	movsbl %al,%eax
   173be:	01 d0                	add    %edx,%eax
   173c0:	83 e8 30             	sub    $0x30,%eax
   173c3:	89 45 fc             	mov    %eax,-0x4(%ebp)
		c++;
   173c6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	while (*c && *c != '/') {
   173ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
   173cd:	0f b6 00             	movzbl (%eax),%eax
   173d0:	84 c0                	test   %al,%al
   173d2:	74 0a                	je     173de <path_to_num+0x4c>
   173d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   173d7:	0f b6 00             	movzbl (%eax),%eax
   173da:	3c 2f                	cmp    $0x2f,%al
   173dc:	75 c9                	jne    173a7 <path_to_num+0x15>
	}
	*num = n;
   173de:	8b 45 0c             	mov    0xc(%ebp),%eax
   173e1:	8b 55 fc             	mov    -0x4(%ebp),%edx
   173e4:	89 10                	mov    %edx,(%eax)
	return 0;
   173e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   173eb:	c9                   	leave  
   173ec:	c3                   	ret    

000173ed <path_next_child>:

const char * path_next_child (const char * path) {
   173ed:	55                   	push   %ebp
   173ee:	89 e5                	mov    %esp,%ebp
   173f0:	83 ec 10             	sub    $0x10,%esp
   const char * c = path;
   173f3:	8b 45 08             	mov    0x8(%ebp),%eax
   173f6:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (*c && (*c++ == '/')) {}
   173f9:	90                   	nop
   173fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   173fd:	0f b6 00             	movzbl (%eax),%eax
   17400:	84 c0                	test   %al,%al
   17402:	74 10                	je     17414 <path_next_child+0x27>
   17404:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17407:	8d 50 01             	lea    0x1(%eax),%edx
   1740a:	89 55 fc             	mov    %edx,-0x4(%ebp)
   1740d:	0f b6 00             	movzbl (%eax),%eax
   17410:	3c 2f                	cmp    $0x2f,%al
   17412:	74 e6                	je     173fa <path_next_child+0xd>
    while (*c && (*c++ != '/')) {}
   17414:	90                   	nop
   17415:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17418:	0f b6 00             	movzbl (%eax),%eax
   1741b:	84 c0                	test   %al,%al
   1741d:	74 10                	je     1742f <path_next_child+0x42>
   1741f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17422:	8d 50 01             	lea    0x1(%eax),%edx
   17425:	89 55 fc             	mov    %edx,-0x4(%ebp)
   17428:	0f b6 00             	movzbl (%eax),%eax
   1742b:	3c 2f                	cmp    $0x2f,%al
   1742d:	75 e6                	jne    17415 <path_next_child+0x28>
    return *c ? c : (const char *)0;
   1742f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17432:	0f b6 00             	movzbl (%eax),%eax
   17435:	84 c0                	test   %al,%al
   17437:	74 05                	je     1743e <path_next_child+0x51>
   17439:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1743c:	eb 05                	jmp    17443 <path_next_child+0x56>
   1743e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17443:	c9                   	leave  
   17444:	c3                   	ret    

00017445 <path_begin_with>:
int path_begin_with (const char * path, const char * str) {
   17445:	55                   	push   %ebp
   17446:	89 e5                	mov    %esp,%ebp
   17448:	83 ec 10             	sub    $0x10,%esp
	const char * s1 = path, * s2 = str;
   1744b:	8b 45 08             	mov    0x8(%ebp),%eax
   1744e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   17451:	8b 45 0c             	mov    0xc(%ebp),%eax
   17454:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (*s1 && *s2 && (*s1 == *s2)) {
   17457:	eb 08                	jmp    17461 <path_begin_with+0x1c>
		s1++;
   17459:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
		s2++;
   1745d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	while (*s1 && *s2 && (*s1 == *s2)) {
   17461:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17464:	0f b6 00             	movzbl (%eax),%eax
   17467:	84 c0                	test   %al,%al
   17469:	74 1a                	je     17485 <path_begin_with+0x40>
   1746b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1746e:	0f b6 00             	movzbl (%eax),%eax
   17471:	84 c0                	test   %al,%al
   17473:	74 10                	je     17485 <path_begin_with+0x40>
   17475:	8b 45 fc             	mov    -0x4(%ebp),%eax
   17478:	0f b6 10             	movzbl (%eax),%edx
   1747b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1747e:	0f b6 00             	movzbl (%eax),%eax
   17481:	38 c2                	cmp    %al,%dl
   17483:	74 d4                	je     17459 <path_begin_with+0x14>
	}

	return *s2 == '\0';
   17485:	8b 45 f8             	mov    -0x8(%ebp),%eax
   17488:	0f b6 00             	movzbl (%eax),%eax
   1748b:	84 c0                	test   %al,%al
   1748d:	0f 94 c0             	sete   %al
   17490:	0f b6 c0             	movzbl %al,%eax
}
   17493:	c9                   	leave  
   17494:	c3                   	ret    

00017495 <is_valid_path>:

static int is_valid_path(char * path)
{
   17495:	55                   	push   %ebp
   17496:	89 e5                	mov    %esp,%ebp
    if(path == (char*)0 || path[0] == '\0')
   17498:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1749c:	74 0a                	je     174a8 <is_valid_path+0x13>
   1749e:	8b 45 08             	mov    0x8(%ebp),%eax
   174a1:	0f b6 00             	movzbl (%eax),%eax
   174a4:	84 c0                	test   %al,%al
   174a6:	75 07                	jne    174af <is_valid_path+0x1a>
    {
        return 0;
   174a8:	b8 00 00 00 00       	mov    $0x0,%eax
   174ad:	eb 05                	jmp    174b4 <is_valid_path+0x1f>
    }
    return 1;
   174af:	b8 01 00 00 00       	mov    $0x1,%eax
}
   174b4:	5d                   	pop    %ebp
   174b5:	c3                   	ret    

000174b6 <fs_protect>:
void fs_protect(fs_t* fs)
{
   174b6:	55                   	push   %ebp
   174b7:	89 e5                	mov    %esp,%ebp
   174b9:	83 ec 08             	sub    $0x8,%esp
    if(fs->mutex)
   174bc:	8b 45 08             	mov    0x8(%ebp),%eax
   174bf:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   174c5:	85 c0                	test   %eax,%eax
   174c7:	74 15                	je     174de <fs_protect+0x28>
        mutex_lock(fs->mutex);
   174c9:	8b 45 08             	mov    0x8(%ebp),%eax
   174cc:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   174d2:	83 ec 0c             	sub    $0xc,%esp
   174d5:	50                   	push   %eax
   174d6:	e8 a9 0d 00 00       	call   18284 <mutex_lock>
   174db:	83 c4 10             	add    $0x10,%esp
}
   174de:	90                   	nop
   174df:	c9                   	leave  
   174e0:	c3                   	ret    

000174e1 <fs_unprotect>:
void fs_unprotect(fs_t* fs)
{
   174e1:	55                   	push   %ebp
   174e2:	89 e5                	mov    %esp,%ebp
   174e4:	83 ec 08             	sub    $0x8,%esp
    if(fs->mutex)
   174e7:	8b 45 08             	mov    0x8(%ebp),%eax
   174ea:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   174f0:	85 c0                	test   %eax,%eax
   174f2:	74 15                	je     17509 <fs_unprotect+0x28>
        mutex_unlock(fs->mutex);
   174f4:	8b 45 08             	mov    0x8(%ebp),%eax
   174f7:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   174fd:	83 ec 0c             	sub    $0xc,%esp
   17500:	50                   	push   %eax
   17501:	e8 14 0e 00 00       	call   1831a <mutex_unlock>
   17506:	83 c4 10             	add    $0x10,%esp
}
   17509:	90                   	nop
   1750a:	c9                   	leave  
   1750b:	c3                   	ret    

0001750c <sys_open>:
int sys_open(char* name, int flag, ...)
{   
   1750c:	55                   	push   %ebp
   1750d:	89 e5                	mov    %esp,%ebp
   1750f:	83 ec 28             	sub    $0x28,%esp

    file_t* file = file_alloc();
   17512:	e8 6f fb ff ff       	call   17086 <file_alloc>
   17517:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(file == (file_t*)0)
   1751a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1751e:	75 15                	jne    17535 <sys_open+0x29>
    {
        log_printf("file table err");
   17520:	83 ec 0c             	sub    $0xc,%esp
   17523:	68 7c 9f 01 00       	push   $0x19f7c
   17528:	e8 1f 1a 00 00       	call   18f4c <log_printf>
   1752d:	83 c4 10             	add    $0x10,%esp
        goto open_failed;
   17530:	e9 64 01 00 00       	jmp    17699 <sys_open+0x18d>
    }
    task_t* task = task_manager.curr_task;
   17535:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   1753a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int fd = -1;
   1753d:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
    fd = task_alloc_fd(file);
   17544:	83 ec 0c             	sub    $0xc,%esp
   17547:	ff 75 e8             	pushl  -0x18(%ebp)
   1754a:	e8 6c 9d ff ff       	call   112bb <task_alloc_fd>
   1754f:	83 c4 10             	add    $0x10,%esp
   17552:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(fd < 0)
   17555:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17559:	79 15                	jns    17570 <sys_open+0x64>
    {
        log_printf("task file table err");
   1755b:	83 ec 0c             	sub    $0xc,%esp
   1755e:	68 8b 9f 01 00       	push   $0x19f8b
   17563:	e8 e4 19 00 00       	call   18f4c <log_printf>
   17568:	83 c4 10             	add    $0x10,%esp
        goto open_failed;
   1756b:	e9 29 01 00 00       	jmp    17699 <sys_open+0x18d>
    }
    
    list_node_t* node = list_first(&mounted_list);
   17570:	83 ec 0c             	sub    $0xc,%esp
   17573:	68 20 d3 05 00       	push   $0x5d320
   17578:	e8 dc fc ff ff       	call   17259 <list_first>
   1757d:	83 c4 10             	add    $0x10,%esp
   17580:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fs_t* fs = (fs_t*)0;
   17583:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(node)
   1758a:	eb 47                	jmp    175d3 <sys_open+0xc7>
    {
        fs_t* curr = LIST_NODE_PARENT(node, fs_t, node);
   1758c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   17590:	74 0a                	je     1759c <sys_open+0x90>
   17592:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17595:	2d 90 00 00 00       	sub    $0x90,%eax
   1759a:	eb 05                	jmp    175a1 <sys_open+0x95>
   1759c:	b8 00 00 00 00       	mov    $0x0,%eax
   175a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
        if(path_begin_with(name, curr->mount_point))
   175a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   175a7:	83 ec 08             	sub    $0x8,%esp
   175aa:	50                   	push   %eax
   175ab:	ff 75 08             	pushl  0x8(%ebp)
   175ae:	e8 92 fe ff ff       	call   17445 <path_begin_with>
   175b3:	83 c4 10             	add    $0x10,%esp
   175b6:	85 c0                	test   %eax,%eax
   175b8:	74 08                	je     175c2 <sys_open+0xb6>
        {
            fs = curr;
   175ba:	8b 45 e0             	mov    -0x20(%ebp),%eax
   175bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
            break;
   175c0:	eb 17                	jmp    175d9 <sys_open+0xcd>
        }
        node = list_node_next(node);
   175c2:	83 ec 0c             	sub    $0xc,%esp
   175c5:	ff 75 f0             	pushl  -0x10(%ebp)
   175c8:	e8 81 fc ff ff       	call   1724e <list_node_next>
   175cd:	83 c4 10             	add    $0x10,%esp
   175d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while(node)
   175d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   175d7:	75 b3                	jne    1758c <sys_open+0x80>
    }
    if(fs)
   175d9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   175dd:	74 13                	je     175f2 <sys_open+0xe6>
    {
        name = path_next_child(name);
   175df:	83 ec 0c             	sub    $0xc,%esp
   175e2:	ff 75 08             	pushl  0x8(%ebp)
   175e5:	e8 03 fe ff ff       	call   173ed <path_next_child>
   175ea:	83 c4 10             	add    $0x10,%esp
   175ed:	89 45 08             	mov    %eax,0x8(%ebp)
   175f0:	eb 08                	jmp    175fa <sys_open+0xee>
    }
    else{
        fs = root_fs;
   175f2:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   175f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    file->fs = fs;    
   175fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   175fd:	8b 55 ec             	mov    -0x14(%ebp),%edx
   17600:	89 50 44             	mov    %edx,0x44(%eax)
    file ->ref = 1;
   17603:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17606:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
    file->mode = flag;
   1760d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17610:	8b 55 0c             	mov    0xc(%ebp),%edx
   17613:	89 50 40             	mov    %edx,0x40(%eax)
    kernel_strncpy(file->file_name, name, FILE_NAME_SIZE);
   17616:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17619:	83 ec 04             	sub    $0x4,%esp
   1761c:	6a 20                	push   $0x20
   1761e:	ff 75 08             	pushl  0x8(%ebp)
   17621:	50                   	push   %eax
   17622:	e8 07 12 00 00       	call   1882e <kernel_strncpy>
   17627:	83 c4 10             	add    $0x10,%esp
    fs_protect(fs);
   1762a:	83 ec 0c             	sub    $0xc,%esp
   1762d:	ff 75 ec             	pushl  -0x14(%ebp)
   17630:	e8 81 fe ff ff       	call   174b6 <fs_protect>
   17635:	83 c4 10             	add    $0x10,%esp
    int err = fs->op->open(fs, name, file);
   17638:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1763b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   17641:	8b 40 08             	mov    0x8(%eax),%eax
   17644:	83 ec 04             	sub    $0x4,%esp
   17647:	ff 75 e8             	pushl  -0x18(%ebp)
   1764a:	ff 75 08             	pushl  0x8(%ebp)
   1764d:	ff 75 ec             	pushl  -0x14(%ebp)
   17650:	ff d0                	call   *%eax
   17652:	83 c4 10             	add    $0x10,%esp
   17655:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (err < 0) {
   17658:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   1765c:	79 28                	jns    17686 <sys_open+0x17a>
		fs_unprotect(fs);
   1765e:	83 ec 0c             	sub    $0xc,%esp
   17661:	ff 75 ec             	pushl  -0x14(%ebp)
   17664:	e8 78 fe ff ff       	call   174e1 <fs_unprotect>
   17669:	83 c4 10             	add    $0x10,%esp
		log_printf("open %s failed.", name);
   1766c:	83 ec 08             	sub    $0x8,%esp
   1766f:	ff 75 08             	pushl  0x8(%ebp)
   17672:	68 9f 9f 01 00       	push   $0x19f9f
   17677:	e8 d0 18 00 00       	call   18f4c <log_printf>
   1767c:	83 c4 10             	add    $0x10,%esp
		return -1;
   1767f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17684:	eb 40                	jmp    176c6 <sys_open+0x1ba>
	}
    fs_unprotect(fs);
   17686:	83 ec 0c             	sub    $0xc,%esp
   17689:	ff 75 ec             	pushl  -0x14(%ebp)
   1768c:	e8 50 fe ff ff       	call   174e1 <fs_unprotect>
   17691:	83 c4 10             	add    $0x10,%esp
    return fd;
   17694:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17697:	eb 2d                	jmp    176c6 <sys_open+0x1ba>
open_failed:
    if(file)
   17699:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1769d:	74 0e                	je     176ad <sys_open+0x1a1>
        file_free(file);
   1769f:	83 ec 0c             	sub    $0xc,%esp
   176a2:	ff 75 e8             	pushl  -0x18(%ebp)
   176a5:	e8 67 fa ff ff       	call   17111 <file_free>
   176aa:	83 c4 10             	add    $0x10,%esp
    if(fd)
   176ad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   176b1:	74 0e                	je     176c1 <sys_open+0x1b5>
        task_remove_fd(fd);
   176b3:	83 ec 0c             	sub    $0xc,%esp
   176b6:	ff 75 f4             	pushl  -0xc(%ebp)
   176b9:	e8 50 9c ff ff       	call   1130e <task_remove_fd>
   176be:	83 c4 10             	add    $0x10,%esp
    return -1;
   176c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
   176c6:	c9                   	leave  
   176c7:	c3                   	ret    

000176c8 <sys_read>:
    
int sys_read(int file, char* buf, int size)
{   
   176c8:	55                   	push   %ebp
   176c9:	89 e5                	mov    %esp,%ebp
   176cb:	83 ec 18             	sub    $0x18,%esp
  
    if(is_file_bad(file))
   176ce:	83 ec 0c             	sub    $0xc,%esp
   176d1:	ff 75 08             	pushl  0x8(%ebp)
   176d4:	e8 01 06 00 00       	call   17cda <is_file_bad>
   176d9:	83 c4 10             	add    $0x10,%esp
   176dc:	85 c0                	test   %eax,%eax
   176de:	74 1a                	je     176fa <sys_read+0x32>
	{
        log_printf("file(%d) is not valid.", file);
   176e0:	83 ec 08             	sub    $0x8,%esp
   176e3:	ff 75 08             	pushl  0x8(%ebp)
   176e6:	68 af 9f 01 00       	push   $0x19faf
   176eb:	e8 5c 18 00 00       	call   18f4c <log_printf>
   176f0:	83 c4 10             	add    $0x10,%esp
		return -1;
   176f3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   176f8:	eb 54                	jmp    1774e <sys_read+0x86>
	}
    file_t * p_file = task_file(file);
   176fa:	83 ec 0c             	sub    $0xc,%esp
   176fd:	ff 75 08             	pushl  0x8(%ebp)
   17700:	e8 86 9b ff ff       	call   1128b <task_file>
   17705:	83 c4 10             	add    $0x10,%esp
   17708:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file) {
   1770b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1770f:	75 17                	jne    17728 <sys_read+0x60>
        log_printf("file not opened");
   17711:	83 ec 0c             	sub    $0xc,%esp
   17714:	68 c6 9f 01 00       	push   $0x19fc6
   17719:	e8 2e 18 00 00       	call   18f4c <log_printf>
   1771e:	83 c4 10             	add    $0x10,%esp
        return -1;
   17721:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17726:	eb 26                	jmp    1774e <sys_read+0x86>
    }
 
    fs_t* fs = p_file->fs;
   17728:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1772b:	8b 40 44             	mov    0x44(%eax),%eax
   1772e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return fs->op->read(buf, size, p_file);
   17731:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17734:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   1773a:	8b 40 0c             	mov    0xc(%eax),%eax
   1773d:	83 ec 04             	sub    $0x4,%esp
   17740:	ff 75 f4             	pushl  -0xc(%ebp)
   17743:	ff 75 10             	pushl  0x10(%ebp)
   17746:	ff 75 0c             	pushl  0xc(%ebp)
   17749:	ff d0                	call   *%eax
   1774b:	83 c4 10             	add    $0x10,%esp
    
}
   1774e:	c9                   	leave  
   1774f:	c3                   	ret    

00017750 <sys_write>:
int sys_write(int file, char* buf, int size)
{
   17750:	55                   	push   %ebp
   17751:	89 e5                	mov    %esp,%ebp
   17753:	83 ec 18             	sub    $0x18,%esp
    // file = 0;		

    file_t * p_file = task_file(file);
   17756:	83 ec 0c             	sub    $0xc,%esp
   17759:	ff 75 08             	pushl  0x8(%ebp)
   1775c:	e8 2a 9b ff ff       	call   1128b <task_file>
   17761:	83 c4 10             	add    $0x10,%esp
   17764:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file) {
   17767:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1776b:	75 17                	jne    17784 <sys_write+0x34>
        log_printf("file not opened");
   1776d:	83 ec 0c             	sub    $0xc,%esp
   17770:	68 c6 9f 01 00       	push   $0x19fc6
   17775:	e8 d2 17 00 00       	call   18f4c <log_printf>
   1777a:	83 c4 10             	add    $0x10,%esp
        return -1;
   1777d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17782:	eb 26                	jmp    177aa <sys_write+0x5a>
    }

    fs_t* fs = p_file->fs;
   17784:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17787:	8b 40 44             	mov    0x44(%eax),%eax
   1778a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return fs->op->write(buf, size, p_file);
   1778d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17790:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   17796:	8b 40 10             	mov    0x10(%eax),%eax
   17799:	83 ec 04             	sub    $0x4,%esp
   1779c:	ff 75 f4             	pushl  -0xc(%ebp)
   1779f:	ff 75 10             	pushl  0x10(%ebp)
   177a2:	ff 75 0c             	pushl  0xc(%ebp)
   177a5:	ff d0                	call   *%eax
   177a7:	83 c4 10             	add    $0x10,%esp

}
   177aa:	c9                   	leave  
   177ab:	c3                   	ret    

000177ac <sys_lseek>:
int sys_lseek(int file, int ptr, int dir){
   177ac:	55                   	push   %ebp
   177ad:	89 e5                	mov    %esp,%ebp
   177af:	83 ec 18             	sub    $0x18,%esp
    

    if(is_file_bad(file))
   177b2:	83 ec 0c             	sub    $0xc,%esp
   177b5:	ff 75 08             	pushl  0x8(%ebp)
   177b8:	e8 1d 05 00 00       	call   17cda <is_file_bad>
   177bd:	83 c4 10             	add    $0x10,%esp
   177c0:	85 c0                	test   %eax,%eax
   177c2:	74 1a                	je     177de <sys_lseek+0x32>
	{
        log_printf("file(%d) is not valid.", file);
   177c4:	83 ec 08             	sub    $0x8,%esp
   177c7:	ff 75 08             	pushl  0x8(%ebp)
   177ca:	68 af 9f 01 00       	push   $0x19faf
   177cf:	e8 78 17 00 00       	call   18f4c <log_printf>
   177d4:	83 c4 10             	add    $0x10,%esp
		return -1;
   177d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   177dc:	eb 55                	jmp    17833 <sys_lseek+0x87>
	}
    file_t * p_file = task_file(file);
   177de:	83 ec 0c             	sub    $0xc,%esp
   177e1:	ff 75 08             	pushl  0x8(%ebp)
   177e4:	e8 a2 9a ff ff       	call   1128b <task_file>
   177e9:	83 c4 10             	add    $0x10,%esp
   177ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file) {
   177ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   177f3:	75 17                	jne    1780c <sys_lseek+0x60>
        log_printf("file not opened");
   177f5:	83 ec 0c             	sub    $0xc,%esp
   177f8:	68 c6 9f 01 00       	push   $0x19fc6
   177fd:	e8 4a 17 00 00       	call   18f4c <log_printf>
   17802:	83 c4 10             	add    $0x10,%esp
        return -1;
   17805:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1780a:	eb 27                	jmp    17833 <sys_lseek+0x87>
    }
    fs_t* fs = p_file->fs;
   1780c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1780f:	8b 40 44             	mov    0x44(%eax),%eax
   17812:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return fs->op->seek(p_file, ptr, dir);
   17815:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17818:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   1781e:	8b 40 18             	mov    0x18(%eax),%eax
   17821:	8b 55 0c             	mov    0xc(%ebp),%edx
   17824:	83 ec 04             	sub    $0x4,%esp
   17827:	ff 75 10             	pushl  0x10(%ebp)
   1782a:	52                   	push   %edx
   1782b:	ff 75 f4             	pushl  -0xc(%ebp)
   1782e:	ff d0                	call   *%eax
   17830:	83 c4 10             	add    $0x10,%esp
    
}
   17833:	c9                   	leave  
   17834:	c3                   	ret    

00017835 <sys_close>:
int sys_close(int file){
   17835:	55                   	push   %ebp
   17836:	89 e5                	mov    %esp,%ebp
   17838:	83 ec 18             	sub    $0x18,%esp


  
    if(is_file_bad(file))
   1783b:	83 ec 0c             	sub    $0xc,%esp
   1783e:	ff 75 08             	pushl  0x8(%ebp)
   17841:	e8 94 04 00 00       	call   17cda <is_file_bad>
   17846:	83 c4 10             	add    $0x10,%esp
   17849:	85 c0                	test   %eax,%eax
   1784b:	74 1d                	je     1786a <sys_close+0x35>
	{
        log_printf("file(%d) is not valid.", file);
   1784d:	83 ec 08             	sub    $0x8,%esp
   17850:	ff 75 08             	pushl  0x8(%ebp)
   17853:	68 af 9f 01 00       	push   $0x19faf
   17858:	e8 ef 16 00 00       	call   18f4c <log_printf>
   1785d:	83 c4 10             	add    $0x10,%esp
		return -1;
   17860:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17865:	e9 c8 00 00 00       	jmp    17932 <sys_close+0xfd>
	}
    file_t * p_file = task_file(file);
   1786a:	83 ec 0c             	sub    $0xc,%esp
   1786d:	ff 75 08             	pushl  0x8(%ebp)
   17870:	e8 16 9a ff ff       	call   1128b <task_file>
   17875:	83 c4 10             	add    $0x10,%esp
   17878:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file) {
   1787b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1787f:	75 1a                	jne    1789b <sys_close+0x66>
        log_printf("file not opened");
   17881:	83 ec 0c             	sub    $0xc,%esp
   17884:	68 c6 9f 01 00       	push   $0x19fc6
   17889:	e8 be 16 00 00       	call   18f4c <log_printf>
   1788e:	83 c4 10             	add    $0x10,%esp
        return -1;
   17891:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17896:	e9 97 00 00 00       	jmp    17932 <sys_close+0xfd>
    }
    Assert(p_file->ref > 0);
   1789b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1789e:	8b 40 28             	mov    0x28(%eax),%eax
   178a1:	85 c0                	test   %eax,%eax
   178a3:	7f 1c                	jg     178c1 <sys_close+0x8c>
   178a5:	68 d6 9f 01 00       	push   $0x19fd6
   178aa:	68 c8 a0 01 00       	push   $0x1a0c8
   178af:	68 be 00 00 00       	push   $0xbe
   178b4:	68 e8 9f 01 00       	push   $0x19fe8
   178b9:	e8 31 14 00 00       	call   18cef <pannic>
   178be:	83 c4 10             	add    $0x10,%esp
    if (p_file->ref-- == 1) {
   178c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   178c4:	8b 40 28             	mov    0x28(%eax),%eax
   178c7:	8d 48 ff             	lea    -0x1(%eax),%ecx
   178ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
   178cd:	89 4a 28             	mov    %ecx,0x28(%edx)
   178d0:	83 f8 01             	cmp    $0x1,%eax
   178d3:	75 4a                	jne    1791f <sys_close+0xea>
		fs_t * fs = p_file->fs;
   178d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   178d8:	8b 40 44             	mov    0x44(%eax),%eax
   178db:	89 45 f0             	mov    %eax,-0x10(%ebp)

		fs_protect(fs);
   178de:	83 ec 0c             	sub    $0xc,%esp
   178e1:	ff 75 f0             	pushl  -0x10(%ebp)
   178e4:	e8 cd fb ff ff       	call   174b6 <fs_protect>
   178e9:	83 c4 10             	add    $0x10,%esp
		fs->op->close(p_file);
   178ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   178ef:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   178f5:	8b 40 14             	mov    0x14(%eax),%eax
   178f8:	83 ec 0c             	sub    $0xc,%esp
   178fb:	ff 75 f4             	pushl  -0xc(%ebp)
   178fe:	ff d0                	call   *%eax
   17900:	83 c4 10             	add    $0x10,%esp
		fs_unprotect(fs);
   17903:	83 ec 0c             	sub    $0xc,%esp
   17906:	ff 75 f0             	pushl  -0x10(%ebp)
   17909:	e8 d3 fb ff ff       	call   174e1 <fs_unprotect>
   1790e:	83 c4 10             	add    $0x10,%esp
	    file_free(p_file);
   17911:	83 ec 0c             	sub    $0xc,%esp
   17914:	ff 75 f4             	pushl  -0xc(%ebp)
   17917:	e8 f5 f7 ff ff       	call   17111 <file_free>
   1791c:	83 c4 10             	add    $0x10,%esp
	}

	task_remove_fd(file);
   1791f:	83 ec 0c             	sub    $0xc,%esp
   17922:	ff 75 08             	pushl  0x8(%ebp)
   17925:	e8 e4 99 ff ff       	call   1130e <task_remove_fd>
   1792a:	83 c4 10             	add    $0x10,%esp
    return 0;
   1792d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17932:	c9                   	leave  
   17933:	c3                   	ret    

00017934 <sys_isatty>:



int sys_isatty(int file) {
   17934:	55                   	push   %ebp
   17935:	89 e5                	mov    %esp,%ebp
   17937:	83 ec 18             	sub    $0x18,%esp
	if(is_file_bad(file))
   1793a:	83 ec 0c             	sub    $0xc,%esp
   1793d:	ff 75 08             	pushl  0x8(%ebp)
   17940:	e8 95 03 00 00       	call   17cda <is_file_bad>
   17945:	83 c4 10             	add    $0x10,%esp
   17948:	85 c0                	test   %eax,%eax
   1794a:	74 1a                	je     17966 <sys_isatty+0x32>
	{
        log_printf("file(%d) is not valid.", file);
   1794c:	83 ec 08             	sub    $0x8,%esp
   1794f:	ff 75 08             	pushl  0x8(%ebp)
   17952:	68 af 9f 01 00       	push   $0x19faf
   17957:	e8 f0 15 00 00       	call   18f4c <log_printf>
   1795c:	83 c4 10             	add    $0x10,%esp
		return -1;
   1795f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17964:	eb 3d                	jmp    179a3 <sys_isatty+0x6f>
	}
    file_t * p_file = task_file(file);
   17966:	83 ec 0c             	sub    $0xc,%esp
   17969:	ff 75 08             	pushl  0x8(%ebp)
   1796c:	e8 1a 99 ff ff       	call   1128b <task_file>
   17971:	83 c4 10             	add    $0x10,%esp
   17974:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file) {
   17977:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1797b:	75 17                	jne    17994 <sys_isatty+0x60>
        log_printf("file not opened");
   1797d:	83 ec 0c             	sub    $0xc,%esp
   17980:	68 c6 9f 01 00       	push   $0x19fc6
   17985:	e8 c2 15 00 00       	call   18f4c <log_printf>
   1798a:	83 c4 10             	add    $0x10,%esp
        return -1;
   1798d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17992:	eb 0f                	jmp    179a3 <sys_isatty+0x6f>
    }
    return p_file->type == FILE_TTY;
   17994:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17997:	8b 40 20             	mov    0x20(%eax),%eax
   1799a:	83 f8 01             	cmp    $0x1,%eax
   1799d:	0f 94 c0             	sete   %al
   179a0:	0f b6 c0             	movzbl %al,%eax
}
   179a3:	c9                   	leave  
   179a4:	c3                   	ret    

000179a5 <sys_fstat>:



int sys_fstat(int file, struct stat *st) {
   179a5:	55                   	push   %ebp
   179a6:	89 e5                	mov    %esp,%ebp
   179a8:	83 ec 18             	sub    $0x18,%esp
    if(is_file_bad(file))
   179ab:	83 ec 0c             	sub    $0xc,%esp
   179ae:	ff 75 08             	pushl  0x8(%ebp)
   179b1:	e8 24 03 00 00       	call   17cda <is_file_bad>
   179b6:	83 c4 10             	add    $0x10,%esp
   179b9:	85 c0                	test   %eax,%eax
   179bb:	74 1a                	je     179d7 <sys_fstat+0x32>
	{
        log_printf("file(%d) is not valid.", file);
   179bd:	83 ec 08             	sub    $0x8,%esp
   179c0:	ff 75 08             	pushl  0x8(%ebp)
   179c3:	68 af 9f 01 00       	push   $0x19faf
   179c8:	e8 7f 15 00 00       	call   18f4c <log_printf>
   179cd:	83 c4 10             	add    $0x10,%esp
		return -1;
   179d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   179d5:	eb 68                	jmp    17a3f <sys_fstat+0x9a>
	}
    file_t * p_file = task_file(file);
   179d7:	83 ec 0c             	sub    $0xc,%esp
   179da:	ff 75 08             	pushl  0x8(%ebp)
   179dd:	e8 a9 98 ff ff       	call   1128b <task_file>
   179e2:	83 c4 10             	add    $0x10,%esp
   179e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (!p_file) {
   179e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   179ec:	75 17                	jne    17a05 <sys_fstat+0x60>
        log_printf("file not opened");
   179ee:	83 ec 0c             	sub    $0xc,%esp
   179f1:	68 c6 9f 01 00       	push   $0x19fc6
   179f6:	e8 51 15 00 00       	call   18f4c <log_printf>
   179fb:	83 c4 10             	add    $0x10,%esp
        return -1;
   179fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17a03:	eb 3a                	jmp    17a3f <sys_fstat+0x9a>
    }
    kernel_memset(st, 0, sizeof(struct stat));
   17a05:	83 ec 04             	sub    $0x4,%esp
   17a08:	6a 48                	push   $0x48
   17a0a:	6a 00                	push   $0x0
   17a0c:	ff 75 0c             	pushl  0xc(%ebp)
   17a0f:	e8 8e 0f 00 00       	call   189a2 <kernel_memset>
   17a14:	83 c4 10             	add    $0x10,%esp
    fs_t* fs = p_file->fs;
   17a17:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17a1a:	8b 40 44             	mov    0x44(%eax),%eax
   17a1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fs->op->stat(p_file, st);
   17a20:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17a23:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   17a29:	8b 40 1c             	mov    0x1c(%eax),%eax
   17a2c:	83 ec 08             	sub    $0x8,%esp
   17a2f:	ff 75 0c             	pushl  0xc(%ebp)
   17a32:	ff 75 f4             	pushl  -0xc(%ebp)
   17a35:	ff d0                	call   *%eax
   17a37:	83 c4 10             	add    $0x10,%esp
    return -1;
   17a3a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   17a3f:	c9                   	leave  
   17a40:	c3                   	ret    

00017a41 <mount_list_init>:
static void mount_list_init(void)
{
   17a41:	55                   	push   %ebp
   17a42:	89 e5                	mov    %esp,%ebp
   17a44:	83 ec 18             	sub    $0x18,%esp
    list_init(&mounted_list);
   17a47:	83 ec 0c             	sub    $0xc,%esp
   17a4a:	68 20 d3 05 00       	push   $0x5d320
   17a4f:	e8 e4 12 00 00       	call   18d38 <list_init>
   17a54:	83 c4 10             	add    $0x10,%esp
    kernel_memset((void*)fs_table, 0, FS_TABLE_SIZE);
   17a57:	83 ec 04             	sub    $0x4,%esp
   17a5a:	6a 0a                	push   $0xa
   17a5c:	6a 00                	push   $0x0
   17a5e:	68 40 d3 05 00       	push   $0x5d340
   17a63:	e8 3a 0f 00 00       	call   189a2 <kernel_memset>
   17a68:	83 c4 10             	add    $0x10,%esp
    list_init(&free_list);
   17a6b:	83 ec 0c             	sub    $0xc,%esp
   17a6e:	68 00 dc 05 00       	push   $0x5dc00
   17a73:	e8 c0 12 00 00       	call   18d38 <list_init>
   17a78:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < FS_TABLE_SIZE; ++i)
   17a7b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   17a82:	eb 28                	jmp    17aac <mount_list_init+0x6b>
    {
        list_insert_first(&free_list, &fs_table[i].node);
   17a84:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17a87:	69 c0 e0 00 00 00    	imul   $0xe0,%eax,%eax
   17a8d:	05 90 00 00 00       	add    $0x90,%eax
   17a92:	05 40 d3 05 00       	add    $0x5d340,%eax
   17a97:	83 ec 08             	sub    $0x8,%esp
   17a9a:	50                   	push   %eax
   17a9b:	68 00 dc 05 00       	push   $0x5dc00
   17aa0:	e8 b8 12 00 00       	call   18d5d <list_insert_first>
   17aa5:	83 c4 10             	add    $0x10,%esp
    for(int i = 0; i < FS_TABLE_SIZE; ++i)
   17aa8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   17aac:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
   17ab0:	7e d2                	jle    17a84 <mount_list_init+0x43>
    }
}
   17ab2:	90                   	nop
   17ab3:	c9                   	leave  
   17ab4:	c3                   	ret    

00017ab5 <get_fs_op>:
fs_op_t* get_fs_op(fs_type_t type, int major)
{
   17ab5:	55                   	push   %ebp
   17ab6:	89 e5                	mov    %esp,%ebp
   17ab8:	83 ec 08             	sub    $0x8,%esp
    switch (type)
   17abb:	8b 45 08             	mov    0x8(%ebp),%eax
   17abe:	85 c0                	test   %eax,%eax
   17ac0:	74 0c                	je     17ace <get_fs_op+0x19>
   17ac2:	83 f8 01             	cmp    $0x1,%eax
   17ac5:	75 0e                	jne    17ad5 <get_fs_op+0x20>
    {
    case FS_FAT16:
        return &fatfs_op;
   17ac7:	b8 40 b1 01 00       	mov    $0x1b140,%eax
   17acc:	eb 1d                	jmp    17aeb <get_fs_op+0x36>
    case FS_DEVFS:
        return &devfs_op;
   17ace:	b8 00 b1 01 00       	mov    $0x1b100,%eax
   17ad3:	eb 16                	jmp    17aeb <get_fs_op+0x36>
 
    default:
        log_printf("unknown fs type\n");
   17ad5:	83 ec 0c             	sub    $0xc,%esp
   17ad8:	68 2f a0 01 00       	push   $0x1a02f
   17add:	e8 6a 14 00 00       	call   18f4c <log_printf>
   17ae2:	83 c4 10             	add    $0x10,%esp
        break;
   17ae5:	90                   	nop
    }
    return (fs_op_t*)0;
   17ae6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17aeb:	c9                   	leave  
   17aec:	c3                   	ret    

00017aed <mount>:

fs_t* mount(fs_type_t type, char* mount_point, int major, int minor )
{
   17aed:	55                   	push   %ebp
   17aee:	89 e5                	mov    %esp,%ebp
   17af0:	83 ec 28             	sub    $0x28,%esp
    fs_t* fs = (fs_t*)0;
   17af3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    log_printf("mount file system, name: %s, dev: %x", mount_point, major);
   17afa:	83 ec 04             	sub    $0x4,%esp
   17afd:	ff 75 10             	pushl  0x10(%ebp)
   17b00:	ff 75 0c             	pushl  0xc(%ebp)
   17b03:	68 40 a0 01 00       	push   $0x1a040
   17b08:	e8 3f 14 00 00       	call   18f4c <log_printf>
   17b0d:	83 c4 10             	add    $0x10,%esp
    list_node_t * curr = list_first(&mounted_list);
   17b10:	83 ec 0c             	sub    $0xc,%esp
   17b13:	68 20 d3 05 00       	push   $0x5d320
   17b18:	e8 3c f7 ff ff       	call   17259 <list_first>
   17b1d:	83 c4 10             	add    $0x10,%esp
   17b20:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (curr) {
   17b23:	eb 59                	jmp    17b7e <mount+0x91>
		fs_t * fs = LIST_NODE_PARENT(curr, fs_t, node);
   17b25:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   17b29:	74 0a                	je     17b35 <mount+0x48>
   17b2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17b2e:	2d 90 00 00 00       	sub    $0x90,%eax
   17b33:	eb 05                	jmp    17b3a <mount+0x4d>
   17b35:	b8 00 00 00 00       	mov    $0x0,%eax
   17b3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (kernel_strncmp(fs->mount_point, mount_point, FS_MOUNTP_SIZE) == 0) {
   17b3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   17b40:	83 ec 04             	sub    $0x4,%esp
   17b43:	68 80 00 00 00       	push   $0x80
   17b48:	ff 75 0c             	pushl  0xc(%ebp)
   17b4b:	50                   	push   %eax
   17b4c:	e8 88 0d 00 00       	call   188d9 <kernel_strncmp>
   17b51:	83 c4 10             	add    $0x10,%esp
   17b54:	85 c0                	test   %eax,%eax
   17b56:	75 15                	jne    17b6d <mount+0x80>
			log_printf("fs alreay mounted.");
   17b58:	83 ec 0c             	sub    $0xc,%esp
   17b5b:	68 65 a0 01 00       	push   $0x1a065
   17b60:	e8 e7 13 00 00       	call   18f4c <log_printf>
   17b65:	83 c4 10             	add    $0x10,%esp
			goto mount_failed;
   17b68:	e9 03 01 00 00       	jmp    17c70 <mount+0x183>
		}
		curr = list_node_next(curr);
   17b6d:	83 ec 0c             	sub    $0xc,%esp
   17b70:	ff 75 f0             	pushl  -0x10(%ebp)
   17b73:	e8 d6 f6 ff ff       	call   1724e <list_node_next>
   17b78:	83 c4 10             	add    $0x10,%esp
   17b7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (curr) {
   17b7e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   17b82:	75 a1                	jne    17b25 <mount+0x38>
	}
    list_node_t * free_node = list_remove_first(&free_list);
   17b84:	83 ec 0c             	sub    $0xc,%esp
   17b87:	68 00 dc 05 00       	push   $0x5dc00
   17b8c:	e8 8f 12 00 00       	call   18e20 <list_remove_first>
   17b91:	83 c4 10             	add    $0x10,%esp
   17b94:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (!free_node) {
   17b97:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   17b9b:	75 15                	jne    17bb2 <mount+0xc5>
		log_printf("no free fs, mount failed.");
   17b9d:	83 ec 0c             	sub    $0xc,%esp
   17ba0:	68 78 a0 01 00       	push   $0x1a078
   17ba5:	e8 a2 13 00 00       	call   18f4c <log_printf>
   17baa:	83 c4 10             	add    $0x10,%esp
		goto mount_failed;
   17bad:	e9 be 00 00 00       	jmp    17c70 <mount+0x183>
	}
    fs = LIST_NODE_PARENT(free_node, fs_t, node);
   17bb2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   17bb6:	74 0a                	je     17bc2 <mount+0xd5>
   17bb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   17bbb:	2d 90 00 00 00       	sub    $0x90,%eax
   17bc0:	eb 05                	jmp    17bc7 <mount+0xda>
   17bc2:	b8 00 00 00 00       	mov    $0x0,%eax
   17bc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_op_t* op = get_fs_op(type, major);
   17bca:	83 ec 08             	sub    $0x8,%esp
   17bcd:	ff 75 10             	pushl  0x10(%ebp)
   17bd0:	ff 75 08             	pushl  0x8(%ebp)
   17bd3:	e8 dd fe ff ff       	call   17ab5 <get_fs_op>
   17bd8:	83 c4 10             	add    $0x10,%esp
   17bdb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    kernel_memset(fs, 0, sizeof(fs_t));
   17bde:	83 ec 04             	sub    $0x4,%esp
   17be1:	68 e0 00 00 00       	push   $0xe0
   17be6:	6a 00                	push   $0x0
   17be8:	ff 75 f4             	pushl  -0xc(%ebp)
   17beb:	e8 b2 0d 00 00       	call   189a2 <kernel_memset>
   17bf0:	83 c4 10             	add    $0x10,%esp
	kernel_strncpy(fs->mount_point, mount_point, FS_MOUNTP_SIZE);
   17bf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17bf6:	83 ec 04             	sub    $0x4,%esp
   17bf9:	68 80 00 00 00       	push   $0x80
   17bfe:	ff 75 0c             	pushl  0xc(%ebp)
   17c01:	50                   	push   %eax
   17c02:	e8 27 0c 00 00       	call   1882e <kernel_strncpy>
   17c07:	83 c4 10             	add    $0x10,%esp
	fs->op = op;
   17c0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17c0d:	8b 55 e8             	mov    -0x18(%ebp),%edx
   17c10:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
	fs->mutex = (mutex_t *)0;
   17c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17c19:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
   17c20:	00 00 00 
    if (op->mount(fs, major, minor) < 0) {
   17c23:	8b 45 e8             	mov    -0x18(%ebp),%eax
   17c26:	8b 00                	mov    (%eax),%eax
   17c28:	83 ec 04             	sub    $0x4,%esp
   17c2b:	ff 75 14             	pushl  0x14(%ebp)
   17c2e:	ff 75 10             	pushl  0x10(%ebp)
   17c31:	ff 75 f4             	pushl  -0xc(%ebp)
   17c34:	ff d0                	call   *%eax
   17c36:	83 c4 10             	add    $0x10,%esp
   17c39:	85 c0                	test   %eax,%eax
   17c3b:	79 15                	jns    17c52 <mount+0x165>
		log_printf("mount fs %s failed", mount_point);
   17c3d:	83 ec 08             	sub    $0x8,%esp
   17c40:	ff 75 0c             	pushl  0xc(%ebp)
   17c43:	68 92 a0 01 00       	push   $0x1a092
   17c48:	e8 ff 12 00 00       	call   18f4c <log_printf>
   17c4d:	83 c4 10             	add    $0x10,%esp
		goto mount_failed;
   17c50:	eb 1e                	jmp    17c70 <mount+0x183>
	}
    list_insert_first(&mounted_list, &fs->node);
   17c52:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17c55:	05 90 00 00 00       	add    $0x90,%eax
   17c5a:	83 ec 08             	sub    $0x8,%esp
   17c5d:	50                   	push   %eax
   17c5e:	68 20 d3 05 00       	push   $0x5d320
   17c63:	e8 f5 10 00 00       	call   18d5d <list_insert_first>
   17c68:	83 c4 10             	add    $0x10,%esp
    return fs;
   17c6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17c6e:	eb 1f                	jmp    17c8f <mount+0x1a2>
mount_failed:
	if (fs) {
   17c70:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17c74:	74 19                	je     17c8f <mount+0x1a2>
		list_insert_first(&free_list, &fs->node);
   17c76:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17c79:	05 90 00 00 00       	add    $0x90,%eax
   17c7e:	83 ec 08             	sub    $0x8,%esp
   17c81:	50                   	push   %eax
   17c82:	68 00 dc 05 00       	push   $0x5dc00
   17c87:	e8 d1 10 00 00       	call   18d5d <list_insert_first>
   17c8c:	83 c4 10             	add    $0x10,%esp
	}
}
   17c8f:	c9                   	leave  
   17c90:	c3                   	ret    

00017c91 <fs_init>:
void fs_init(void)
{
   17c91:	55                   	push   %ebp
   17c92:	89 e5                	mov    %esp,%ebp
   17c94:	83 ec 18             	sub    $0x18,%esp
    file_table_init();
   17c97:	e8 b7 f4 ff ff       	call   17153 <file_table_init>
    mount_list_init();
   17c9c:	e8 a0 fd ff ff       	call   17a41 <mount_list_init>
    disk_init();
   17ca1:	e8 87 cb ff ff       	call   1482d <disk_init>
    fs_t* fs = mount(FS_DEVFS, "/dev", 0, 0);
   17ca6:	6a 00                	push   $0x0
   17ca8:	6a 00                	push   $0x0
   17caa:	68 a5 a0 01 00       	push   $0x1a0a5
   17caf:	6a 00                	push   $0x0
   17cb1:	e8 37 fe ff ff       	call   17aed <mount>
   17cb6:	83 c4 10             	add    $0x10,%esp
   17cb9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    root_fs = mount(FS_FAT16, "/home", ROOT_DEV );
   17cbc:	68 b1 00 00 00       	push   $0xb1
   17cc1:	6a 02                	push   $0x2
   17cc3:	68 aa a0 01 00       	push   $0x1a0aa
   17cc8:	6a 01                	push   $0x1
   17cca:	e8 1e fe ff ff       	call   17aed <mount>
   17ccf:	83 c4 10             	add    $0x10,%esp
   17cd2:	a3 0c dc 05 00       	mov    %eax,0x5dc0c
}
   17cd7:	90                   	nop
   17cd8:	c9                   	leave  
   17cd9:	c3                   	ret    

00017cda <is_file_bad>:
static int is_file_bad(int file)
{
   17cda:	55                   	push   %ebp
   17cdb:	89 e5                	mov    %esp,%ebp
    if ((file < 0) || (file >= TASK_OFILE_NR))
   17cdd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   17ce1:	78 06                	js     17ce9 <is_file_bad+0xf>
   17ce3:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   17ce7:	7e 07                	jle    17cf0 <is_file_bad+0x16>
        return 1;
   17ce9:	b8 01 00 00 00       	mov    $0x1,%eax
   17cee:	eb 05                	jmp    17cf5 <is_file_bad+0x1b>
    return 0;
   17cf0:	b8 00 00 00 00       	mov    $0x0,%eax
}
   17cf5:	5d                   	pop    %ebp
   17cf6:	c3                   	ret    

00017cf7 <sys_ioctl>:
int sys_ioctl(int file, int cmd, int arg0, int arg1)
{
   17cf7:	55                   	push   %ebp
   17cf8:	89 e5                	mov    %esp,%ebp
   17cfa:	83 ec 18             	sub    $0x18,%esp
    if(is_file_bad(file))
   17cfd:	ff 75 08             	pushl  0x8(%ebp)
   17d00:	e8 d5 ff ff ff       	call   17cda <is_file_bad>
   17d05:	83 c4 04             	add    $0x4,%esp
   17d08:	85 c0                	test   %eax,%eax
   17d0a:	74 1a                	je     17d26 <sys_ioctl+0x2f>
	 {
        log_printf("file(%d) is not valid.", file);
   17d0c:	83 ec 08             	sub    $0x8,%esp
   17d0f:	ff 75 08             	pushl  0x8(%ebp)
   17d12:	68 af 9f 01 00       	push   $0x19faf
   17d17:	e8 30 12 00 00       	call   18f4c <log_printf>
   17d1c:	83 c4 10             	add    $0x10,%esp
		return -1;
   17d1f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17d24:	eb 7c                	jmp    17da2 <sys_ioctl+0xab>
	}

	file_t * p_file = task_file(file);
   17d26:	83 ec 0c             	sub    $0xc,%esp
   17d29:	ff 75 08             	pushl  0x8(%ebp)
   17d2c:	e8 5a 95 ff ff       	call   1128b <task_file>
   17d31:	83 c4 10             	add    $0x10,%esp
   17d34:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!p_file) {
   17d37:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17d3b:	75 17                	jne    17d54 <sys_ioctl+0x5d>
		log_printf("file not opened");
   17d3d:	83 ec 0c             	sub    $0xc,%esp
   17d40:	68 c6 9f 01 00       	push   $0x19fc6
   17d45:	e8 02 12 00 00       	call   18f4c <log_printf>
   17d4a:	83 c4 10             	add    $0x10,%esp
		return -1;
   17d4d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17d52:	eb 4e                	jmp    17da2 <sys_ioctl+0xab>
	}
    fs_t* fs = p_file->fs;
   17d54:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17d57:	8b 40 44             	mov    0x44(%eax),%eax
   17d5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fs_protect(root_fs);
   17d5d:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17d62:	83 ec 0c             	sub    $0xc,%esp
   17d65:	50                   	push   %eax
   17d66:	e8 4b f7 ff ff       	call   174b6 <fs_protect>
   17d6b:	83 c4 10             	add    $0x10,%esp
    int err = fs->op->ioctl(p_file, cmd, arg0, arg1);
   17d6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17d71:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   17d77:	8b 40 20             	mov    0x20(%eax),%eax
   17d7a:	ff 75 14             	pushl  0x14(%ebp)
   17d7d:	ff 75 10             	pushl  0x10(%ebp)
   17d80:	ff 75 0c             	pushl  0xc(%ebp)
   17d83:	ff 75 f4             	pushl  -0xc(%ebp)
   17d86:	ff d0                	call   *%eax
   17d88:	83 c4 10             	add    $0x10,%esp
   17d8b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    fs_unprotect(root_fs);
   17d8e:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17d93:	83 ec 0c             	sub    $0xc,%esp
   17d96:	50                   	push   %eax
   17d97:	e8 45 f7 ff ff       	call   174e1 <fs_unprotect>
   17d9c:	83 c4 10             	add    $0x10,%esp
    return err;
   17d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
   17da2:	c9                   	leave  
   17da3:	c3                   	ret    

00017da4 <sys_dup>:
int sys_dup (int file) {
   17da4:	55                   	push   %ebp
   17da5:	89 e5                	mov    %esp,%ebp
   17da7:	83 ec 18             	sub    $0x18,%esp
	if(is_file_bad(file))
   17daa:	ff 75 08             	pushl  0x8(%ebp)
   17dad:	e8 28 ff ff ff       	call   17cda <is_file_bad>
   17db2:	83 c4 04             	add    $0x4,%esp
   17db5:	85 c0                	test   %eax,%eax
   17db7:	74 1a                	je     17dd3 <sys_dup+0x2f>
	 {
        log_printf("file(%d) is not valid.", file);
   17db9:	83 ec 08             	sub    $0x8,%esp
   17dbc:	ff 75 08             	pushl  0x8(%ebp)
   17dbf:	68 af 9f 01 00       	push   $0x19faf
   17dc4:	e8 83 11 00 00       	call   18f4c <log_printf>
   17dc9:	83 c4 10             	add    $0x10,%esp
		return -1;
   17dcc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17dd1:	eb 6d                	jmp    17e40 <sys_dup+0x9c>
	}

	file_t * p_file = task_file(file);
   17dd3:	83 ec 0c             	sub    $0xc,%esp
   17dd6:	ff 75 08             	pushl  0x8(%ebp)
   17dd9:	e8 ad 94 ff ff       	call   1128b <task_file>
   17dde:	83 c4 10             	add    $0x10,%esp
   17de1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!p_file) {
   17de4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   17de8:	75 17                	jne    17e01 <sys_dup+0x5d>
		log_printf("file not opened");
   17dea:	83 ec 0c             	sub    $0xc,%esp
   17ded:	68 c6 9f 01 00       	push   $0x19fc6
   17df2:	e8 55 11 00 00       	call   18f4c <log_printf>
   17df7:	83 c4 10             	add    $0x10,%esp
		return -1;
   17dfa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   17dff:	eb 3f                	jmp    17e40 <sys_dup+0x9c>
	}

	int fd = task_alloc_fd(p_file);	
   17e01:	83 ec 0c             	sub    $0xc,%esp
   17e04:	ff 75 f4             	pushl  -0xc(%ebp)
   17e07:	e8 af 94 ff ff       	call   112bb <task_alloc_fd>
   17e0c:	83 c4 10             	add    $0x10,%esp
   17e0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (fd >= 0) {
   17e12:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   17e16:	78 13                	js     17e2b <sys_dup+0x87>
		ref_inc(p_file);		
   17e18:	83 ec 0c             	sub    $0xc,%esp
   17e1b:	ff 75 f4             	pushl  -0xc(%ebp)
   17e1e:	e8 60 f3 ff ff       	call   17183 <ref_inc>
   17e23:	83 c4 10             	add    $0x10,%esp
		return fd;
   17e26:	8b 45 f0             	mov    -0x10(%ebp),%eax
   17e29:	eb 15                	jmp    17e40 <sys_dup+0x9c>
	}

	log_printf("No task file avaliable");
   17e2b:	83 ec 0c             	sub    $0xc,%esp
   17e2e:	68 b0 a0 01 00       	push   $0x1a0b0
   17e33:	e8 14 11 00 00       	call   18f4c <log_printf>
   17e38:	83 c4 10             	add    $0x10,%esp
    return -1;
   17e3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   17e40:	c9                   	leave  
   17e41:	c3                   	ret    

00017e42 <sys_opendir>:

int sys_opendir(const char* name, DIR* dir)
{
   17e42:	55                   	push   %ebp
   17e43:	89 e5                	mov    %esp,%ebp
   17e45:	83 ec 18             	sub    $0x18,%esp
    fs_protect(root_fs);
   17e48:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17e4d:	83 ec 0c             	sub    $0xc,%esp
   17e50:	50                   	push   %eax
   17e51:	e8 60 f6 ff ff       	call   174b6 <fs_protect>
   17e56:	83 c4 10             	add    $0x10,%esp
    int err = root_fs->op->opendir(root_fs, name, dir);
   17e59:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17e5e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   17e64:	8b 40 24             	mov    0x24(%eax),%eax
   17e67:	8b 15 0c dc 05 00    	mov    0x5dc0c,%edx
   17e6d:	83 ec 04             	sub    $0x4,%esp
   17e70:	ff 75 0c             	pushl  0xc(%ebp)
   17e73:	ff 75 08             	pushl  0x8(%ebp)
   17e76:	52                   	push   %edx
   17e77:	ff d0                	call   *%eax
   17e79:	83 c4 10             	add    $0x10,%esp
   17e7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_unprotect(root_fs);
   17e7f:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17e84:	83 ec 0c             	sub    $0xc,%esp
   17e87:	50                   	push   %eax
   17e88:	e8 54 f6 ff ff       	call   174e1 <fs_unprotect>
   17e8d:	83 c4 10             	add    $0x10,%esp
    return err;
   17e90:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   17e93:	c9                   	leave  
   17e94:	c3                   	ret    

00017e95 <sys_readdir>:
int sys_readdir(DIR* dir, struct dirent* dirent)
{
   17e95:	55                   	push   %ebp
   17e96:	89 e5                	mov    %esp,%ebp
   17e98:	83 ec 18             	sub    $0x18,%esp
    fs_protect(root_fs);
   17e9b:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17ea0:	83 ec 0c             	sub    $0xc,%esp
   17ea3:	50                   	push   %eax
   17ea4:	e8 0d f6 ff ff       	call   174b6 <fs_protect>
   17ea9:	83 c4 10             	add    $0x10,%esp
    int err = root_fs->op->readdir(root_fs, dir, dirent);
   17eac:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17eb1:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   17eb7:	8b 40 28             	mov    0x28(%eax),%eax
   17eba:	8b 15 0c dc 05 00    	mov    0x5dc0c,%edx
   17ec0:	83 ec 04             	sub    $0x4,%esp
   17ec3:	ff 75 0c             	pushl  0xc(%ebp)
   17ec6:	ff 75 08             	pushl  0x8(%ebp)
   17ec9:	52                   	push   %edx
   17eca:	ff d0                	call   *%eax
   17ecc:	83 c4 10             	add    $0x10,%esp
   17ecf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_unprotect(root_fs);
   17ed2:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17ed7:	83 ec 0c             	sub    $0xc,%esp
   17eda:	50                   	push   %eax
   17edb:	e8 01 f6 ff ff       	call   174e1 <fs_unprotect>
   17ee0:	83 c4 10             	add    $0x10,%esp
    return err;
   17ee3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   17ee6:	c9                   	leave  
   17ee7:	c3                   	ret    

00017ee8 <sys_closedir>:
int sys_closedir(DIR* dir)
{
   17ee8:	55                   	push   %ebp
   17ee9:	89 e5                	mov    %esp,%ebp
   17eeb:	83 ec 18             	sub    $0x18,%esp
    fs_protect(root_fs);
   17eee:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17ef3:	83 ec 0c             	sub    $0xc,%esp
   17ef6:	50                   	push   %eax
   17ef7:	e8 ba f5 ff ff       	call   174b6 <fs_protect>
   17efc:	83 c4 10             	add    $0x10,%esp
    int err = root_fs->op->closedir(root_fs, dir);
   17eff:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17f04:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   17f0a:	8b 40 2c             	mov    0x2c(%eax),%eax
   17f0d:	8b 15 0c dc 05 00    	mov    0x5dc0c,%edx
   17f13:	83 ec 08             	sub    $0x8,%esp
   17f16:	ff 75 08             	pushl  0x8(%ebp)
   17f19:	52                   	push   %edx
   17f1a:	ff d0                	call   *%eax
   17f1c:	83 c4 10             	add    $0x10,%esp
   17f1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_unprotect(root_fs);
   17f22:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17f27:	83 ec 0c             	sub    $0xc,%esp
   17f2a:	50                   	push   %eax
   17f2b:	e8 b1 f5 ff ff       	call   174e1 <fs_unprotect>
   17f30:	83 c4 10             	add    $0x10,%esp
    return err;
   17f33:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   17f36:	c9                   	leave  
   17f37:	c3                   	ret    

00017f38 <sys_unlink>:

int sys_unlink(const char* name)
{
   17f38:	55                   	push   %ebp
   17f39:	89 e5                	mov    %esp,%ebp
   17f3b:	83 ec 18             	sub    $0x18,%esp
    fs_protect(root_fs);
   17f3e:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17f43:	83 ec 0c             	sub    $0xc,%esp
   17f46:	50                   	push   %eax
   17f47:	e8 6a f5 ff ff       	call   174b6 <fs_protect>
   17f4c:	83 c4 10             	add    $0x10,%esp
    int err = root_fs->op->unlink(root_fs, name);
   17f4f:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17f54:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   17f5a:	8b 40 30             	mov    0x30(%eax),%eax
   17f5d:	8b 15 0c dc 05 00    	mov    0x5dc0c,%edx
   17f63:	83 ec 08             	sub    $0x8,%esp
   17f66:	ff 75 08             	pushl  0x8(%ebp)
   17f69:	52                   	push   %edx
   17f6a:	ff d0                	call   *%eax
   17f6c:	83 c4 10             	add    $0x10,%esp
   17f6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    fs_unprotect(root_fs);
   17f72:	a1 0c dc 05 00       	mov    0x5dc0c,%eax
   17f77:	83 ec 0c             	sub    $0xc,%esp
   17f7a:	50                   	push   %eax
   17f7b:	e8 61 f5 ff ff       	call   174e1 <fs_unprotect>
   17f80:	83 c4 10             	add    $0x10,%esp
    return err;
   17f83:	8b 45 f4             	mov    -0xc(%ebp),%eax
   17f86:	c9                   	leave  
   17f87:	c3                   	ret    

00017f88 <inb>:
static inline uint8_t inb(uint16_t  port) {
   17f88:	55                   	push   %ebp
   17f89:	89 e5                	mov    %esp,%ebp
   17f8b:	83 ec 14             	sub    $0x14,%esp
   17f8e:	8b 45 08             	mov    0x8(%ebp),%eax
   17f91:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   17f95:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   17f99:	89 c2                	mov    %eax,%edx
   17f9b:	ec                   	in     (%dx),%al
   17f9c:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   17f9f:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   17fa3:	c9                   	leave  
   17fa4:	c3                   	ret    

00017fa5 <inw>:
static inline uint16_t inw(uint16_t  port) {
   17fa5:	55                   	push   %ebp
   17fa6:	89 e5                	mov    %esp,%ebp
   17fa8:	83 ec 14             	sub    $0x14,%esp
   17fab:	8b 45 08             	mov    0x8(%ebp),%eax
   17fae:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   17fb2:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   17fb6:	89 c2                	mov    %eax,%edx
   17fb8:	66 ed                	in     (%dx),%ax
   17fba:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   17fbe:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   17fc2:	c9                   	leave  
   17fc3:	c3                   	ret    

00017fc4 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   17fc4:	55                   	push   %ebp
   17fc5:	89 e5                	mov    %esp,%ebp
   17fc7:	83 ec 08             	sub    $0x8,%esp
   17fca:	8b 55 08             	mov    0x8(%ebp),%edx
   17fcd:	8b 45 0c             	mov    0xc(%ebp),%eax
   17fd0:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   17fd4:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   17fd7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   17fdb:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   17fdf:	ee                   	out    %al,(%dx)
}
   17fe0:	90                   	nop
   17fe1:	c9                   	leave  
   17fe2:	c3                   	ret    

00017fe3 <read_disk>:
static void read_disk(int sector, int sector_count, uint8_t * buf) {
   17fe3:	55                   	push   %ebp
   17fe4:	89 e5                	mov    %esp,%ebp
   17fe6:	53                   	push   %ebx
   17fe7:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   17fea:	68 e0 00 00 00       	push   $0xe0
   17fef:	68 f6 01 00 00       	push   $0x1f6
   17ff4:	e8 cb ff ff ff       	call   17fc4 <outb>
   17ff9:	83 c4 08             	add    $0x8,%esp
	outb(0x1F2, (uint8_t) (sector_count >> 8));
   17ffc:	8b 45 0c             	mov    0xc(%ebp),%eax
   17fff:	c1 f8 08             	sar    $0x8,%eax
   18002:	0f b6 c0             	movzbl %al,%eax
   18005:	50                   	push   %eax
   18006:	68 f2 01 00 00       	push   $0x1f2
   1800b:	e8 b4 ff ff ff       	call   17fc4 <outb>
   18010:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		// LBA参数的24~31位
   18013:	8b 45 08             	mov    0x8(%ebp),%eax
   18016:	c1 f8 18             	sar    $0x18,%eax
   18019:	0f b6 c0             	movzbl %al,%eax
   1801c:	50                   	push   %eax
   1801d:	68 f3 01 00 00       	push   $0x1f3
   18022:	e8 9d ff ff ff       	call   17fc4 <outb>
   18027:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					// LBA参数的32~39位
   1802a:	6a 00                	push   $0x0
   1802c:	68 f4 01 00 00       	push   $0x1f4
   18031:	e8 8e ff ff ff       	call   17fc4 <outb>
   18036:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					// LBA参数的40~47位
   18039:	6a 00                	push   $0x0
   1803b:	68 f5 01 00 00       	push   $0x1f5
   18040:	e8 7f ff ff ff       	call   17fc4 <outb>
   18045:	83 c4 08             	add    $0x8,%esp
    outb(0x1F2, (uint8_t) (sector_count));
   18048:	8b 45 0c             	mov    0xc(%ebp),%eax
   1804b:	0f b6 c0             	movzbl %al,%eax
   1804e:	50                   	push   %eax
   1804f:	68 f2 01 00 00       	push   $0x1f2
   18054:	e8 6b ff ff ff       	call   17fc4 <outb>
   18059:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			// LBA参数的0~7位
   1805c:	8b 45 08             	mov    0x8(%ebp),%eax
   1805f:	0f b6 c0             	movzbl %al,%eax
   18062:	50                   	push   %eax
   18063:	68 f3 01 00 00       	push   $0x1f3
   18068:	e8 57 ff ff ff       	call   17fc4 <outb>
   1806d:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		// LBA参数的8~15位
   18070:	8b 45 08             	mov    0x8(%ebp),%eax
   18073:	c1 f8 08             	sar    $0x8,%eax
   18076:	0f b6 c0             	movzbl %al,%eax
   18079:	50                   	push   %eax
   1807a:	68 f4 01 00 00       	push   $0x1f4
   1807f:	e8 40 ff ff ff       	call   17fc4 <outb>
   18084:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		// LBA参数的16~23位
   18087:	8b 45 08             	mov    0x8(%ebp),%eax
   1808a:	c1 f8 10             	sar    $0x10,%eax
   1808d:	0f b6 c0             	movzbl %al,%eax
   18090:	50                   	push   %eax
   18091:	68 f5 01 00 00       	push   $0x1f5
   18096:	e8 29 ff ff ff       	call   17fc4 <outb>
   1809b:	83 c4 08             	add    $0x8,%esp
	outb(0x1F7, (uint8_t) 0x24);
   1809e:	6a 24                	push   $0x24
   180a0:	68 f7 01 00 00       	push   $0x1f7
   180a5:	e8 1a ff ff ff       	call   17fc4 <outb>
   180aa:	83 c4 08             	add    $0x8,%esp
	uint16_t *data_buf = (uint16_t*) buf;
   180ad:	8b 45 10             	mov    0x10(%ebp),%eax
   180b0:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (sector_count-- > 0) {
   180b3:	eb 4a                	jmp    180ff <read_disk+0x11c>
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   180b5:	90                   	nop
   180b6:	68 f7 01 00 00       	push   $0x1f7
   180bb:	e8 c8 fe ff ff       	call   17f88 <inb>
   180c0:	83 c4 04             	add    $0x4,%esp
   180c3:	0f b6 c0             	movzbl %al,%eax
   180c6:	25 88 00 00 00       	and    $0x88,%eax
   180cb:	83 f8 08             	cmp    $0x8,%eax
   180ce:	75 e6                	jne    180b6 <read_disk+0xd3>
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   180d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   180d7:	eb 1d                	jmp    180f6 <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   180d9:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   180dc:	8d 43 02             	lea    0x2(%ebx),%eax
   180df:	89 45 f8             	mov    %eax,-0x8(%ebp)
   180e2:	68 f0 01 00 00       	push   $0x1f0
   180e7:	e8 b9 fe ff ff       	call   17fa5 <inw>
   180ec:	83 c4 04             	add    $0x4,%esp
   180ef:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   180f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   180f6:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   180fd:	7e da                	jle    180d9 <read_disk+0xf6>
	while (sector_count-- > 0) {
   180ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   18102:	8d 50 ff             	lea    -0x1(%eax),%edx
   18105:	89 55 0c             	mov    %edx,0xc(%ebp)
   18108:	85 c0                	test   %eax,%eax
   1810a:	7f a9                	jg     180b5 <read_disk+0xd2>
}
   1810c:	90                   	nop
   1810d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   18110:	c9                   	leave  
   18111:	c3                   	ret    

00018112 <kernel_init>:
#include "dev/console.h"
#include "dev/kbd.h"
#include "fs/fs.h"
// static boot_info_t * init_boot_info;

void kernel_init(boot_info_t* boot_info){
   18112:	55                   	push   %ebp
   18113:	89 e5                	mov    %esp,%ebp
   18115:	83 ec 08             	sub    $0x8,%esp
    // init_boot_info = boot_info;
    Assert(boot_info->ram_region_count != 0);
   18118:	8b 45 08             	mov    0x8(%ebp),%eax
   1811b:	8b 40 50             	mov    0x50(%eax),%eax
   1811e:	85 c0                	test   %eax,%eax
   18120:	75 19                	jne    1813b <kernel_init+0x29>
   18122:	68 d4 a0 01 00       	push   $0x1a0d4
   18127:	68 c0 a1 01 00       	push   $0x1a1c0
   1812c:	6a 14                	push   $0x14
   1812e:	68 f8 a0 01 00       	push   $0x1a0f8
   18133:	e8 b7 0b 00 00       	call   18cef <pannic>
   18138:	83 c4 10             	add    $0x10,%esp
    // Assert(3 < 2);
    cpu_init();
   1813b:	e8 22 a7 ff ff       	call   12862 <cpu_init>
    irq_init();
   18140:	e8 08 b1 ff ff       	call   1324d <irq_init>
    log_init();
   18145:	e8 d3 0d 00 00       	call   18f1d <log_init>
    memory_init(boot_info);
   1814a:	83 ec 0c             	sub    $0xc,%esp
   1814d:	ff 75 08             	pushl  0x8(%ebp)
   18150:	e8 07 86 ff ff       	call   1075c <memory_init>
   18155:	83 c4 10             	add    $0x10,%esp
    fs_init();
   18158:	e8 34 fb ff ff       	call   17c91 <fs_init>

    timer_init();
   1815d:	e8 66 cf ff ff       	call   150c8 <timer_init>
    task_manager_init();
   18162:	e8 90 95 ff ff       	call   116f7 <task_manager_init>
    // init_main();

}
   18167:	90                   	nop
   18168:	c9                   	leave  
   18169:	c3                   	ret    

0001816a <move_to_first_task>:
//         // sys_sleep(500);
//         // task_switch_from_to(&init_task_struct, task_first_task());
//         // sys_shed_yield();
//     }
// }
void move_to_first_task(void) {
   1816a:	55                   	push   %ebp
   1816b:	89 e5                	mov    %esp,%ebp
   1816d:	56                   	push   %esi
   1816e:	53                   	push   %ebx
   1816f:	83 ec 10             	sub    $0x10,%esp
    task_t * curr = task_manager.curr_task;
   18172:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   18177:	89 45 f4             	mov    %eax,-0xc(%ebp)
    Assert(curr != 0);
   1817a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1817e:	75 19                	jne    18199 <move_to_first_task+0x2f>
   18180:	68 43 a1 01 00       	push   $0x1a143
   18185:	68 cc a1 01 00       	push   $0x1a1cc
   1818a:	6a 31                	push   $0x31
   1818c:	68 f8 a0 01 00       	push   $0x1a0f8
   18191:	e8 59 0b 00 00       	call   18cef <pannic>
   18196:	83 c4 10             	add    $0x10,%esp

    tss_t * tss = &(curr->tss);
   18199:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1819c:	05 5c 02 00 00       	add    $0x25c,%eax
   181a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
        "push %[ss]\n\t"			// SS
        "push %[esp]\n\t"			// ESP
        "push %[eflags]\n\t"           // EFLAGS
        "push %[cs]\n\t"			// CS
        "push %[eip]\n\t"		    // ip
        "iret\n\t"::[ss]"r"(tss->ss),  [esp]"r"(tss->esp), [eflags]"r"(tss->eflags),
   181a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   181a7:	8b 40 50             	mov    0x50(%eax),%eax
   181aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
   181ad:	8b 52 38             	mov    0x38(%edx),%edx
   181b0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   181b3:	8b 49 24             	mov    0x24(%ecx),%ecx
        [cs]"r"(tss->cs), [eip]"r"(tss->eip));
   181b6:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   181b9:	8b 5b 4c             	mov    0x4c(%ebx),%ebx
   181bc:	8b 75 f0             	mov    -0x10(%ebp),%esi
   181bf:	8b 76 20             	mov    0x20(%esi),%esi
    __asm__ __volatile__(
   181c2:	50                   	push   %eax
   181c3:	52                   	push   %edx
   181c4:	51                   	push   %ecx
   181c5:	53                   	push   %ebx
   181c6:	56                   	push   %esi
   181c7:	cf                   	iret   
}
   181c8:	90                   	nop
   181c9:	8d 65 f8             	lea    -0x8(%ebp),%esp
   181cc:	5b                   	pop    %ebx
   181cd:	5e                   	pop    %esi
   181ce:	5d                   	pop    %ebp
   181cf:	c3                   	ret    

000181d0 <init_main>:

void init_main(void){
   181d0:	55                   	push   %ebp
   181d1:	89 e5                	mov    %esp,%ebp
   181d3:	83 ec 08             	sub    $0x8,%esp
    // int a = 3 / 0;
    // irq_enable_global();
    // list_test();
    log_printf("====================================");
   181d6:	83 ec 0c             	sub    $0xc,%esp
   181d9:	68 50 a1 01 00       	push   $0x1a150
   181de:	e8 69 0d 00 00       	call   18f4c <log_printf>
   181e3:	83 c4 10             	add    $0x10,%esp
    log_printf("Kernel is running....");
   181e6:	83 ec 0c             	sub    $0xc,%esp
   181e9:	68 75 a1 01 00       	push   $0x1a175
   181ee:	e8 59 0d 00 00       	call   18f4c <log_printf>
   181f3:	83 c4 10             	add    $0x10,%esp
    log_printf("Version: %s, name: %s", "1.0.0", "tiny x86 os");
   181f6:	83 ec 04             	sub    $0x4,%esp
   181f9:	68 8b a1 01 00       	push   $0x1a18b
   181fe:	68 97 a1 01 00       	push   $0x1a197
   18203:	68 9d a1 01 00       	push   $0x1a19d
   18208:	e8 3f 0d 00 00       	call   18f4c <log_printf>
   1820d:	83 c4 10             	add    $0x10,%esp
    log_printf("====================================");
   18210:	83 ec 0c             	sub    $0xc,%esp
   18213:	68 50 a1 01 00       	push   $0x1a150
   18218:	e8 2f 0d 00 00       	call   18f4c <log_printf>
   1821d:	83 c4 10             	add    $0x10,%esp
    log_printf("%d %d %x %c", -123, 123456, 0x12345, 'a');
   18220:	83 ec 0c             	sub    $0xc,%esp
   18223:	6a 61                	push   $0x61
   18225:	68 45 23 01 00       	push   $0x12345
   1822a:	68 40 e2 01 00       	push   $0x1e240
   1822f:	6a 85                	push   $0xffffff85
   18231:	68 b3 a1 01 00       	push   $0x1a1b3
   18236:	e8 11 0d 00 00       	call   18f4c <log_printf>
   1823b:	83 c4 20             	add    $0x20,%esp
    first_task_init();
   1823e:	e8 9b 95 ff ff       	call   117de <first_task_init>
    move_to_first_task();
   18243:	e8 22 ff ff ff       	call   1816a <move_to_first_task>
    //     log_printf("init_main %d", count++);
    //     // sem_notify(&sem);
    //     // sys_sleep(1000);
    //     // sys_shed_yield();
    // }
}
   18248:	90                   	nop
   18249:	c9                   	leave  
   1824a:	c3                   	ret    

0001824b <list_count>:
static inline int list_count(list_t *list) {
   1824b:	55                   	push   %ebp
   1824c:	89 e5                	mov    %esp,%ebp
    return list->count;
   1824e:	8b 45 08             	mov    0x8(%ebp),%eax
   18251:	8b 40 08             	mov    0x8(%eax),%eax
}
   18254:	5d                   	pop    %ebp
   18255:	c3                   	ret    

00018256 <mutex_init>:
#include "ipc/mutex.h"
#include "cpu/irq.h"
void mutex_init(mutex_t* mutex){
   18256:	55                   	push   %ebp
   18257:	89 e5                	mov    %esp,%ebp
   18259:	83 ec 08             	sub    $0x8,%esp
    mutex->owner = (task_t*) 0;
   1825c:	8b 45 08             	mov    0x8(%ebp),%eax
   1825f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    mutex->lock_count = 0;
   18266:	8b 45 08             	mov    0x8(%ebp),%eax
   18269:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list);
   1826f:	8b 45 08             	mov    0x8(%ebp),%eax
   18272:	83 c0 04             	add    $0x4,%eax
   18275:	83 ec 0c             	sub    $0xc,%esp
   18278:	50                   	push   %eax
   18279:	e8 ba 0a 00 00       	call   18d38 <list_init>
   1827e:	83 c4 10             	add    $0x10,%esp
}
   18281:	90                   	nop
   18282:	c9                   	leave  
   18283:	c3                   	ret    

00018284 <mutex_lock>:

void mutex_lock(mutex_t* mutex){
   18284:	55                   	push   %ebp
   18285:	89 e5                	mov    %esp,%ebp
   18287:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = enter_protection();
   1828a:	e8 97 b1 ff ff       	call   13426 <enter_protection>
   1828f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr_task = task_manager.curr_task;
   18292:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   18297:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->lock_count == 0)
   1829a:	8b 45 08             	mov    0x8(%ebp),%eax
   1829d:	8b 00                	mov    (%eax),%eax
   1829f:	85 c0                	test   %eax,%eax
   182a1:	75 18                	jne    182bb <mutex_lock+0x37>
    {
        ++mutex->lock_count;
   182a3:	8b 45 08             	mov    0x8(%ebp),%eax
   182a6:	8b 00                	mov    (%eax),%eax
   182a8:	8d 50 01             	lea    0x1(%eax),%edx
   182ab:	8b 45 08             	mov    0x8(%ebp),%eax
   182ae:	89 10                	mov    %edx,(%eax)
        mutex->owner = curr_task;
   182b0:	8b 45 08             	mov    0x8(%ebp),%eax
   182b3:	8b 55 f0             	mov    -0x10(%ebp),%edx
   182b6:	89 50 10             	mov    %edx,0x10(%eax)
   182b9:	eb 4e                	jmp    18309 <mutex_lock+0x85>
    }
     else if (mutex->owner == curr_task) {
   182bb:	8b 45 08             	mov    0x8(%ebp),%eax
   182be:	8b 40 10             	mov    0x10(%eax),%eax
   182c1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   182c4:	75 0f                	jne    182d5 <mutex_lock+0x51>
        // 已经为当前任务所有，只增加计数
        mutex->lock_count++;
   182c6:	8b 45 08             	mov    0x8(%ebp),%eax
   182c9:	8b 00                	mov    (%eax),%eax
   182cb:	8d 50 01             	lea    0x1(%eax),%edx
   182ce:	8b 45 08             	mov    0x8(%ebp),%eax
   182d1:	89 10                	mov    %edx,(%eax)
   182d3:	eb 34                	jmp    18309 <mutex_lock+0x85>
    }
    else {
        // 有其它任务占用，则进入队列等待
        task_t * curr = task_manager.curr_task;
   182d5:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   182da:	89 45 ec             	mov    %eax,-0x14(%ebp)
        set_block(curr);
   182dd:	83 ec 0c             	sub    $0xc,%esp
   182e0:	ff 75 ec             	pushl  -0x14(%ebp)
   182e3:	e8 29 96 ff ff       	call   11911 <set_block>
   182e8:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list, &curr->wait_node);
   182eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   182ee:	8d 50 18             	lea    0x18(%eax),%edx
   182f1:	8b 45 08             	mov    0x8(%ebp),%eax
   182f4:	83 c0 04             	add    $0x4,%eax
   182f7:	83 ec 08             	sub    $0x8,%esp
   182fa:	52                   	push   %edx
   182fb:	50                   	push   %eax
   182fc:	e8 bb 0a 00 00       	call   18dbc <list_insert_last>
   18301:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   18304:	e8 d5 96 ff ff       	call   119de <task_dispatch>
    }
    leave_protection(state);
   18309:	83 ec 0c             	sub    $0xc,%esp
   1830c:	ff 75 f4             	pushl  -0xc(%ebp)
   1830f:	e8 2a b1 ff ff       	call   1343e <leave_protection>
   18314:	83 c4 10             	add    $0x10,%esp
}
   18317:	90                   	nop
   18318:	c9                   	leave  
   18319:	c3                   	ret    

0001831a <mutex_unlock>:

void mutex_unlock(mutex_t* mutex){
   1831a:	55                   	push   %ebp
   1831b:	89 e5                	mov    %esp,%ebp
   1831d:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = enter_protection();
   18320:	e8 01 b1 ff ff       	call   13426 <enter_protection>
   18325:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t* curr_task = task_manager.curr_task;
   18328:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   1832d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(mutex->owner == curr_task){
   18330:	8b 45 08             	mov    0x8(%ebp),%eax
   18333:	8b 40 10             	mov    0x10(%eax),%eax
   18336:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   18339:	0f 85 8a 00 00 00    	jne    183c9 <mutex_unlock+0xaf>
        if(--mutex->lock_count == 0){
   1833f:	8b 45 08             	mov    0x8(%ebp),%eax
   18342:	8b 00                	mov    (%eax),%eax
   18344:	8d 50 ff             	lea    -0x1(%eax),%edx
   18347:	8b 45 08             	mov    0x8(%ebp),%eax
   1834a:	89 10                	mov    %edx,(%eax)
   1834c:	8b 45 08             	mov    0x8(%ebp),%eax
   1834f:	8b 00                	mov    (%eax),%eax
   18351:	85 c0                	test   %eax,%eax
   18353:	75 74                	jne    183c9 <mutex_unlock+0xaf>
            mutex->owner = (task_t*) 0;
   18355:	8b 45 08             	mov    0x8(%ebp),%eax
   18358:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

            if(list_count(&mutex->wait_list)){
   1835f:	8b 45 08             	mov    0x8(%ebp),%eax
   18362:	83 c0 04             	add    $0x4,%eax
   18365:	83 ec 0c             	sub    $0xc,%esp
   18368:	50                   	push   %eax
   18369:	e8 dd fe ff ff       	call   1824b <list_count>
   1836e:	83 c4 10             	add    $0x10,%esp
   18371:	85 c0                	test   %eax,%eax
   18373:	74 54                	je     183c9 <mutex_unlock+0xaf>
                list_node_t* node = list_remove_first(&mutex->wait_list);
   18375:	8b 45 08             	mov    0x8(%ebp),%eax
   18378:	83 c0 04             	add    $0x4,%eax
   1837b:	83 ec 0c             	sub    $0xc,%esp
   1837e:	50                   	push   %eax
   1837f:	e8 9c 0a 00 00       	call   18e20 <list_remove_first>
   18384:	83 c4 10             	add    $0x10,%esp
   18387:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t* task = LIST_NODE_PARENT(node, task_t, wait_node);
   1838a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1838e:	74 08                	je     18398 <mutex_unlock+0x7e>
   18390:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18393:	83 e8 18             	sub    $0x18,%eax
   18396:	eb 05                	jmp    1839d <mutex_unlock+0x83>
   18398:	b8 00 00 00 00       	mov    $0x0,%eax
   1839d:	89 45 e8             	mov    %eax,-0x18(%ebp)
                set_ready(task);
   183a0:	83 ec 0c             	sub    $0xc,%esp
   183a3:	ff 75 e8             	pushl  -0x18(%ebp)
   183a6:	e8 32 95 ff ff       	call   118dd <set_ready>
   183ab:	83 c4 10             	add    $0x10,%esp
                mutex->lock_count++;
   183ae:	8b 45 08             	mov    0x8(%ebp),%eax
   183b1:	8b 00                	mov    (%eax),%eax
   183b3:	8d 50 01             	lea    0x1(%eax),%edx
   183b6:	8b 45 08             	mov    0x8(%ebp),%eax
   183b9:	89 10                	mov    %edx,(%eax)
                mutex->owner = task;
   183bb:	8b 45 08             	mov    0x8(%ebp),%eax
   183be:	8b 55 e8             	mov    -0x18(%ebp),%edx
   183c1:	89 50 10             	mov    %edx,0x10(%eax)
                task_dispatch();
   183c4:	e8 15 96 ff ff       	call   119de <task_dispatch>
            }
        }
    }

    leave_protection(state);
   183c9:	83 ec 0c             	sub    $0xc,%esp
   183cc:	ff 75 f4             	pushl  -0xc(%ebp)
   183cf:	e8 6a b0 ff ff       	call   1343e <leave_protection>
   183d4:	83 c4 10             	add    $0x10,%esp
   183d7:	90                   	nop
   183d8:	c9                   	leave  
   183d9:	c3                   	ret    

000183da <list_count>:
static inline int list_count(list_t *list) {
   183da:	55                   	push   %ebp
   183db:	89 e5                	mov    %esp,%ebp
    return list->count;
   183dd:	8b 45 08             	mov    0x8(%ebp),%eax
   183e0:	8b 40 08             	mov    0x8(%eax),%eax
}
   183e3:	5d                   	pop    %ebp
   183e4:	c3                   	ret    

000183e5 <sem_init>:
 * 信号量初始化
 */
#include "cpu/irq.h"
#include "core/task.h"
#include "ipc/sem.h"
void sem_init (sem_t * sem, int init_count) {
   183e5:	55                   	push   %ebp
   183e6:	89 e5                	mov    %esp,%ebp
   183e8:	83 ec 08             	sub    $0x8,%esp
    sem->count = init_count;
   183eb:	8b 45 08             	mov    0x8(%ebp),%eax
   183ee:	8b 55 0c             	mov    0xc(%ebp),%edx
   183f1:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   183f3:	8b 45 08             	mov    0x8(%ebp),%eax
   183f6:	83 c0 04             	add    $0x4,%eax
   183f9:	83 ec 0c             	sub    $0xc,%esp
   183fc:	50                   	push   %eax
   183fd:	e8 36 09 00 00       	call   18d38 <list_init>
   18402:	83 c4 10             	add    $0x10,%esp
}
   18405:	90                   	nop
   18406:	c9                   	leave  
   18407:	c3                   	ret    

00018408 <sem_wait>:

/**
 * 申请信号量
 */
void sem_wait (sem_t * sem) {
   18408:	55                   	push   %ebp
   18409:	89 e5                	mov    %esp,%ebp
   1840b:	83 ec 18             	sub    $0x18,%esp
    irq_state_t  irq_state = enter_protection();
   1840e:	e8 13 b0 ff ff       	call   13426 <enter_protection>
   18413:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (sem->count > 0) {
   18416:	8b 45 08             	mov    0x8(%ebp),%eax
   18419:	8b 00                	mov    (%eax),%eax
   1841b:	85 c0                	test   %eax,%eax
   1841d:	7e 0f                	jle    1842e <sem_wait+0x26>
        sem->count--;
   1841f:	8b 45 08             	mov    0x8(%ebp),%eax
   18422:	8b 00                	mov    (%eax),%eax
   18424:	8d 50 ff             	lea    -0x1(%eax),%edx
   18427:	8b 45 08             	mov    0x8(%ebp),%eax
   1842a:	89 10                	mov    %edx,(%eax)
   1842c:	eb 34                	jmp    18462 <sem_wait+0x5a>
    } else {
        // 从就绪队列中移除，然后加入信号量的等待队列
        task_t * curr = task_manager.curr_task;
   1842e:	a1 64 fc 05 00       	mov    0x5fc64,%eax
   18433:	89 45 f0             	mov    %eax,-0x10(%ebp)
        set_block(curr);
   18436:	83 ec 0c             	sub    $0xc,%esp
   18439:	ff 75 f0             	pushl  -0x10(%ebp)
   1843c:	e8 d0 94 ff ff       	call   11911 <set_block>
   18441:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list, &curr->wait_node);
   18444:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18447:	8d 50 18             	lea    0x18(%eax),%edx
   1844a:	8b 45 08             	mov    0x8(%ebp),%eax
   1844d:	83 c0 04             	add    $0x4,%eax
   18450:	83 ec 08             	sub    $0x8,%esp
   18453:	52                   	push   %edx
   18454:	50                   	push   %eax
   18455:	e8 62 09 00 00       	call   18dbc <list_insert_last>
   1845a:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   1845d:	e8 7c 95 ff ff       	call   119de <task_dispatch>
    }

    leave_protection(irq_state);
   18462:	83 ec 0c             	sub    $0xc,%esp
   18465:	ff 75 f4             	pushl  -0xc(%ebp)
   18468:	e8 d1 af ff ff       	call   1343e <leave_protection>
   1846d:	83 c4 10             	add    $0x10,%esp
}
   18470:	90                   	nop
   18471:	c9                   	leave  
   18472:	c3                   	ret    

00018473 <sem_notify>:

/**
 * 释放信号量
 */
void sem_notify (sem_t * sem) {
   18473:	55                   	push   %ebp
   18474:	89 e5                	mov    %esp,%ebp
   18476:	83 ec 18             	sub    $0x18,%esp
    irq_state_t  irq_state = enter_protection();
   18479:	e8 a8 af ff ff       	call   13426 <enter_protection>
   1847e:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (list_count(&sem->wait_list)) {
   18481:	8b 45 08             	mov    0x8(%ebp),%eax
   18484:	83 c0 04             	add    $0x4,%eax
   18487:	83 ec 0c             	sub    $0xc,%esp
   1848a:	50                   	push   %eax
   1848b:	e8 4a ff ff ff       	call   183da <list_count>
   18490:	83 c4 10             	add    $0x10,%esp
   18493:	85 c0                	test   %eax,%eax
   18495:	74 40                	je     184d7 <sem_notify+0x64>
        // 有进程等待，则唤醒加入就绪队列
        list_node_t * node = list_remove_first(&sem->wait_list);
   18497:	8b 45 08             	mov    0x8(%ebp),%eax
   1849a:	83 c0 04             	add    $0x4,%eax
   1849d:	83 ec 0c             	sub    $0xc,%esp
   184a0:	50                   	push   %eax
   184a1:	e8 7a 09 00 00       	call   18e20 <list_remove_first>
   184a6:	83 c4 10             	add    $0x10,%esp
   184a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_t * task = LIST_NODE_PARENT(node, task_t, wait_node);
   184ac:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   184b0:	74 08                	je     184ba <sem_notify+0x47>
   184b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   184b5:	83 e8 18             	sub    $0x18,%eax
   184b8:	eb 05                	jmp    184bf <sem_notify+0x4c>
   184ba:	b8 00 00 00 00       	mov    $0x0,%eax
   184bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
        set_ready(task);
   184c2:	83 ec 0c             	sub    $0xc,%esp
   184c5:	ff 75 ec             	pushl  -0x14(%ebp)
   184c8:	e8 10 94 ff ff       	call   118dd <set_ready>
   184cd:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   184d0:	e8 09 95 ff ff       	call   119de <task_dispatch>
   184d5:	eb 0d                	jmp    184e4 <sem_notify+0x71>
    } else {
        sem->count++;
   184d7:	8b 45 08             	mov    0x8(%ebp),%eax
   184da:	8b 00                	mov    (%eax),%eax
   184dc:	8d 50 01             	lea    0x1(%eax),%edx
   184df:	8b 45 08             	mov    0x8(%ebp),%eax
   184e2:	89 10                	mov    %edx,(%eax)
    }

    leave_protection(irq_state);
   184e4:	83 ec 0c             	sub    $0xc,%esp
   184e7:	ff 75 f4             	pushl  -0xc(%ebp)
   184ea:	e8 4f af ff ff       	call   1343e <leave_protection>
   184ef:	83 c4 10             	add    $0x10,%esp
}
   184f2:	90                   	nop
   184f3:	c9                   	leave  
   184f4:	c3                   	ret    

000184f5 <sem_count>:

/**
 * 获取信号量的当前值
 */
int sem_count (sem_t * sem) {
   184f5:	55                   	push   %ebp
   184f6:	89 e5                	mov    %esp,%ebp
   184f8:	83 ec 18             	sub    $0x18,%esp
    irq_state_t  irq_state = enter_protection();
   184fb:	e8 26 af ff ff       	call   13426 <enter_protection>
   18500:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count = sem->count;
   18503:	8b 45 08             	mov    0x8(%ebp),%eax
   18506:	8b 00                	mov    (%eax),%eax
   18508:	89 45 f0             	mov    %eax,-0x10(%ebp)
    leave_protection(irq_state);
   1850b:	83 ec 0c             	sub    $0xc,%esp
   1850e:	ff 75 f4             	pushl  -0xc(%ebp)
   18511:	e8 28 af ff ff       	call   1343e <leave_protection>
   18516:	83 c4 10             	add    $0x10,%esp
    return count;
   18519:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1851c:	c9                   	leave  
   1851d:	c3                   	ret    

0001851e <bitmap_init>:
#include "tools/bitmap.h"
#include "tools/klib.h"
void bitmap_init(bitmap_t* bitm, uint8_t* bit, int count, int default_value)
{
   1851e:	55                   	push   %ebp
   1851f:	89 e5                	mov    %esp,%ebp
   18521:	83 ec 18             	sub    $0x18,%esp
    bitm -> count = count;
   18524:	8b 45 08             	mov    0x8(%ebp),%eax
   18527:	8b 55 10             	mov    0x10(%ebp),%edx
   1852a:	89 10                	mov    %edx,(%eax)
    bitm -> pbit = bit;
   1852c:	8b 45 08             	mov    0x8(%ebp),%eax
   1852f:	8b 55 0c             	mov    0xc(%ebp),%edx
   18532:	89 50 04             	mov    %edx,0x4(%eax)
    int bytes = bit_count(bitm->count);
   18535:	8b 45 08             	mov    0x8(%ebp),%eax
   18538:	8b 00                	mov    (%eax),%eax
   1853a:	83 ec 0c             	sub    $0xc,%esp
   1853d:	50                   	push   %eax
   1853e:	e8 31 00 00 00       	call   18574 <bit_count>
   18543:	83 c4 10             	add    $0x10,%esp
   18546:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_memset(bitm->pbit, default_value ? 0xFF: 0, bytes);
   18549:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1854d:	74 07                	je     18556 <bitmap_init+0x38>
   1854f:	ba ff 00 00 00       	mov    $0xff,%edx
   18554:	eb 05                	jmp    1855b <bitmap_init+0x3d>
   18556:	ba 00 00 00 00       	mov    $0x0,%edx
   1855b:	8b 45 08             	mov    0x8(%ebp),%eax
   1855e:	8b 40 04             	mov    0x4(%eax),%eax
   18561:	83 ec 04             	sub    $0x4,%esp
   18564:	ff 75 f4             	pushl  -0xc(%ebp)
   18567:	52                   	push   %edx
   18568:	50                   	push   %eax
   18569:	e8 34 04 00 00       	call   189a2 <kernel_memset>
   1856e:	83 c4 10             	add    $0x10,%esp
}
   18571:	90                   	nop
   18572:	c9                   	leave  
   18573:	c3                   	ret    

00018574 <bit_count>:

int bit_count(int count){
   18574:	55                   	push   %ebp
   18575:	89 e5                	mov    %esp,%ebp
    return (count + 8 - 1)/8;
   18577:	8b 45 08             	mov    0x8(%ebp),%eax
   1857a:	83 c0 07             	add    $0x7,%eax
   1857d:	8d 50 07             	lea    0x7(%eax),%edx
   18580:	85 c0                	test   %eax,%eax
   18582:	0f 48 c2             	cmovs  %edx,%eax
   18585:	c1 f8 03             	sar    $0x3,%eax
}
   18588:	5d                   	pop    %ebp
   18589:	c3                   	ret    

0001858a <bitmap_get_index>:

int bitmap_get_index(bitmap_t* bitmap, int index)
{
   1858a:	55                   	push   %ebp
   1858b:	89 e5                	mov    %esp,%ebp
   1858d:	53                   	push   %ebx
    return bitmap->pbit[index/8] & (1 << (index % 8));
   1858e:	8b 45 08             	mov    0x8(%ebp),%eax
   18591:	8b 50 04             	mov    0x4(%eax),%edx
   18594:	8b 45 0c             	mov    0xc(%ebp),%eax
   18597:	8d 48 07             	lea    0x7(%eax),%ecx
   1859a:	85 c0                	test   %eax,%eax
   1859c:	0f 48 c1             	cmovs  %ecx,%eax
   1859f:	c1 f8 03             	sar    $0x3,%eax
   185a2:	01 d0                	add    %edx,%eax
   185a4:	0f b6 00             	movzbl (%eax),%eax
   185a7:	0f b6 d8             	movzbl %al,%ebx
   185aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   185ad:	99                   	cltd   
   185ae:	c1 ea 1d             	shr    $0x1d,%edx
   185b1:	01 d0                	add    %edx,%eax
   185b3:	83 e0 07             	and    $0x7,%eax
   185b6:	29 d0                	sub    %edx,%eax
   185b8:	ba 01 00 00 00       	mov    $0x1,%edx
   185bd:	89 c1                	mov    %eax,%ecx
   185bf:	d3 e2                	shl    %cl,%edx
   185c1:	89 d0                	mov    %edx,%eax
   185c3:	21 d8                	and    %ebx,%eax
}
   185c5:	5b                   	pop    %ebx
   185c6:	5d                   	pop    %ebp
   185c7:	c3                   	ret    

000185c8 <bitmap_set_nbit>:

void bitmap_set_nbit(bitmap_t* bitmap, int index, int count, int bit)
{
   185c8:	55                   	push   %ebp
   185c9:	89 e5                	mov    %esp,%ebp
   185cb:	56                   	push   %esi
   185cc:	53                   	push   %ebx
   185cd:	83 ec 10             	sub    $0x10,%esp
    for(int i = 0; i < count&& index < bitmap->count; ++i, ++index){
   185d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   185d7:	e9 a2 00 00 00       	jmp    1867e <bitmap_set_nbit+0xb6>
        if(bit == 1)
   185dc:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
   185e0:	75 4a                	jne    1862c <bitmap_set_nbit+0x64>
        {
            bitmap->pbit[index/8] |= (1 << (index % 8));
   185e2:	8b 45 08             	mov    0x8(%ebp),%eax
   185e5:	8b 50 04             	mov    0x4(%eax),%edx
   185e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   185eb:	8d 48 07             	lea    0x7(%eax),%ecx
   185ee:	85 c0                	test   %eax,%eax
   185f0:	0f 48 c1             	cmovs  %ecx,%eax
   185f3:	c1 f8 03             	sar    $0x3,%eax
   185f6:	89 c3                	mov    %eax,%ebx
   185f8:	89 d8                	mov    %ebx,%eax
   185fa:	01 d0                	add    %edx,%eax
   185fc:	0f b6 00             	movzbl (%eax),%eax
   185ff:	89 c6                	mov    %eax,%esi
   18601:	8b 45 0c             	mov    0xc(%ebp),%eax
   18604:	99                   	cltd   
   18605:	c1 ea 1d             	shr    $0x1d,%edx
   18608:	01 d0                	add    %edx,%eax
   1860a:	83 e0 07             	and    $0x7,%eax
   1860d:	29 d0                	sub    %edx,%eax
   1860f:	ba 01 00 00 00       	mov    $0x1,%edx
   18614:	89 c1                	mov    %eax,%ecx
   18616:	d3 e2                	shl    %cl,%edx
   18618:	89 d0                	mov    %edx,%eax
   1861a:	89 f2                	mov    %esi,%edx
   1861c:	09 c2                	or     %eax,%edx
   1861e:	8b 45 08             	mov    0x8(%ebp),%eax
   18621:	8b 40 04             	mov    0x4(%eax),%eax
   18624:	89 d9                	mov    %ebx,%ecx
   18626:	01 c8                	add    %ecx,%eax
   18628:	88 10                	mov    %dl,(%eax)
   1862a:	eb 4a                	jmp    18676 <bitmap_set_nbit+0xae>
        }
        else{
            bitmap->pbit[index/8] &= ~(1 << (index % 8));
   1862c:	8b 45 08             	mov    0x8(%ebp),%eax
   1862f:	8b 50 04             	mov    0x4(%eax),%edx
   18632:	8b 45 0c             	mov    0xc(%ebp),%eax
   18635:	8d 48 07             	lea    0x7(%eax),%ecx
   18638:	85 c0                	test   %eax,%eax
   1863a:	0f 48 c1             	cmovs  %ecx,%eax
   1863d:	c1 f8 03             	sar    $0x3,%eax
   18640:	89 c3                	mov    %eax,%ebx
   18642:	89 d8                	mov    %ebx,%eax
   18644:	01 d0                	add    %edx,%eax
   18646:	0f b6 00             	movzbl (%eax),%eax
   18649:	89 c6                	mov    %eax,%esi
   1864b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1864e:	99                   	cltd   
   1864f:	c1 ea 1d             	shr    $0x1d,%edx
   18652:	01 d0                	add    %edx,%eax
   18654:	83 e0 07             	and    $0x7,%eax
   18657:	29 d0                	sub    %edx,%eax
   18659:	ba 01 00 00 00       	mov    $0x1,%edx
   1865e:	89 c1                	mov    %eax,%ecx
   18660:	d3 e2                	shl    %cl,%edx
   18662:	89 d0                	mov    %edx,%eax
   18664:	f7 d0                	not    %eax
   18666:	89 f2                	mov    %esi,%edx
   18668:	21 c2                	and    %eax,%edx
   1866a:	8b 45 08             	mov    0x8(%ebp),%eax
   1866d:	8b 40 04             	mov    0x4(%eax),%eax
   18670:	89 d9                	mov    %ebx,%ecx
   18672:	01 c8                	add    %ecx,%eax
   18674:	88 10                	mov    %dl,(%eax)
    for(int i = 0; i < count&& index < bitmap->count; ++i, ++index){
   18676:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1867a:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   1867e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18681:	3b 45 10             	cmp    0x10(%ebp),%eax
   18684:	7d 0e                	jge    18694 <bitmap_set_nbit+0xcc>
   18686:	8b 45 08             	mov    0x8(%ebp),%eax
   18689:	8b 00                	mov    (%eax),%eax
   1868b:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1868e:	0f 8c 48 ff ff ff    	jl     185dc <bitmap_set_nbit+0x14>
        }
    }
}
   18694:	90                   	nop
   18695:	83 c4 10             	add    $0x10,%esp
   18698:	5b                   	pop    %ebx
   18699:	5e                   	pop    %esi
   1869a:	5d                   	pop    %ebp
   1869b:	c3                   	ret    

0001869c <bitmap_is_set>:

int bitmap_is_set(bitmap_t* pbit, int index){
   1869c:	55                   	push   %ebp
   1869d:	89 e5                	mov    %esp,%ebp
    return bitmap_get_index(pbit, index) ? 1 : 0;
   1869f:	ff 75 0c             	pushl  0xc(%ebp)
   186a2:	ff 75 08             	pushl  0x8(%ebp)
   186a5:	e8 e0 fe ff ff       	call   1858a <bitmap_get_index>
   186aa:	83 c4 08             	add    $0x8,%esp
   186ad:	85 c0                	test   %eax,%eax
   186af:	0f 95 c0             	setne  %al
   186b2:	0f b6 c0             	movzbl %al,%eax
}
   186b5:	c9                   	leave  
   186b6:	c3                   	ret    

000186b7 <bitmap_alloc_nbit>:

int bitmap_alloc_nbit(bitmap_t* pbit, int count, int bit)
{
   186b7:	55                   	push   %ebp
   186b8:	89 e5                	mov    %esp,%ebp
   186ba:	83 ec 10             	sub    $0x10,%esp
    int search_idx = 0;
   186bd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_index = -1;
   186c4:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
    
    while(search_idx < pbit->count){
   186cb:	e9 8a 00 00 00       	jmp    1875a <bitmap_alloc_nbit+0xa3>
        if(bitmap_get_index(pbit, search_idx) != bit)
   186d0:	ff 75 fc             	pushl  -0x4(%ebp)
   186d3:	ff 75 08             	pushl  0x8(%ebp)
   186d6:	e8 af fe ff ff       	call   1858a <bitmap_get_index>
   186db:	83 c4 08             	add    $0x8,%esp
   186de:	39 45 10             	cmp    %eax,0x10(%ebp)
   186e1:	74 06                	je     186e9 <bitmap_alloc_nbit+0x32>
        {
            ++search_idx;
   186e3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   186e7:	eb 71                	jmp    1875a <bitmap_alloc_nbit+0xa3>
        }
        ok_index  = search_idx;
   186e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   186ec:	89 45 f8             	mov    %eax,-0x8(%ebp)
        int i = 1;
   186ef:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
        for(; i < count && search_idx < pbit->count; ++i){
   186f6:	eb 27                	jmp    1871f <bitmap_alloc_nbit+0x68>
            if(bitmap_get_index(pbit, search_idx++) != bit)
   186f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   186fb:	8d 50 01             	lea    0x1(%eax),%edx
   186fe:	89 55 fc             	mov    %edx,-0x4(%ebp)
   18701:	50                   	push   %eax
   18702:	ff 75 08             	pushl  0x8(%ebp)
   18705:	e8 80 fe ff ff       	call   1858a <bitmap_get_index>
   1870a:	83 c4 08             	add    $0x8,%esp
   1870d:	39 45 10             	cmp    %eax,0x10(%ebp)
   18710:	74 09                	je     1871b <bitmap_alloc_nbit+0x64>
            {
                ok_index = -1;
   18712:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   18719:	eb 16                	jmp    18731 <bitmap_alloc_nbit+0x7a>
        for(; i < count && search_idx < pbit->count; ++i){
   1871b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1871f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18722:	3b 45 0c             	cmp    0xc(%ebp),%eax
   18725:	7d 0a                	jge    18731 <bitmap_alloc_nbit+0x7a>
   18727:	8b 45 08             	mov    0x8(%ebp),%eax
   1872a:	8b 00                	mov    (%eax),%eax
   1872c:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   1872f:	7c c7                	jl     186f8 <bitmap_alloc_nbit+0x41>
            }      
        }
        if(i >= count){
   18731:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18734:	3b 45 0c             	cmp    0xc(%ebp),%eax
   18737:	7c 21                	jl     1875a <bitmap_alloc_nbit+0xa3>
            bitmap_set_nbit(pbit, ok_index, count, !bit);
   18739:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1873d:	0f 94 c0             	sete   %al
   18740:	0f b6 c0             	movzbl %al,%eax
   18743:	50                   	push   %eax
   18744:	ff 75 0c             	pushl  0xc(%ebp)
   18747:	ff 75 f8             	pushl  -0x8(%ebp)
   1874a:	ff 75 08             	pushl  0x8(%ebp)
   1874d:	e8 76 fe ff ff       	call   185c8 <bitmap_set_nbit>
   18752:	83 c4 10             	add    $0x10,%esp
            return ok_index;
   18755:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18758:	eb 13                	jmp    1876d <bitmap_alloc_nbit+0xb6>
    while(search_idx < pbit->count){
   1875a:	8b 45 08             	mov    0x8(%ebp),%eax
   1875d:	8b 00                	mov    (%eax),%eax
   1875f:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   18762:	0f 8c 68 ff ff ff    	jl     186d0 <bitmap_alloc_nbit+0x19>
        } 
    }     
    
    
    return -1;
   18768:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1876d:	c9                   	leave  
   1876e:	c3                   	ret    

0001876f <hlt>:
static inline void hlt() {
   1876f:	55                   	push   %ebp
   18770:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("hlt");
   18772:	f4                   	hlt    
}
   18773:	90                   	nop
   18774:	5d                   	pop    %ebp
   18775:	c3                   	ret    

00018776 <count_string>:
#include "tools/klib.h"
int count_string(char* const * start)
{
   18776:	55                   	push   %ebp
   18777:	89 e5                	mov    %esp,%ebp
   18779:	83 ec 10             	sub    $0x10,%esp
    int count =0;
   1877c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    if(start)
   18783:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   18787:	74 13                	je     1879c <count_string+0x26>
    {
        while(*start)
   18789:	eb 08                	jmp    18793 <count_string+0x1d>
        {
            start++;
   1878b:	83 45 08 04          	addl   $0x4,0x8(%ebp)
            count ++;
   1878f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        while(*start)
   18793:	8b 45 08             	mov    0x8(%ebp),%eax
   18796:	8b 00                	mov    (%eax),%eax
   18798:	85 c0                	test   %eax,%eax
   1879a:	75 ef                	jne    1878b <count_string+0x15>
        }
    }
    return count;
   1879c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1879f:	c9                   	leave  
   187a0:	c3                   	ret    

000187a1 <get_filename>:
char* get_filename(char* name)
{
   187a1:	55                   	push   %ebp
   187a2:	89 e5                	mov    %esp,%ebp
   187a4:	83 ec 10             	sub    $0x10,%esp
    char* s = name;
   187a7:	8b 45 08             	mov    0x8(%ebp),%eax
   187aa:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(*s != '\0')
   187ad:	eb 04                	jmp    187b3 <get_filename+0x12>
    {
        s++;
   187af:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while(*s != '\0')
   187b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   187b6:	0f b6 00             	movzbl (%eax),%eax
   187b9:	84 c0                	test   %al,%al
   187bb:	75 f2                	jne    187af <get_filename+0xe>
    }
    while(*s != '/' && *s !='\\' && s >= name)
   187bd:	eb 04                	jmp    187c3 <get_filename+0x22>
    {
        s--;
   187bf:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while(*s != '/' && *s !='\\' && s >= name)
   187c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   187c6:	0f b6 00             	movzbl (%eax),%eax
   187c9:	3c 2f                	cmp    $0x2f,%al
   187cb:	74 12                	je     187df <get_filename+0x3e>
   187cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
   187d0:	0f b6 00             	movzbl (%eax),%eax
   187d3:	3c 5c                	cmp    $0x5c,%al
   187d5:	74 08                	je     187df <get_filename+0x3e>
   187d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   187da:	3b 45 08             	cmp    0x8(%ebp),%eax
   187dd:	73 e0                	jae    187bf <get_filename+0x1e>
    }
    return s+1;
   187df:	8b 45 fc             	mov    -0x4(%ebp),%eax
   187e2:	83 c0 01             	add    $0x1,%eax
}
   187e5:	c9                   	leave  
   187e6:	c3                   	ret    

000187e7 <kernel_strcpy>:
void kernel_strcpy (char * dest, const char * src) {
   187e7:	55                   	push   %ebp
   187e8:	89 e5                	mov    %esp,%ebp
    if (!dest || !src) {
   187ea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   187ee:	74 3b                	je     1882b <kernel_strcpy+0x44>
   187f0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   187f4:	74 35                	je     1882b <kernel_strcpy+0x44>
        return;
    }

    while (*dest && *src) {
   187f6:	eb 17                	jmp    1880f <kernel_strcpy+0x28>
        *dest++ = *src++;
   187f8:	8b 55 0c             	mov    0xc(%ebp),%edx
   187fb:	8d 42 01             	lea    0x1(%edx),%eax
   187fe:	89 45 0c             	mov    %eax,0xc(%ebp)
   18801:	8b 45 08             	mov    0x8(%ebp),%eax
   18804:	8d 48 01             	lea    0x1(%eax),%ecx
   18807:	89 4d 08             	mov    %ecx,0x8(%ebp)
   1880a:	0f b6 12             	movzbl (%edx),%edx
   1880d:	88 10                	mov    %dl,(%eax)
    while (*dest && *src) {
   1880f:	8b 45 08             	mov    0x8(%ebp),%eax
   18812:	0f b6 00             	movzbl (%eax),%eax
   18815:	84 c0                	test   %al,%al
   18817:	74 0a                	je     18823 <kernel_strcpy+0x3c>
   18819:	8b 45 0c             	mov    0xc(%ebp),%eax
   1881c:	0f b6 00             	movzbl (%eax),%eax
   1881f:	84 c0                	test   %al,%al
   18821:	75 d5                	jne    187f8 <kernel_strcpy+0x11>
    }
    *dest = '\0';
   18823:	8b 45 08             	mov    0x8(%ebp),%eax
   18826:	c6 00 00             	movb   $0x0,(%eax)
   18829:	eb 01                	jmp    1882c <kernel_strcpy+0x45>
        return;
   1882b:	90                   	nop
}
   1882c:	5d                   	pop    %ebp
   1882d:	c3                   	ret    

0001882e <kernel_strncpy>:

void kernel_strncpy(char * dest, const char * src, int size) {
   1882e:	55                   	push   %ebp
   1882f:	89 e5                	mov    %esp,%ebp
   18831:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size) {
   18834:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   18838:	74 61                	je     1889b <kernel_strncpy+0x6d>
   1883a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1883e:	74 5b                	je     1889b <kernel_strncpy+0x6d>
   18840:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   18844:	74 55                	je     1889b <kernel_strncpy+0x6d>
        return;
    }

    char * d = dest;
   18846:	8b 45 08             	mov    0x8(%ebp),%eax
   18849:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char * s = src;
   1884c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1884f:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while ((size-- > 0) && (*s)) {
   18852:	eb 17                	jmp    1886b <kernel_strncpy+0x3d>
        *d++ = *s++;
   18854:	8b 55 f8             	mov    -0x8(%ebp),%edx
   18857:	8d 42 01             	lea    0x1(%edx),%eax
   1885a:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1885d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18860:	8d 48 01             	lea    0x1(%eax),%ecx
   18863:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   18866:	0f b6 12             	movzbl (%edx),%edx
   18869:	88 10                	mov    %dl,(%eax)
    while ((size-- > 0) && (*s)) {
   1886b:	8b 45 10             	mov    0x10(%ebp),%eax
   1886e:	8d 50 ff             	lea    -0x1(%eax),%edx
   18871:	89 55 10             	mov    %edx,0x10(%ebp)
   18874:	85 c0                	test   %eax,%eax
   18876:	7e 0a                	jle    18882 <kernel_strncpy+0x54>
   18878:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1887b:	0f b6 00             	movzbl (%eax),%eax
   1887e:	84 c0                	test   %al,%al
   18880:	75 d2                	jne    18854 <kernel_strncpy+0x26>
    }
    if (size == 0) {
   18882:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   18886:	75 0b                	jne    18893 <kernel_strncpy+0x65>
        *(d - 1) = '\0';
   18888:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1888b:	83 e8 01             	sub    $0x1,%eax
   1888e:	c6 00 00             	movb   $0x0,(%eax)
   18891:	eb 09                	jmp    1889c <kernel_strncpy+0x6e>
    } else {
        *d = '\0';
   18893:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18896:	c6 00 00             	movb   $0x0,(%eax)
   18899:	eb 01                	jmp    1889c <kernel_strncpy+0x6e>
        return;
   1889b:	90                   	nop
    }
}
   1889c:	c9                   	leave  
   1889d:	c3                   	ret    

0001889e <kernel_strlen>:

int kernel_strlen(const char * str) {
   1889e:	55                   	push   %ebp
   1889f:	89 e5                	mov    %esp,%ebp
   188a1:	83 ec 10             	sub    $0x10,%esp
    if (str == (const char *)0) {
   188a4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   188a8:	75 07                	jne    188b1 <kernel_strlen+0x13>
        return 0;
   188aa:	b8 00 00 00 00       	mov    $0x0,%eax
   188af:	eb 26                	jmp    188d7 <kernel_strlen+0x39>
    }

	const char * c = str;
   188b1:	8b 45 08             	mov    0x8(%ebp),%eax
   188b4:	89 45 fc             	mov    %eax,-0x4(%ebp)

	int len = 0;
   188b7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	while (*c++) {
   188be:	eb 04                	jmp    188c4 <kernel_strlen+0x26>
		len++;
   188c0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	while (*c++) {
   188c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   188c7:	8d 50 01             	lea    0x1(%eax),%edx
   188ca:	89 55 fc             	mov    %edx,-0x4(%ebp)
   188cd:	0f b6 00             	movzbl (%eax),%eax
   188d0:	84 c0                	test   %al,%al
   188d2:	75 ec                	jne    188c0 <kernel_strlen+0x22>
	}

	return len;
   188d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
   188d7:	c9                   	leave  
   188d8:	c3                   	ret    

000188d9 <kernel_strncmp>:


int kernel_strncmp (const char * s1, const char * s2, int size) {
   188d9:	55                   	push   %ebp
   188da:	89 e5                	mov    %esp,%ebp
    if (!s1 || !s2) {
   188dc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   188e0:	74 06                	je     188e8 <kernel_strncmp+0xf>
   188e2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   188e6:	75 0f                	jne    188f7 <kernel_strncmp+0x1e>
        return -1;
   188e8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   188ed:	eb 62                	jmp    18951 <kernel_strncmp+0x78>
    }

    while (*s1 && *s2 && (*s1 == *s2) && size) {
    	s1++;
   188ef:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    	s2++;
   188f3:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    while (*s1 && *s2 && (*s1 == *s2) && size) {
   188f7:	8b 45 08             	mov    0x8(%ebp),%eax
   188fa:	0f b6 00             	movzbl (%eax),%eax
   188fd:	84 c0                	test   %al,%al
   188ff:	74 20                	je     18921 <kernel_strncmp+0x48>
   18901:	8b 45 0c             	mov    0xc(%ebp),%eax
   18904:	0f b6 00             	movzbl (%eax),%eax
   18907:	84 c0                	test   %al,%al
   18909:	74 16                	je     18921 <kernel_strncmp+0x48>
   1890b:	8b 45 08             	mov    0x8(%ebp),%eax
   1890e:	0f b6 10             	movzbl (%eax),%edx
   18911:	8b 45 0c             	mov    0xc(%ebp),%eax
   18914:	0f b6 00             	movzbl (%eax),%eax
   18917:	38 c2                	cmp    %al,%dl
   18919:	75 06                	jne    18921 <kernel_strncmp+0x48>
   1891b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1891f:	75 ce                	jne    188ef <kernel_strncmp+0x16>
    }

    return !((*s1 == '\0') || (*s2 == '\0') || (*s1 == *s2));
   18921:	8b 45 08             	mov    0x8(%ebp),%eax
   18924:	0f b6 00             	movzbl (%eax),%eax
   18927:	84 c0                	test   %al,%al
   18929:	74 21                	je     1894c <kernel_strncmp+0x73>
   1892b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1892e:	0f b6 00             	movzbl (%eax),%eax
   18931:	84 c0                	test   %al,%al
   18933:	74 17                	je     1894c <kernel_strncmp+0x73>
   18935:	8b 45 08             	mov    0x8(%ebp),%eax
   18938:	0f b6 10             	movzbl (%eax),%edx
   1893b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1893e:	0f b6 00             	movzbl (%eax),%eax
   18941:	38 c2                	cmp    %al,%dl
   18943:	74 07                	je     1894c <kernel_strncmp+0x73>
   18945:	b8 01 00 00 00       	mov    $0x1,%eax
   1894a:	eb 05                	jmp    18951 <kernel_strncmp+0x78>
   1894c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   18951:	5d                   	pop    %ebp
   18952:	c3                   	ret    

00018953 <kernel_memcpy>:

void kernel_memcpy (void * dest, void * src, int size) {
   18953:	55                   	push   %ebp
   18954:	89 e5                	mov    %esp,%ebp
   18956:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size) {
   18959:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1895d:	74 40                	je     1899f <kernel_memcpy+0x4c>
   1895f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   18963:	74 3a                	je     1899f <kernel_memcpy+0x4c>
   18965:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   18969:	74 34                	je     1899f <kernel_memcpy+0x4c>
        return;
    }

    uint8_t * s = (uint8_t *)src;
   1896b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1896e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t * d = (uint8_t *)dest;
   18971:	8b 45 08             	mov    0x8(%ebp),%eax
   18974:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (size--) {
   18977:	eb 17                	jmp    18990 <kernel_memcpy+0x3d>
        *d++ = *s++;
   18979:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1897c:	8d 42 01             	lea    0x1(%edx),%eax
   1897f:	89 45 fc             	mov    %eax,-0x4(%ebp)
   18982:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18985:	8d 48 01             	lea    0x1(%eax),%ecx
   18988:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   1898b:	0f b6 12             	movzbl (%edx),%edx
   1898e:	88 10                	mov    %dl,(%eax)
    while (size--) {
   18990:	8b 45 10             	mov    0x10(%ebp),%eax
   18993:	8d 50 ff             	lea    -0x1(%eax),%edx
   18996:	89 55 10             	mov    %edx,0x10(%ebp)
   18999:	85 c0                	test   %eax,%eax
   1899b:	75 dc                	jne    18979 <kernel_memcpy+0x26>
   1899d:	eb 01                	jmp    189a0 <kernel_memcpy+0x4d>
        return;
   1899f:	90                   	nop
    }
}
   189a0:	c9                   	leave  
   189a1:	c3                   	ret    

000189a2 <kernel_memset>:

void kernel_memset(void * dest, uint8_t v, int size) {
   189a2:	55                   	push   %ebp
   189a3:	89 e5                	mov    %esp,%ebp
   189a5:	83 ec 14             	sub    $0x14,%esp
   189a8:	8b 45 0c             	mov    0xc(%ebp),%eax
   189ab:	88 45 ec             	mov    %al,-0x14(%ebp)
    if (!dest || !size) {
   189ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   189b2:	74 2c                	je     189e0 <kernel_memset+0x3e>
   189b4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   189b8:	74 26                	je     189e0 <kernel_memset+0x3e>
        return;
    }

    uint8_t * d = (uint8_t *)dest;
   189ba:	8b 45 08             	mov    0x8(%ebp),%eax
   189bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (size--) {
   189c0:	eb 0f                	jmp    189d1 <kernel_memset+0x2f>
        *d++ = v;
   189c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   189c5:	8d 50 01             	lea    0x1(%eax),%edx
   189c8:	89 55 fc             	mov    %edx,-0x4(%ebp)
   189cb:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   189cf:	88 10                	mov    %dl,(%eax)
    while (size--) {
   189d1:	8b 45 10             	mov    0x10(%ebp),%eax
   189d4:	8d 50 ff             	lea    -0x1(%eax),%edx
   189d7:	89 55 10             	mov    %edx,0x10(%ebp)
   189da:	85 c0                	test   %eax,%eax
   189dc:	75 e4                	jne    189c2 <kernel_memset+0x20>
   189de:	eb 01                	jmp    189e1 <kernel_memset+0x3f>
        return;
   189e0:	90                   	nop
    }
}
   189e1:	c9                   	leave  
   189e2:	c3                   	ret    

000189e3 <kernel_memcmp>:

int kernel_memcmp (void * d1, void * d2, int size) {
   189e3:	55                   	push   %ebp
   189e4:	89 e5                	mov    %esp,%ebp
   189e6:	83 ec 10             	sub    $0x10,%esp
    if (!d1 || !d2) {
   189e9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   189ed:	74 06                	je     189f5 <kernel_memcmp+0x12>
   189ef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   189f3:	75 07                	jne    189fc <kernel_memcmp+0x19>
        return 1;
   189f5:	b8 01 00 00 00       	mov    $0x1,%eax
   189fa:	eb 43                	jmp    18a3f <kernel_memcmp+0x5c>
    }

	uint8_t * p_d1 = (uint8_t *)d1;
   189fc:	8b 45 08             	mov    0x8(%ebp),%eax
   189ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint8_t * p_d2 = (uint8_t *)d2;
   18a02:	8b 45 0c             	mov    0xc(%ebp),%eax
   18a05:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (size--) {
   18a08:	eb 23                	jmp    18a2d <kernel_memcmp+0x4a>
		if (*p_d1++ != *p_d2++) {
   18a0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18a0d:	8d 50 01             	lea    0x1(%eax),%edx
   18a10:	89 55 fc             	mov    %edx,-0x4(%ebp)
   18a13:	0f b6 08             	movzbl (%eax),%ecx
   18a16:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18a19:	8d 50 01             	lea    0x1(%eax),%edx
   18a1c:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18a1f:	0f b6 00             	movzbl (%eax),%eax
   18a22:	38 c1                	cmp    %al,%cl
   18a24:	74 07                	je     18a2d <kernel_memcmp+0x4a>
			return 1; 
   18a26:	b8 01 00 00 00       	mov    $0x1,%eax
   18a2b:	eb 12                	jmp    18a3f <kernel_memcmp+0x5c>
	while (size--) {
   18a2d:	8b 45 10             	mov    0x10(%ebp),%eax
   18a30:	8d 50 ff             	lea    -0x1(%eax),%edx
   18a33:	89 55 10             	mov    %edx,0x10(%ebp)
   18a36:	85 c0                	test   %eax,%eax
   18a38:	75 d0                	jne    18a0a <kernel_memcmp+0x27>
		}
	}

	return 0;
   18a3a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   18a3f:	c9                   	leave  
   18a40:	c3                   	ret    

00018a41 <kernel_itoa>:
void kernel_itoa(char* buf, int num, int base){
   18a41:	55                   	push   %ebp
   18a42:	89 e5                	mov    %esp,%ebp
   18a44:	53                   	push   %ebx
   18a45:	83 ec 20             	sub    $0x20,%esp
     static const char * num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char * p = buf;
   18a48:	8b 45 08             	mov    0x8(%ebp),%eax
   18a4b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int old_num = num;
   18a4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   18a51:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if ((base != 2) && (base != 8) && (base != 10) && (base != 16)) {
   18a54:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   18a58:	74 1d                	je     18a77 <kernel_itoa+0x36>
   18a5a:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   18a5e:	74 17                	je     18a77 <kernel_itoa+0x36>
   18a60:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   18a64:	74 11                	je     18a77 <kernel_itoa+0x36>
   18a66:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   18a6a:	74 0b                	je     18a77 <kernel_itoa+0x36>
        *p = '\0';
   18a6c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18a6f:	c6 00 00             	movb   $0x0,(%eax)
        return;
   18a72:	e9 03 01 00 00       	jmp    18b7a <kernel_itoa+0x139>
    }

    int signed_num = 0;
   18a77:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if ((num < 0) && (base == 10)) {
   18a7e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   18a82:	79 19                	jns    18a9d <kernel_itoa+0x5c>
   18a84:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   18a88:	75 13                	jne    18a9d <kernel_itoa+0x5c>
        *p++ = '-';
   18a8a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18a8d:	8d 50 01             	lea    0x1(%eax),%edx
   18a90:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18a93:	c6 00 2d             	movb   $0x2d,(%eax)
        signed_num = 1;
   18a96:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    }

    if (signed_num) {
   18a9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   18aa1:	74 3b                	je     18ade <kernel_itoa+0x9d>
        do {
            char ch = num2ch[num % base + 15];
   18aa3:	8b 0d 74 b1 01 00    	mov    0x1b174,%ecx
   18aa9:	8b 45 0c             	mov    0xc(%ebp),%eax
   18aac:	99                   	cltd   
   18aad:	f7 7d 10             	idivl  0x10(%ebp)
   18ab0:	89 d0                	mov    %edx,%eax
   18ab2:	83 c0 0f             	add    $0xf,%eax
   18ab5:	01 c8                	add    %ecx,%eax
   18ab7:	0f b6 00             	movzbl (%eax),%eax
   18aba:	88 45 e6             	mov    %al,-0x1a(%ebp)
            *p++ = ch;
   18abd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18ac0:	8d 50 01             	lea    0x1(%eax),%edx
   18ac3:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18ac6:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
   18aca:	88 10                	mov    %dl,(%eax)
            num /= base;
   18acc:	8b 45 0c             	mov    0xc(%ebp),%eax
   18acf:	99                   	cltd   
   18ad0:	f7 7d 10             	idivl  0x10(%ebp)
   18ad3:	89 45 0c             	mov    %eax,0xc(%ebp)
        } while (num);
   18ad6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   18ada:	75 c7                	jne    18aa3 <kernel_itoa+0x62>
   18adc:	eb 4b                	jmp    18b29 <kernel_itoa+0xe8>
    } else {
        uint32_t u_num = (uint32_t)num;
   18ade:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ae1:	89 45 f0             	mov    %eax,-0x10(%ebp)
        do {
            char ch = num2ch[u_num % base + 15];
   18ae4:	8b 0d 74 b1 01 00    	mov    0x1b174,%ecx
   18aea:	8b 5d 10             	mov    0x10(%ebp),%ebx
   18aed:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18af0:	ba 00 00 00 00       	mov    $0x0,%edx
   18af5:	f7 f3                	div    %ebx
   18af7:	89 d0                	mov    %edx,%eax
   18af9:	83 c0 0f             	add    $0xf,%eax
   18afc:	01 c8                	add    %ecx,%eax
   18afe:	0f b6 00             	movzbl (%eax),%eax
   18b01:	88 45 e7             	mov    %al,-0x19(%ebp)
            *p++ = ch;
   18b04:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18b07:	8d 50 01             	lea    0x1(%eax),%edx
   18b0a:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18b0d:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
   18b11:	88 10                	mov    %dl,(%eax)
            u_num /= base;
   18b13:	8b 5d 10             	mov    0x10(%ebp),%ebx
   18b16:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18b19:	ba 00 00 00 00       	mov    $0x0,%edx
   18b1e:	f7 f3                	div    %ebx
   18b20:	89 45 f0             	mov    %eax,-0x10(%ebp)
        } while (u_num);
   18b23:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   18b27:	75 bb                	jne    18ae4 <kernel_itoa+0xa3>
    }
    *p-- = '\0';
   18b29:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18b2c:	8d 50 ff             	lea    -0x1(%eax),%edx
   18b2f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18b32:	c6 00 00             	movb   $0x0,(%eax)

    char * start = (!signed_num) ? buf : buf + 1;
   18b35:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   18b39:	74 08                	je     18b43 <kernel_itoa+0x102>
   18b3b:	8b 45 08             	mov    0x8(%ebp),%eax
   18b3e:	83 c0 01             	add    $0x1,%eax
   18b41:	eb 03                	jmp    18b46 <kernel_itoa+0x105>
   18b43:	8b 45 08             	mov    0x8(%ebp),%eax
   18b46:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (start < p) {
   18b49:	eb 27                	jmp    18b72 <kernel_itoa+0x131>
        char ch = *start;
   18b4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18b4e:	0f b6 00             	movzbl (%eax),%eax
   18b51:	88 45 e5             	mov    %al,-0x1b(%ebp)
        *start = *p;
   18b54:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18b57:	0f b6 10             	movzbl (%eax),%edx
   18b5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18b5d:	88 10                	mov    %dl,(%eax)
        *p-- = ch;
   18b5f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18b62:	8d 50 ff             	lea    -0x1(%eax),%edx
   18b65:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18b68:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
   18b6c:	88 10                	mov    %dl,(%eax)
        start++;
   18b6e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    while (start < p) {
   18b72:	8b 45 ec             	mov    -0x14(%ebp),%eax
   18b75:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   18b78:	72 d1                	jb     18b4b <kernel_itoa+0x10a>
    }
}
   18b7a:	83 c4 20             	add    $0x20,%esp
   18b7d:	5b                   	pop    %ebx
   18b7e:	5d                   	pop    %ebp
   18b7f:	c3                   	ret    

00018b80 <kernel_sprintf>:
void kernel_sprintf(char* buf, const char* fmt, ...)
{
   18b80:	55                   	push   %ebp
   18b81:	89 e5                	mov    %esp,%ebp
   18b83:	83 ec 18             	sub    $0x18,%esp
    va_list args;
    va_start(args, fmt);
   18b86:	8d 45 10             	lea    0x10(%ebp),%eax
   18b89:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kernel_vsprintf(buf, fmt, args);
   18b8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   18b8f:	83 ec 04             	sub    $0x4,%esp
   18b92:	50                   	push   %eax
   18b93:	ff 75 0c             	pushl  0xc(%ebp)
   18b96:	ff 75 08             	pushl  0x8(%ebp)
   18b99:	e8 06 00 00 00       	call   18ba4 <kernel_vsprintf>
   18b9e:	83 c4 10             	add    $0x10,%esp
    va_end(args);
}
   18ba1:	90                   	nop
   18ba2:	c9                   	leave  
   18ba3:	c3                   	ret    

00018ba4 <kernel_vsprintf>:
void kernel_vsprintf(char* buf, const char* fmt, va_list args ){
   18ba4:	55                   	push   %ebp
   18ba5:	89 e5                	mov    %esp,%ebp
   18ba7:	83 ec 20             	sub    $0x20,%esp
    enum {NORMAL, FORMAL} state = NORMAL;
   18baa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    char ch;
    char* temp = buf;
   18bb1:	8b 45 08             	mov    0x8(%ebp),%eax
   18bb4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(ch = *fmt++)
   18bb7:	e9 17 01 00 00       	jmp    18cd3 <kernel_vsprintf+0x12f>
    {
        switch (state)
   18bbc:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18bbf:	85 c0                	test   %eax,%eax
   18bc1:	74 0a                	je     18bcd <kernel_vsprintf+0x29>
   18bc3:	83 f8 01             	cmp    $0x1,%eax
   18bc6:	74 2b                	je     18bf3 <kernel_vsprintf+0x4f>
   18bc8:	e9 06 01 00 00       	jmp    18cd3 <kernel_vsprintf+0x12f>
        {
        case NORMAL:
            if(ch == '%')
   18bcd:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   18bd1:	75 0c                	jne    18bdf <kernel_vsprintf+0x3b>
                state = FORMAL;
   18bd3:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   18bda:	e9 f4 00 00 00       	jmp    18cd3 <kernel_vsprintf+0x12f>
            else 
                *temp++ = ch;
   18bdf:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18be2:	8d 50 01             	lea    0x1(%eax),%edx
   18be5:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18be8:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   18bec:	88 10                	mov    %dl,(%eax)
            break;
   18bee:	e9 e0 00 00 00       	jmp    18cd3 <kernel_vsprintf+0x12f>
        case FORMAL:
            if(ch == 's')
   18bf3:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   18bf7:	75 47                	jne    18c40 <kernel_vsprintf+0x9c>
            {const char* cur = va_arg(args, char*);
   18bf9:	8b 45 10             	mov    0x10(%ebp),%eax
   18bfc:	8d 50 04             	lea    0x4(%eax),%edx
   18bff:	89 55 10             	mov    %edx,0x10(%ebp)
   18c02:	8b 00                	mov    (%eax),%eax
   18c04:	89 45 f4             	mov    %eax,-0xc(%ebp)
            int len = kernel_strlen(cur);
   18c07:	ff 75 f4             	pushl  -0xc(%ebp)
   18c0a:	e8 8f fc ff ff       	call   1889e <kernel_strlen>
   18c0f:	83 c4 04             	add    $0x4,%esp
   18c12:	89 45 f0             	mov    %eax,-0x10(%ebp)
            while(len--)
   18c15:	eb 17                	jmp    18c2e <kernel_vsprintf+0x8a>
                *temp++ = *cur++; 
   18c17:	8b 55 f4             	mov    -0xc(%ebp),%edx
   18c1a:	8d 42 01             	lea    0x1(%edx),%eax
   18c1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
   18c20:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18c23:	8d 48 01             	lea    0x1(%eax),%ecx
   18c26:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   18c29:	0f b6 12             	movzbl (%edx),%edx
   18c2c:	88 10                	mov    %dl,(%eax)
            while(len--)
   18c2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   18c31:	8d 50 ff             	lea    -0x1(%eax),%edx
   18c34:	89 55 f0             	mov    %edx,-0x10(%ebp)
   18c37:	85 c0                	test   %eax,%eax
   18c39:	75 dc                	jne    18c17 <kernel_vsprintf+0x73>
   18c3b:	e9 8b 00 00 00       	jmp    18ccb <kernel_vsprintf+0x127>
            }
            else if(ch == 'd'){
   18c40:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   18c44:	75 2e                	jne    18c74 <kernel_vsprintf+0xd0>
                int num = va_arg(args, int);
   18c46:	8b 45 10             	mov    0x10(%ebp),%eax
   18c49:	8d 50 04             	lea    0x4(%eax),%edx
   18c4c:	89 55 10             	mov    %edx,0x10(%ebp)
   18c4f:	8b 00                	mov    (%eax),%eax
   18c51:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                kernel_itoa(temp, num, 10);
   18c54:	6a 0a                	push   $0xa
   18c56:	ff 75 e4             	pushl  -0x1c(%ebp)
   18c59:	ff 75 f8             	pushl  -0x8(%ebp)
   18c5c:	e8 e0 fd ff ff       	call   18a41 <kernel_itoa>
   18c61:	83 c4 0c             	add    $0xc,%esp
                temp += kernel_strlen(temp);
   18c64:	ff 75 f8             	pushl  -0x8(%ebp)
   18c67:	e8 32 fc ff ff       	call   1889e <kernel_strlen>
   18c6c:	83 c4 04             	add    $0x4,%esp
   18c6f:	01 45 f8             	add    %eax,-0x8(%ebp)
   18c72:	eb 57                	jmp    18ccb <kernel_vsprintf+0x127>
            }
            else if(ch == 'x')
   18c74:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   18c78:	75 2e                	jne    18ca8 <kernel_vsprintf+0x104>
            {   
                int num = va_arg(args, int);
   18c7a:	8b 45 10             	mov    0x10(%ebp),%eax
   18c7d:	8d 50 04             	lea    0x4(%eax),%edx
   18c80:	89 55 10             	mov    %edx,0x10(%ebp)
   18c83:	8b 00                	mov    (%eax),%eax
   18c85:	89 45 e8             	mov    %eax,-0x18(%ebp)
                kernel_itoa(temp, num, 16);
   18c88:	6a 10                	push   $0x10
   18c8a:	ff 75 e8             	pushl  -0x18(%ebp)
   18c8d:	ff 75 f8             	pushl  -0x8(%ebp)
   18c90:	e8 ac fd ff ff       	call   18a41 <kernel_itoa>
   18c95:	83 c4 0c             	add    $0xc,%esp
                temp += kernel_strlen(temp);
   18c98:	ff 75 f8             	pushl  -0x8(%ebp)
   18c9b:	e8 fe fb ff ff       	call   1889e <kernel_strlen>
   18ca0:	83 c4 04             	add    $0x4,%esp
   18ca3:	01 45 f8             	add    %eax,-0x8(%ebp)
   18ca6:	eb 23                	jmp    18ccb <kernel_vsprintf+0x127>
            }
            else if(ch == 'c'){
   18ca8:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   18cac:	75 1d                	jne    18ccb <kernel_vsprintf+0x127>
                char ch = va_arg(args, int);
   18cae:	8b 45 10             	mov    0x10(%ebp),%eax
   18cb1:	8d 50 04             	lea    0x4(%eax),%edx
   18cb4:	89 55 10             	mov    %edx,0x10(%ebp)
   18cb7:	8b 00                	mov    (%eax),%eax
   18cb9:	88 45 ee             	mov    %al,-0x12(%ebp)
                *temp++ = ch;
   18cbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   18cbf:	8d 50 01             	lea    0x1(%eax),%edx
   18cc2:	89 55 f8             	mov    %edx,-0x8(%ebp)
   18cc5:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   18cc9:	88 10                	mov    %dl,(%eax)
            }
            state = NORMAL;
   18ccb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            break;   
   18cd2:	90                   	nop
    while(ch = *fmt++)
   18cd3:	8b 45 0c             	mov    0xc(%ebp),%eax
   18cd6:	8d 50 01             	lea    0x1(%eax),%edx
   18cd9:	89 55 0c             	mov    %edx,0xc(%ebp)
   18cdc:	0f b6 00             	movzbl (%eax),%eax
   18cdf:	88 45 ef             	mov    %al,-0x11(%ebp)
   18ce2:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   18ce6:	0f 85 d0 fe ff ff    	jne    18bbc <kernel_vsprintf+0x18>
        }
    }
}
   18cec:	90                   	nop
   18ced:	c9                   	leave  
   18cee:	c3                   	ret    

00018cef <pannic>:


void pannic(const char* file, int line, const char* func, const char* expr){
   18cef:	55                   	push   %ebp
   18cf0:	89 e5                	mov    %esp,%ebp
   18cf2:	83 ec 08             	sub    $0x8,%esp
        log_printf("assert failed %s", expr);
   18cf5:	83 ec 08             	sub    $0x8,%esp
   18cf8:	ff 75 14             	pushl  0x14(%ebp)
   18cfb:	68 e0 a1 01 00       	push   $0x1a1e0
   18d00:	e8 47 02 00 00       	call   18f4c <log_printf>
   18d05:	83 c4 10             	add    $0x10,%esp
        log_printf("file is %s\nline is %d\nfunc is %s\n", file, line, func);
   18d08:	ff 75 10             	pushl  0x10(%ebp)
   18d0b:	ff 75 0c             	pushl  0xc(%ebp)
   18d0e:	ff 75 08             	pushl  0x8(%ebp)
   18d11:	68 f4 a1 01 00       	push   $0x1a1f4
   18d16:	e8 31 02 00 00       	call   18f4c <log_printf>
   18d1b:	83 c4 10             	add    $0x10,%esp
        for(;;){
            hlt();
   18d1e:	e8 4c fa ff ff       	call   1876f <hlt>
   18d23:	eb f9                	jmp    18d1e <pannic+0x2f>

00018d25 <list_is_empty>:
static inline int list_is_empty(list_t *list) {
   18d25:	55                   	push   %ebp
   18d26:	89 e5                	mov    %esp,%ebp
    return list->count == 0;
   18d28:	8b 45 08             	mov    0x8(%ebp),%eax
   18d2b:	8b 40 08             	mov    0x8(%eax),%eax
   18d2e:	85 c0                	test   %eax,%eax
   18d30:	0f 94 c0             	sete   %al
   18d33:	0f b6 c0             	movzbl %al,%eax
}
   18d36:	5d                   	pop    %ebp
   18d37:	c3                   	ret    

00018d38 <list_init>:

/**
 * 初始化链表
 * @param list 待初始化的链表
 */
void list_init(list_t *list) {
   18d38:	55                   	push   %ebp
   18d39:	89 e5                	mov    %esp,%ebp
    list->first = list->last = (list_node_t *)0;
   18d3b:	8b 45 08             	mov    0x8(%ebp),%eax
   18d3e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   18d45:	8b 45 08             	mov    0x8(%ebp),%eax
   18d48:	8b 50 04             	mov    0x4(%eax),%edx
   18d4b:	8b 45 08             	mov    0x8(%ebp),%eax
   18d4e:	89 10                	mov    %edx,(%eax)
    list->count = 0;
   18d50:	8b 45 08             	mov    0x8(%ebp),%eax
   18d53:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   18d5a:	90                   	nop
   18d5b:	5d                   	pop    %ebp
   18d5c:	c3                   	ret    

00018d5d <list_insert_first>:
/**
 * 将指定表项插入到指定链表的头部
 * @param list 待插入的链表
 * @param node 待插入的结点
 */
void list_insert_first(list_t *list, list_node_t *node) {
   18d5d:	55                   	push   %ebp
   18d5e:	89 e5                	mov    %esp,%ebp
    // 设置好待插入结点的前后，前面为空
    node->next = list->first;
   18d60:	8b 45 08             	mov    0x8(%ebp),%eax
   18d63:	8b 10                	mov    (%eax),%edx
   18d65:	8b 45 0c             	mov    0xc(%ebp),%eax
   18d68:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre = (list_node_t *)0;
   18d6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   18d6e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    // 如果为空，需要同时设置first和last指向自己
    if (list_is_empty(list)) {
   18d74:	ff 75 08             	pushl  0x8(%ebp)
   18d77:	e8 a9 ff ff ff       	call   18d25 <list_is_empty>
   18d7c:	83 c4 04             	add    $0x4,%esp
   18d7f:	85 c0                	test   %eax,%eax
   18d81:	74 15                	je     18d98 <list_insert_first+0x3b>
        list->last = list->first = node;
   18d83:	8b 45 08             	mov    0x8(%ebp),%eax
   18d86:	8b 55 0c             	mov    0xc(%ebp),%edx
   18d89:	89 10                	mov    %edx,(%eax)
   18d8b:	8b 45 08             	mov    0x8(%ebp),%eax
   18d8e:	8b 10                	mov    (%eax),%edx
   18d90:	8b 45 08             	mov    0x8(%ebp),%eax
   18d93:	89 50 04             	mov    %edx,0x4(%eax)
   18d96:	eb 12                	jmp    18daa <list_insert_first+0x4d>
    } else {
        // 否则，设置好原本第一个结点的pre
        list->first->pre = node;
   18d98:	8b 45 08             	mov    0x8(%ebp),%eax
   18d9b:	8b 00                	mov    (%eax),%eax
   18d9d:	8b 55 0c             	mov    0xc(%ebp),%edx
   18da0:	89 10                	mov    %edx,(%eax)

        // 调整first指向
        list->first = node;
   18da2:	8b 45 08             	mov    0x8(%ebp),%eax
   18da5:	8b 55 0c             	mov    0xc(%ebp),%edx
   18da8:	89 10                	mov    %edx,(%eax)
    }

    list->count++;
   18daa:	8b 45 08             	mov    0x8(%ebp),%eax
   18dad:	8b 40 08             	mov    0x8(%eax),%eax
   18db0:	8d 50 01             	lea    0x1(%eax),%edx
   18db3:	8b 45 08             	mov    0x8(%ebp),%eax
   18db6:	89 50 08             	mov    %edx,0x8(%eax)
}
   18db9:	90                   	nop
   18dba:	c9                   	leave  
   18dbb:	c3                   	ret    

00018dbc <list_insert_last>:
/**
 * 将指定表项插入到指定链表的尾部
 * @param list 操作的链表
 * @param node 待插入的结点
 */
void list_insert_last(list_t *list, list_node_t *node) {
   18dbc:	55                   	push   %ebp
   18dbd:	89 e5                	mov    %esp,%ebp
    // 设置好结点本身
    node->pre = list->last;
   18dbf:	8b 45 08             	mov    0x8(%ebp),%eax
   18dc2:	8b 50 04             	mov    0x4(%eax),%edx
   18dc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   18dc8:	89 10                	mov    %edx,(%eax)
    node->next = (list_node_t*)0;
   18dca:	8b 45 0c             	mov    0xc(%ebp),%eax
   18dcd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    // 表空，则first/last都指向唯一的node
    if (list_is_empty(list)) {
   18dd4:	ff 75 08             	pushl  0x8(%ebp)
   18dd7:	e8 49 ff ff ff       	call   18d25 <list_is_empty>
   18ddc:	83 c4 04             	add    $0x4,%esp
   18ddf:	85 c0                	test   %eax,%eax
   18de1:	74 16                	je     18df9 <list_insert_last+0x3d>
        list->first = list->last = node;
   18de3:	8b 45 08             	mov    0x8(%ebp),%eax
   18de6:	8b 55 0c             	mov    0xc(%ebp),%edx
   18de9:	89 50 04             	mov    %edx,0x4(%eax)
   18dec:	8b 45 08             	mov    0x8(%ebp),%eax
   18def:	8b 50 04             	mov    0x4(%eax),%edx
   18df2:	8b 45 08             	mov    0x8(%ebp),%eax
   18df5:	89 10                	mov    %edx,(%eax)
   18df7:	eb 15                	jmp    18e0e <list_insert_last+0x52>
    } else {
        // 否则，调整last结点的向一指向为node
        list->last->next = node;
   18df9:	8b 45 08             	mov    0x8(%ebp),%eax
   18dfc:	8b 40 04             	mov    0x4(%eax),%eax
   18dff:	8b 55 0c             	mov    0xc(%ebp),%edx
   18e02:	89 50 04             	mov    %edx,0x4(%eax)

        // node变成了新的后继结点
        list->last = node;
   18e05:	8b 45 08             	mov    0x8(%ebp),%eax
   18e08:	8b 55 0c             	mov    0xc(%ebp),%edx
   18e0b:	89 50 04             	mov    %edx,0x4(%eax)
    }

    list->count++;
   18e0e:	8b 45 08             	mov    0x8(%ebp),%eax
   18e11:	8b 40 08             	mov    0x8(%eax),%eax
   18e14:	8d 50 01             	lea    0x1(%eax),%edx
   18e17:	8b 45 08             	mov    0x8(%ebp),%eax
   18e1a:	89 50 08             	mov    %edx,0x8(%eax)
}
   18e1d:	90                   	nop
   18e1e:	c9                   	leave  
   18e1f:	c3                   	ret    

00018e20 <list_remove_first>:
/**
 * 移除指定链表的头部
 * @param list 操作的链表
 * @return 链表的第一个结点
 */
list_node_t* list_remove_first(list_t *list) {
   18e20:	55                   	push   %ebp
   18e21:	89 e5                	mov    %esp,%ebp
   18e23:	83 ec 10             	sub    $0x10,%esp
    // 表项为空，返回空
    if (list_is_empty(list)) {
   18e26:	ff 75 08             	pushl  0x8(%ebp)
   18e29:	e8 f7 fe ff ff       	call   18d25 <list_is_empty>
   18e2e:	83 c4 04             	add    $0x4,%esp
   18e31:	85 c0                	test   %eax,%eax
   18e33:	74 07                	je     18e3c <list_remove_first+0x1c>
        return (list_node_t*)0;
   18e35:	b8 00 00 00 00       	mov    $0x0,%eax
   18e3a:	eb 5a                	jmp    18e96 <list_remove_first+0x76>
    }

    // 取第一个结点
    list_node_t * remove_node = list->first;
   18e3c:	8b 45 08             	mov    0x8(%ebp),%eax
   18e3f:	8b 00                	mov    (%eax),%eax
   18e41:	89 45 fc             	mov    %eax,-0x4(%ebp)

    // 将first往表尾移1个，跳过刚才移过的那个，如果没有后继，则first=0
    list->first = remove_node->next;
   18e44:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18e47:	8b 50 04             	mov    0x4(%eax),%edx
   18e4a:	8b 45 08             	mov    0x8(%ebp),%eax
   18e4d:	89 10                	mov    %edx,(%eax)
    if (list->first == (list_node_t *)0) {
   18e4f:	8b 45 08             	mov    0x8(%ebp),%eax
   18e52:	8b 00                	mov    (%eax),%eax
   18e54:	85 c0                	test   %eax,%eax
   18e56:	75 0c                	jne    18e64 <list_remove_first+0x44>
        // node为最后一个结点
        list->last = (list_node_t*)0;
   18e58:	8b 45 08             	mov    0x8(%ebp),%eax
   18e5b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   18e62:	eb 0c                	jmp    18e70 <list_remove_first+0x50>
    } else {
        // 非最后一结点，将后继的前驱清0
        remove_node->next->pre = (list_node_t *)0;
   18e64:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18e67:	8b 40 04             	mov    0x4(%eax),%eax
   18e6a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }

    // 调整node自己，置0，因为没有后继结点
    remove_node->next = remove_node->pre = (list_node_t*)0;
   18e70:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18e73:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   18e79:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18e7c:	8b 10                	mov    (%eax),%edx
   18e7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   18e81:	89 50 04             	mov    %edx,0x4(%eax)

    // 同时调整计数值
    list->count--;
   18e84:	8b 45 08             	mov    0x8(%ebp),%eax
   18e87:	8b 40 08             	mov    0x8(%eax),%eax
   18e8a:	8d 50 ff             	lea    -0x1(%eax),%edx
   18e8d:	8b 45 08             	mov    0x8(%ebp),%eax
   18e90:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   18e93:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   18e96:	c9                   	leave  
   18e97:	c3                   	ret    

00018e98 <list_remove>:

/**
 * 移除指定链表的中的表项
 * 不检查node是否在结点中
 */
list_node_t * list_remove(list_t *list, list_node_t *remove_node) {
   18e98:	55                   	push   %ebp
   18e99:	89 e5                	mov    %esp,%ebp
    // 如果是头，头往前移
    if (remove_node == list->first) {
   18e9b:	8b 45 08             	mov    0x8(%ebp),%eax
   18e9e:	8b 00                	mov    (%eax),%eax
   18ea0:	39 45 0c             	cmp    %eax,0xc(%ebp)
   18ea3:	75 0b                	jne    18eb0 <list_remove+0x18>
        list->first = remove_node->next;
   18ea5:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ea8:	8b 50 04             	mov    0x4(%eax),%edx
   18eab:	8b 45 08             	mov    0x8(%ebp),%eax
   18eae:	89 10                	mov    %edx,(%eax)
    }

    // 如果是尾，则尾往回移
    if (remove_node == list->last) {
   18eb0:	8b 45 08             	mov    0x8(%ebp),%eax
   18eb3:	8b 40 04             	mov    0x4(%eax),%eax
   18eb6:	39 45 0c             	cmp    %eax,0xc(%ebp)
   18eb9:	75 0b                	jne    18ec6 <list_remove+0x2e>
        list->last = remove_node->pre;
   18ebb:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ebe:	8b 10                	mov    (%eax),%edx
   18ec0:	8b 45 08             	mov    0x8(%ebp),%eax
   18ec3:	89 50 04             	mov    %edx,0x4(%eax)
    }

    // 如果有前，则调整前的后继
    if (remove_node->pre) {
   18ec6:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ec9:	8b 00                	mov    (%eax),%eax
   18ecb:	85 c0                	test   %eax,%eax
   18ecd:	74 0e                	je     18edd <list_remove+0x45>
        remove_node->pre->next = remove_node->next;
   18ecf:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ed2:	8b 00                	mov    (%eax),%eax
   18ed4:	8b 55 0c             	mov    0xc(%ebp),%edx
   18ed7:	8b 52 04             	mov    0x4(%edx),%edx
   18eda:	89 50 04             	mov    %edx,0x4(%eax)
    }

    // 如果有后，则调整后往前的
    if (remove_node->next) {
   18edd:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ee0:	8b 40 04             	mov    0x4(%eax),%eax
   18ee3:	85 c0                	test   %eax,%eax
   18ee5:	74 0d                	je     18ef4 <list_remove+0x5c>
        remove_node->next->pre = remove_node->pre;
   18ee7:	8b 45 0c             	mov    0xc(%ebp),%eax
   18eea:	8b 40 04             	mov    0x4(%eax),%eax
   18eed:	8b 55 0c             	mov    0xc(%ebp),%edx
   18ef0:	8b 12                	mov    (%edx),%edx
   18ef2:	89 10                	mov    %edx,(%eax)
    }

    // 清空node指向
    remove_node->pre = remove_node->next = (list_node_t*)0;
   18ef4:	8b 45 0c             	mov    0xc(%ebp),%eax
   18ef7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   18efe:	8b 45 0c             	mov    0xc(%ebp),%eax
   18f01:	8b 50 04             	mov    0x4(%eax),%edx
   18f04:	8b 45 0c             	mov    0xc(%ebp),%eax
   18f07:	89 10                	mov    %edx,(%eax)
    --list->count;
   18f09:	8b 45 08             	mov    0x8(%ebp),%eax
   18f0c:	8b 40 08             	mov    0x8(%eax),%eax
   18f0f:	8d 50 ff             	lea    -0x1(%eax),%edx
   18f12:	8b 45 08             	mov    0x8(%ebp),%eax
   18f15:	89 50 08             	mov    %edx,0x8(%eax)
    return remove_node;
   18f18:	8b 45 0c             	mov    0xc(%ebp),%eax
}
   18f1b:	5d                   	pop    %ebp
   18f1c:	c3                   	ret    

00018f1d <log_init>:
#include "dev/dev.h"
#define USE_LOG             0
static mutex_t mutex;
#define COM1_PORT           0x3F8  
static int log_dev_id;
void log_init (void) {
   18f1d:	55                   	push   %ebp
   18f1e:	89 e5                	mov    %esp,%ebp
   18f20:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   18f23:	83 ec 0c             	sub    $0xc,%esp
   18f26:	68 20 dc 05 00       	push   $0x5dc20
   18f2b:	e8 26 f3 ff ff       	call   18256 <mutex_init>
   18f30:	83 c4 10             	add    $0x10,%esp
    log_dev_id = dev_open(DEV_TTY, 0, 0);
   18f33:	83 ec 04             	sub    $0x4,%esp
   18f36:	6a 00                	push   $0x0
   18f38:	6a 00                	push   $0x0
   18f3a:	6a 01                	push   $0x1
   18f3c:	e8 98 b0 ff ff       	call   13fd9 <dev_open>
   18f41:	83 c4 10             	add    $0x10,%esp
   18f44:	a3 34 dc 05 00       	mov    %eax,0x5dc34

    // If serial is not faulty set it in normal operation mode
    // (not-loopback with IRQs enabled and OUT#1 and OUT#2 bits enabled)
    outb(COM1_PORT + 4, 0x0F);
#endif 
}
   18f49:	90                   	nop
   18f4a:	c9                   	leave  
   18f4b:	c3                   	ret    

00018f4c <log_printf>:

void log_printf(const char * fmt, ...) {
   18f4c:	55                   	push   %ebp
   18f4d:	89 e5                	mov    %esp,%ebp
   18f4f:	81 ec 98 00 00 00    	sub    $0x98,%esp
    
    char buf[128];
    kernel_memset(buf, '\0', sizeof(buf));
   18f55:	83 ec 04             	sub    $0x4,%esp
   18f58:	68 80 00 00 00       	push   $0x80
   18f5d:	6a 00                	push   $0x0
   18f5f:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   18f65:	50                   	push   %eax
   18f66:	e8 37 fa ff ff       	call   189a2 <kernel_memset>
   18f6b:	83 c4 10             	add    $0x10,%esp
    va_list args;
    va_start(args, fmt);
   18f6e:	8d 45 0c             	lea    0xc(%ebp),%eax
   18f71:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
    kernel_vsprintf(buf, fmt, args);
   18f77:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
   18f7d:	83 ec 04             	sub    $0x4,%esp
   18f80:	50                   	push   %eax
   18f81:	ff 75 08             	pushl  0x8(%ebp)
   18f84:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   18f8a:	50                   	push   %eax
   18f8b:	e8 14 fc ff ff       	call   18ba4 <kernel_vsprintf>
   18f90:	83 c4 10             	add    $0x10,%esp
    va_end(args);
    mutex_lock(&mutex);
   18f93:	83 ec 0c             	sub    $0xc,%esp
   18f96:	68 20 dc 05 00       	push   $0x5dc20
   18f9b:	e8 e4 f2 ff ff       	call   18284 <mutex_lock>
   18fa0:	83 c4 10             	add    $0x10,%esp
    }

    outb(COM1_PORT, '\r');
    outb(COM1_PORT, '\n');
#else
    dev_write(log_dev_id, 0, "log:", 4);
   18fa3:	a1 34 dc 05 00       	mov    0x5dc34,%eax
   18fa8:	6a 04                	push   $0x4
   18faa:	68 38 a2 01 00       	push   $0x1a238
   18faf:	6a 00                	push   $0x0
   18fb1:	50                   	push   %eax
   18fb2:	e8 b8 b1 ff ff       	call   1416f <dev_write>
   18fb7:	83 c4 10             	add    $0x10,%esp
    dev_write(log_dev_id, 0, buf, kernel_strlen(buf));
   18fba:	83 ec 0c             	sub    $0xc,%esp
   18fbd:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   18fc3:	50                   	push   %eax
   18fc4:	e8 d5 f8 ff ff       	call   1889e <kernel_strlen>
   18fc9:	83 c4 10             	add    $0x10,%esp
   18fcc:	89 c2                	mov    %eax,%edx
   18fce:	a1 34 dc 05 00       	mov    0x5dc34,%eax
   18fd3:	52                   	push   %edx
   18fd4:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
   18fda:	52                   	push   %edx
   18fdb:	6a 00                	push   $0x0
   18fdd:	50                   	push   %eax
   18fde:	e8 8c b1 ff ff       	call   1416f <dev_write>
   18fe3:	83 c4 10             	add    $0x10,%esp
    // console_write(0, buf, kernel_strlen(buf));
    char c = '\n';
   18fe6:	c6 85 73 ff ff ff 0a 	movb   $0xa,-0x8d(%ebp)
    dev_write(log_dev_id, 0, &c, 1);
   18fed:	a1 34 dc 05 00       	mov    0x5dc34,%eax
   18ff2:	6a 01                	push   $0x1
   18ff4:	8d 95 73 ff ff ff    	lea    -0x8d(%ebp),%edx
   18ffa:	52                   	push   %edx
   18ffb:	6a 00                	push   $0x0
   18ffd:	50                   	push   %eax
   18ffe:	e8 6c b1 ff ff       	call   1416f <dev_write>
   19003:	83 c4 10             	add    $0x10,%esp
    // console_write(0, &c, 1);
#endif
    mutex_unlock(&mutex);
   19006:	83 ec 0c             	sub    $0xc,%esp
   19009:	68 20 dc 05 00       	push   $0x5dc20
   1900e:	e8 07 f3 ff ff       	call   1831a <mutex_unlock>
   19013:	83 c4 10             	add    $0x10,%esp
   19016:	90                   	nop
   19017:	c9                   	leave  
   19018:	c3                   	ret    

Disassembly of section .first_task:

80000000 <_first_task_entry>:
	.text
	.global _first_task_entry
	.extern first_task_main 
//全局可见可在.c文件中引用
_first_task_entry:
	mov %ss, %ax
80000000:	66 8c d0             	mov    %ss,%ax
    mov %ax, %ds
80000003:	8e d8                	mov    %eax,%ds
	mov %ax, %es
80000005:	8e c0                	mov    %eax,%es
	mov %ax, %fs
80000007:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
80000009:	8e e8                	mov    %eax,%gs
8000000b:	e9 00 00 00 00       	jmp    80000010 <first_task_main>

80000010 <first_task_main>:
#include "core/task.h"
#include "tools/log.h"
#include "applib/lib_syscall.h"
#include "dev/tty.h"
void first_task_main(void)
{
80000010:	55                   	push   %ebp
80000011:	89 e5                	mov    %esp,%ebp
80000013:	83 ec 28             	sub    $0x28,%esp
    //     mprint_msg("parent: %d", count);
    // }

    // pid = getpid();

        for (int i = 0; i < 4; i++) {
80000016:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
8000001d:	e9 90 00 00 00       	jmp    800000b2 <first_task_main+0xa2>
        int pid = fork();
80000022:	e8 82 01 00 00       	call   800001a9 <fork>
80000027:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (pid < 0) {
8000002a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
8000002e:	79 14                	jns    80000044 <first_task_main+0x34>
            mprint_msg("create shell proc failed", 0);
80000030:	83 ec 08             	sub    $0x8,%esp
80000033:	6a 00                	push   $0x0
80000035:	68 cd 00 00 80       	push   $0x800000cd
8000003a:	e8 42 01 00 00       	call   80000181 <mprint_msg>
8000003f:	83 c4 10             	add    $0x10,%esp
            break;
80000042:	eb 78                	jmp    800000bc <first_task_main+0xac>
        } else if (pid == 0) {
80000044:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
80000048:	75 64                	jne    800000ae <first_task_main+0x9e>
            char tty_num[] = "/dev/tty?";
8000004a:	c7 45 e6 2f 64 65 76 	movl   $0x7665642f,-0x1a(%ebp)
80000051:	c7 45 ea 2f 74 74 79 	movl   $0x7974742f,-0x16(%ebp)
80000058:	66 c7 45 ee 3f 00    	movw   $0x3f,-0x12(%ebp)
            tty_num[sizeof(tty_num) - 2] = i + '0';
8000005e:	8b 45 f4             	mov    -0xc(%ebp),%eax
80000061:	83 c0 30             	add    $0x30,%eax
80000064:	88 45 ee             	mov    %al,-0x12(%ebp)
            char * argv[] = {tty_num, (char *)0};
80000067:	8d 45 e6             	lea    -0x1a(%ebp),%eax
8000006a:	89 45 dc             	mov    %eax,-0x24(%ebp)
8000006d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
            execve("shell.elf", argv, (char **)0);
80000074:	83 ec 04             	sub    $0x4,%esp
80000077:	6a 00                	push   $0x0
80000079:	8d 45 dc             	lea    -0x24(%ebp),%eax
8000007c:	50                   	push   %eax
8000007d:	68 e6 00 00 80       	push   $0x800000e6
80000082:	e8 5a 01 00 00       	call   800001e1 <execve>
80000087:	83 c4 10             	add    $0x10,%esp
            mprint_msg("create shell proc failed", 0);
8000008a:	83 ec 08             	sub    $0x8,%esp
8000008d:	6a 00                	push   $0x0
8000008f:	68 cd 00 00 80       	push   $0x800000cd
80000094:	e8 e8 00 00 00       	call   80000181 <mprint_msg>
80000099:	83 c4 10             	add    $0x10,%esp
            while (1) {
                sleep(10000);
8000009c:	83 ec 0c             	sub    $0xc,%esp
8000009f:	68 10 27 00 00       	push   $0x2710
800000a4:	e8 93 00 00 00       	call   8000013c <sleep>
800000a9:	83 c4 10             	add    $0x10,%esp
800000ac:	eb ee                	jmp    8000009c <first_task_main+0x8c>
        for (int i = 0; i < 4; i++) {
800000ae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
800000b2:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
800000b6:	0f 8e 66 ff ff ff    	jle    80000022 <first_task_main+0x12>
            }
        }
    }
    for (;;) {
        int status;
        wait(&status);
800000bc:	83 ec 0c             	sub    $0xc,%esp
800000bf:	8d 45 d8             	lea    -0x28(%ebp),%eax
800000c2:	50                   	push   %eax
800000c3:	e8 fa 02 00 00       	call   800003c2 <wait>
800000c8:	83 c4 10             	add    $0x10,%esp
    for (;;) {
800000cb:	eb ef                	jmp    800000bc <first_task_main+0xac>
800000cd:	63 72 65             	arpl   %si,0x65(%edx)
800000d0:	61                   	popa   
800000d1:	74 65                	je     80000138 <sys_call+0x48>
800000d3:	20 73 68             	and    %dh,0x68(%ebx)
800000d6:	65 6c                	gs insb (%dx),%es:(%edi)
800000d8:	6c                   	insb   (%dx),%es:(%edi)
800000d9:	20 70 72             	and    %dh,0x72(%eax)
800000dc:	6f                   	outsl  %ds:(%esi),(%dx)
800000dd:	63 20                	arpl   %sp,(%eax)
800000df:	66 61                	popaw  
800000e1:	69 6c 65 64 00 73 68 	imul   $0x65687300,0x64(%ebp,%eiz,2),%ebp
800000e8:	65 
800000e9:	6c                   	insb   (%dx),%es:(%edi)
800000ea:	6c                   	insb   (%dx),%es:(%edi)
800000eb:	2e 65 6c             	cs gs insb (%dx),%es:(%edi)
800000ee:	66                   	data16
	...

800000f0 <sys_call>:
    uint32_t arg2;
    uint32_t arg3;
}sys_arg_t;

static inline int sys_call(sys_arg_t* args)
{
800000f0:	55                   	push   %ebp
800000f1:	89 e5                	mov    %esp,%ebp
800000f3:	57                   	push   %edi
800000f4:	56                   	push   %esi
800000f5:	53                   	push   %ebx
800000f6:	83 ec 10             	sub    $0x10,%esp
	uint32_t addr[] = {0, SYSTEM_SELECTOR | 0};
800000f9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
80000100:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%ebp)
        "push %[arg2]\n\t"
        "push %[arg1]\n\t"
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcalll *(%[a])":"=a"(ret)
        :[arg3]"r"(args->arg3), [arg2]"r"(args->arg2),
80000107:	8b 45 08             	mov    0x8(%ebp),%eax
8000010a:	8b 40 10             	mov    0x10(%eax),%eax
8000010d:	8b 55 08             	mov    0x8(%ebp),%edx
80000110:	8b 52 0c             	mov    0xc(%edx),%edx
        [arg1]"r"(args->arg1),[arg0]"r"(args->arg0),[id]"r"(args->id),[a]"r"(addr));
80000113:	8b 4d 08             	mov    0x8(%ebp),%ecx
80000116:	8b 49 08             	mov    0x8(%ecx),%ecx
80000119:	8b 5d 08             	mov    0x8(%ebp),%ebx
8000011c:	8b 5b 04             	mov    0x4(%ebx),%ebx
8000011f:	8b 75 08             	mov    0x8(%ebp),%esi
80000122:	8b 36                	mov    (%esi),%esi
	__asm__ __volatile__(
80000124:	8d 7d e8             	lea    -0x18(%ebp),%edi
80000127:	50                   	push   %eax
80000128:	52                   	push   %edx
80000129:	51                   	push   %ecx
8000012a:	53                   	push   %ebx
8000012b:	56                   	push   %esi
8000012c:	ff 1f                	lcall  *(%edi)
8000012e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return ret;
80000131:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
80000134:	83 c4 10             	add    $0x10,%esp
80000137:	5b                   	pop    %ebx
80000138:	5e                   	pop    %esi
80000139:	5f                   	pop    %edi
8000013a:	5d                   	pop    %ebp
8000013b:	c3                   	ret    

8000013c <sleep>:
#include "applib/lib_syscall.h"

void sleep (int ms)
{
8000013c:	55                   	push   %ebp
8000013d:	89 e5                	mov    %esp,%ebp
8000013f:	83 ec 20             	sub    $0x20,%esp
    if(ms < 0)
80000142:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
80000146:	78 1b                	js     80000163 <sleep+0x27>
        return;
    sys_arg_t args;
    args.id = SYS_SLEEP;
80000148:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0 = ms;
8000014f:	8b 45 08             	mov    0x8(%ebp),%eax
80000152:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
80000155:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000158:	50                   	push   %eax
80000159:	e8 92 ff ff ff       	call   800000f0 <sys_call>
8000015e:	83 c4 04             	add    $0x4,%esp
80000161:	eb 01                	jmp    80000164 <sleep+0x28>
        return;
80000163:	90                   	nop
}
80000164:	c9                   	leave  
80000165:	c3                   	ret    

80000166 <getpid>:

uint32_t getpid(void)
{
80000166:	55                   	push   %ebp
80000167:	89 e5                	mov    %esp,%ebp
80000169:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_GETPID;
8000016c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
80000173:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000176:	50                   	push   %eax
80000177:	e8 74 ff ff ff       	call   800000f0 <sys_call>
8000017c:	83 c4 04             	add    $0x4,%esp
}
8000017f:	c9                   	leave  
80000180:	c3                   	ret    

80000181 <mprint_msg>:

void mprint_msg(char* fmt, int value)
{
80000181:	55                   	push   %ebp
80000182:	89 e5                	mov    %esp,%ebp
80000184:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_PRINTMSG;
80000187:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%ebp)
    args.arg0 = (uint32_t)fmt;
8000018e:	8b 45 08             	mov    0x8(%ebp),%eax
80000191:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (uint32_t)value;
80000194:	8b 45 0c             	mov    0xc(%ebp),%eax
80000197:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
8000019a:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000019d:	50                   	push   %eax
8000019e:	e8 4d ff ff ff       	call   800000f0 <sys_call>
800001a3:	83 c4 04             	add    $0x4,%esp
}
800001a6:	90                   	nop
800001a7:	c9                   	leave  
800001a8:	c3                   	ret    

800001a9 <fork>:

int fork(void)
{
800001a9:	55                   	push   %ebp
800001aa:	89 e5                	mov    %esp,%ebp
800001ac:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_FORK;
800001af:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    sys_call(&args);
800001b6:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001b9:	50                   	push   %eax
800001ba:	e8 31 ff ff ff       	call   800000f0 <sys_call>
800001bf:	83 c4 04             	add    $0x4,%esp
}
800001c2:	90                   	nop
800001c3:	c9                   	leave  
800001c4:	c3                   	ret    

800001c5 <yield>:

int yield(void)
{
800001c5:	55                   	push   %ebp
800001c6:	89 e5                	mov    %esp,%ebp
800001c8:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_YIELD;
800001cb:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)
    sys_call(&args);
800001d2:	8d 45 ec             	lea    -0x14(%ebp),%eax
800001d5:	50                   	push   %eax
800001d6:	e8 15 ff ff ff       	call   800000f0 <sys_call>
800001db:	83 c4 04             	add    $0x4,%esp
}
800001de:	90                   	nop
800001df:	c9                   	leave  
800001e0:	c3                   	ret    

800001e1 <execve>:

int execve(const char*name , char* const* argv, char* const* env)
{
800001e1:	55                   	push   %ebp
800001e2:	89 e5                	mov    %esp,%ebp
800001e4:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_EXECVE;
800001e7:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    args.arg0 = (int)name;
800001ee:	8b 45 08             	mov    0x8(%ebp),%eax
800001f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)argv;
800001f4:	8b 45 0c             	mov    0xc(%ebp),%eax
800001f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)env;
800001fa:	8b 45 10             	mov    0x10(%ebp),%eax
800001fd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    sys_call(&args);
80000200:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000203:	50                   	push   %eax
80000204:	e8 e7 fe ff ff       	call   800000f0 <sys_call>
80000209:	83 c4 04             	add    $0x4,%esp
}
8000020c:	90                   	nop
8000020d:	c9                   	leave  
8000020e:	c3                   	ret    

8000020f <open>:

int open(const char* name, int flag, ...)
{
8000020f:	55                   	push   %ebp
80000210:	89 e5                	mov    %esp,%ebp
80000212:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_OPEN;
80000215:	c7 45 ec 32 00 00 00 	movl   $0x32,-0x14(%ebp)
    args.arg0 = (int)name;
8000021c:	8b 45 08             	mov    0x8(%ebp),%eax
8000021f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = flag;
80000222:	8b 45 0c             	mov    0xc(%ebp),%eax
80000225:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
80000228:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000022b:	50                   	push   %eax
8000022c:	e8 bf fe ff ff       	call   800000f0 <sys_call>
80000231:	83 c4 04             	add    $0x4,%esp
}
80000234:	90                   	nop
80000235:	c9                   	leave  
80000236:	c3                   	ret    

80000237 <read>:
int read(int fd, char* buf, int size)
{
80000237:	55                   	push   %ebp
80000238:	89 e5                	mov    %esp,%ebp
8000023a:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_READ;
8000023d:	c7 45 ec 33 00 00 00 	movl   $0x33,-0x14(%ebp)
    args.arg0 = fd;
80000244:	8b 45 08             	mov    0x8(%ebp),%eax
80000247:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)buf;
8000024a:	8b 45 0c             	mov    0xc(%ebp),%eax
8000024d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = size;
80000250:	8b 45 10             	mov    0x10(%ebp),%eax
80000253:	89 45 f8             	mov    %eax,-0x8(%ebp)
    sys_call(&args);
80000256:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000259:	50                   	push   %eax
8000025a:	e8 91 fe ff ff       	call   800000f0 <sys_call>
8000025f:	83 c4 04             	add    $0x4,%esp
}
80000262:	90                   	nop
80000263:	c9                   	leave  
80000264:	c3                   	ret    

80000265 <write>:
int write(int fd, char* buf, int size)
{
80000265:	55                   	push   %ebp
80000266:	89 e5                	mov    %esp,%ebp
80000268:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_WRITE;
8000026b:	c7 45 ec 34 00 00 00 	movl   $0x34,-0x14(%ebp)
    args.arg0 = fd;
80000272:	8b 45 08             	mov    0x8(%ebp),%eax
80000275:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)buf;
80000278:	8b 45 0c             	mov    0xc(%ebp),%eax
8000027b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = size;
8000027e:	8b 45 10             	mov    0x10(%ebp),%eax
80000281:	89 45 f8             	mov    %eax,-0x8(%ebp)
    sys_call(&args);
80000284:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000287:	50                   	push   %eax
80000288:	e8 63 fe ff ff       	call   800000f0 <sys_call>
8000028d:	83 c4 04             	add    $0x4,%esp
}
80000290:	90                   	nop
80000291:	c9                   	leave  
80000292:	c3                   	ret    

80000293 <lseek>:
int lseek(int fd, int ptr, int dir)
{
80000293:	55                   	push   %ebp
80000294:	89 e5                	mov    %esp,%ebp
80000296:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_LSEEK;
80000299:	c7 45 ec 35 00 00 00 	movl   $0x35,-0x14(%ebp)
    args.arg0 = fd;
800002a0:	8b 45 08             	mov    0x8(%ebp),%eax
800002a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = ptr;
800002a6:	8b 45 0c             	mov    0xc(%ebp),%eax
800002a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = dir;
800002ac:	8b 45 10             	mov    0x10(%ebp),%eax
800002af:	89 45 f8             	mov    %eax,-0x8(%ebp)
    sys_call(&args);
800002b2:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002b5:	50                   	push   %eax
800002b6:	e8 35 fe ff ff       	call   800000f0 <sys_call>
800002bb:	83 c4 04             	add    $0x4,%esp
}
800002be:	90                   	nop
800002bf:	c9                   	leave  
800002c0:	c3                   	ret    

800002c1 <close>:
int close(int fd)
{
800002c1:	55                   	push   %ebp
800002c2:	89 e5                	mov    %esp,%ebp
800002c4:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_CLOSE;
800002c7:	c7 45 ec 36 00 00 00 	movl   $0x36,-0x14(%ebp)
    args.arg0 = fd;
800002ce:	8b 45 08             	mov    0x8(%ebp),%eax
800002d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
800002d4:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002d7:	50                   	push   %eax
800002d8:	e8 13 fe ff ff       	call   800000f0 <sys_call>
800002dd:	83 c4 04             	add    $0x4,%esp
}
800002e0:	90                   	nop
800002e1:	c9                   	leave  
800002e2:	c3                   	ret    

800002e3 <fstat>:

int fstat(int file, struct stat *st) {
800002e3:	55                   	push   %ebp
800002e4:	89 e5                	mov    %esp,%ebp
800002e6:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_FSTAT;
800002e9:	c7 45 ec 37 00 00 00 	movl   $0x37,-0x14(%ebp)
    args.arg0 = (int)file;
800002f0:	8b 45 08             	mov    0x8(%ebp),%eax
800002f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)st;
800002f6:	8b 45 0c             	mov    0xc(%ebp),%eax
800002f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return sys_call(&args);
800002fc:	8d 45 ec             	lea    -0x14(%ebp),%eax
800002ff:	50                   	push   %eax
80000300:	e8 eb fd ff ff       	call   800000f0 <sys_call>
80000305:	83 c4 04             	add    $0x4,%esp
}
80000308:	c9                   	leave  
80000309:	c3                   	ret    

8000030a <ioctl>:

int ioctl(int file, int cmd, int arg0, int arg1) {
8000030a:	55                   	push   %ebp
8000030b:	89 e5                	mov    %esp,%ebp
8000030d:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_IOCTL;
80000310:	c7 45 ec 3b 00 00 00 	movl   $0x3b,-0x14(%ebp)
    args.arg0 = file;
80000317:	8b 45 08             	mov    0x8(%ebp),%eax
8000031a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = cmd;
8000031d:	8b 45 0c             	mov    0xc(%ebp),%eax
80000320:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = arg0;
80000323:	8b 45 10             	mov    0x10(%ebp),%eax
80000326:	89 45 f8             	mov    %eax,-0x8(%ebp)
    args.arg1 = arg1;
80000329:	8b 45 14             	mov    0x14(%ebp),%eax
8000032c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return sys_call(&args);
8000032f:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000332:	50                   	push   %eax
80000333:	e8 b8 fd ff ff       	call   800000f0 <sys_call>
80000338:	83 c4 04             	add    $0x4,%esp
}
8000033b:	c9                   	leave  
8000033c:	c3                   	ret    

8000033d <isatty>:

int isatty(int file) {
8000033d:	55                   	push   %ebp
8000033e:	89 e5                	mov    %esp,%ebp
80000340:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_ISATTY;
80000343:	c7 45 ec 38 00 00 00 	movl   $0x38,-0x14(%ebp)
    args.arg0 = (int)file;
8000034a:	8b 45 08             	mov    0x8(%ebp),%eax
8000034d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
80000350:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000353:	50                   	push   %eax
80000354:	e8 97 fd ff ff       	call   800000f0 <sys_call>
80000359:	83 c4 04             	add    $0x4,%esp
}
8000035c:	c9                   	leave  
8000035d:	c3                   	ret    

8000035e <sbrk>:

void * sbrk(ptrdiff_t incr) {
8000035e:	55                   	push   %ebp
8000035f:	89 e5                	mov    %esp,%ebp
80000361:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_SBRK;
80000364:	c7 45 ec 39 00 00 00 	movl   $0x39,-0x14(%ebp)
    args.arg0 = (int)incr;
8000036b:	8b 45 08             	mov    0x8(%ebp),%eax
8000036e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return (void *)sys_call(&args);
80000371:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000374:	50                   	push   %eax
80000375:	e8 76 fd ff ff       	call   800000f0 <sys_call>
8000037a:	83 c4 04             	add    $0x4,%esp
}
8000037d:	c9                   	leave  
8000037e:	c3                   	ret    

8000037f <dup>:

int dup(int file) {
8000037f:	55                   	push   %ebp
80000380:	89 e5                	mov    %esp,%ebp
80000382:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_DUP;
80000385:	c7 45 ec 3a 00 00 00 	movl   $0x3a,-0x14(%ebp)
    args.arg0 = (int)file;
8000038c:	8b 45 08             	mov    0x8(%ebp),%eax
8000038f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
80000392:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000395:	50                   	push   %eax
80000396:	e8 55 fd ff ff       	call   800000f0 <sys_call>
8000039b:	83 c4 04             	add    $0x4,%esp
}
8000039e:	c9                   	leave  
8000039f:	c3                   	ret    

800003a0 <_exit>:

void _exit(int status)
{
800003a0:	55                   	push   %ebp
800003a1:	89 e5                	mov    %esp,%ebp
800003a3:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_EXIT;
800003a6:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%ebp)
    args.arg0 = status;
800003ad:	8b 45 08             	mov    0x8(%ebp),%eax
800003b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
800003b3:	8d 45 ec             	lea    -0x14(%ebp),%eax
800003b6:	50                   	push   %eax
800003b7:	e8 34 fd ff ff       	call   800000f0 <sys_call>
800003bc:	83 c4 04             	add    $0x4,%esp
}
800003bf:	90                   	nop
800003c0:	c9                   	leave  
800003c1:	c3                   	ret    

800003c2 <wait>:

int wait(int* status)
{
800003c2:	55                   	push   %ebp
800003c3:	89 e5                	mov    %esp,%ebp
800003c5:	83 ec 20             	sub    $0x20,%esp
    sys_arg_t args;
    args.id = SYS_WAIT;
800003c8:	c7 45 ec 06 00 00 00 	movl   $0x6,-0x14(%ebp)
    args.arg0 = (int)status;
800003cf:	8b 45 08             	mov    0x8(%ebp),%eax
800003d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return sys_call(&args);
800003d5:	8d 45 ec             	lea    -0x14(%ebp),%eax
800003d8:	50                   	push   %eax
800003d9:	e8 12 fd ff ff       	call   800000f0 <sys_call>
800003de:	83 c4 04             	add    $0x4,%esp
}
800003e1:	c9                   	leave  
800003e2:	c3                   	ret    
